<file path="Ast.cs">
using System.Collections.Generic;

namespace CTilde;

public enum AccessSpecifier { Public, Private }

// Base classes
public abstract record AstNode
{
    public AstNode? Parent { get; set; }

    public IEnumerable<AstNode> Ancestors()
    {
        var current = Parent;
        while (current != null)
        {
            yield return current;
            current = current.Parent;
        }
    }
}
public abstract record StatementNode : AstNode;
public abstract record ExpressionNode : AstNode;

// Program structure
public record ImportDirectiveNode(string LibraryName) : AstNode;
public record UsingDirectiveNode(string Namespace, string? Alias) : AstNode;
public record MemberVariableNode(bool IsConst, Token Type, int PointerLevel, Token Name, AccessSpecifier AccessLevel) : AstNode;
public record StructDefinitionNode(string Name, string? Namespace, List<MemberVariableNode> Members) : AstNode;
public record ParameterNode(Token Type, int PointerLevel, Token Name) : AstNode;
public record FunctionDeclarationNode(Token ReturnType, int ReturnPointerLevel, string Name, List<ParameterNode> Parameters, StatementNode? Body, string? OwnerStructName, AccessSpecifier AccessLevel, string? Namespace) : AstNode;
public record EnumDefinitionNode(string Name, string? Namespace, List<EnumMemberNode> Members) : AstNode; // NEW
public record EnumMemberNode(Token Name, int Value) : AstNode; // NEW

// New top-level structure for compilation units
public record CompilationUnitNode(string FilePath, List<UsingDirectiveNode> Usings, List<StructDefinitionNode> Structs, List<FunctionDeclarationNode> Functions, List<EnumDefinitionNode> Enums) : AstNode; // MODIFIED
public record ProgramNode(List<ImportDirectiveNode> Imports, List<CompilationUnitNode> CompilationUnits) : AstNode;


// Statements
public record BlockStatementNode(List<StatementNode> Statements) : StatementNode;
public record ReturnStatementNode(ExpressionNode? Expression) : StatementNode;
public record WhileStatementNode(ExpressionNode Condition, StatementNode Body) : StatementNode;
public record IfStatementNode(ExpressionNode Condition, StatementNode ThenBody, StatementNode? ElseBody) : StatementNode;
public record DeclarationStatementNode(bool IsConst, Token Type, int PointerLevel, Token Identifier, ExpressionNode? Initializer) : StatementNode;
public record ExpressionStatementNode(ExpressionNode Expression) : StatementNode;


// Expressions
public record InitializerListExpressionNode(List<ExpressionNode> Values) : ExpressionNode;
public record IntegerLiteralNode(int Value) : ExpressionNode;
public record StringLiteralNode(string Value, string Label) : ExpressionNode;
public record UnaryExpressionNode(Token Operator, ExpressionNode Right) : ExpressionNode;
public record AssignmentExpressionNode(ExpressionNode Left, ExpressionNode Right) : ExpressionNode;
public record VariableExpressionNode(Token Identifier) : ExpressionNode;
public record CallExpressionNode(ExpressionNode Callee, List<ExpressionNode> Arguments) : ExpressionNode;
public record BinaryExpressionNode(ExpressionNode Left, Token Operator, ExpressionNode Right) : ExpressionNode;
public record MemberAccessExpressionNode(ExpressionNode Left, Token Operator, Token Member) : ExpressionNode;
public record QualifiedAccessExpressionNode(Token Namespace, Token Member) : ExpressionNode;
</file>

<file path="Compiler.cs">
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CTilde;

public class Compiler
{
    public void Compile(string entryFilePath)
    {
        // 1. Discover all source files from #includes
        var preprocessor = new Preprocessor();
        var allFiles = preprocessor.DiscoverDependencies(entryFilePath);

        // 2. Parse each file into a CompilationUnit
        var compilationUnits = new List<CompilationUnitNode>();
        var allImports = new List<ImportDirectiveNode>();

        foreach (var file in allFiles)
        {
            var code = File.ReadAllText(file);
            var tokens = Tokenizer.Tokenize(code);
            var parser = new Parser(tokens);
            var unit = parser.Parse(file);

            // Collect all #import directives globally
            var importsInFile = parser.GetImports();
            allImports.AddRange(importsInFile);

            compilationUnits.Add(unit);
        }

        var programNode = new ProgramNode(allImports.DistinctBy(i => i.LibraryName).ToList(), compilationUnits);

        // 3. Generate Code
        var generator = new CodeGenerator(programNode);
        string asmCode = generator.Generate();

        // 4. Output
        File.WriteAllText("Output/output.asm", asmCode);
        Console.WriteLine("Compilation successful. Assembly code written to output.asm");
    }
}
</file>

<file path="Parser.cs">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

namespace CTilde;

public class Parser
{
    private readonly List<Token> _tokens;
    private int _position;
    private int _stringLabelCounter;
    private string? _currentNamespace;
    private readonly List<ImportDirectiveNode> _imports = new();

    public Parser(List<Token> tokens)
    {
        _tokens = tokens;
        _position = 0;
    }

    private Token Current => _position < _tokens.Count ? _tokens[_position] : new(TokenType.Unknown, string.Empty);
    private Token Peek(int offset) => _position + offset < _tokens.Count ? _tokens[_position + offset] : new(TokenType.Unknown, string.Empty);

    private Token Eat(TokenType expectedType)
    {
        var currentToken = Current;
        if (currentToken.Type == expectedType)
        {
            _position++;
            return currentToken;
        }
        throw new InvalidOperationException($"Expected token {expectedType} but got {currentToken.Type} ('{currentToken.Value}') at position {_position}");
    }

    public List<ImportDirectiveNode> GetImports() => _imports;

    public CompilationUnitNode Parse(string filePath)
    {
        var usings = new List<UsingDirectiveNode>();
        var structs = new List<StructDefinitionNode>();
        var functions = new List<FunctionDeclarationNode>();
        var enums = new List<EnumDefinitionNode>(); // NEW

        while (Current.Type != TokenType.Unknown)
        {
            if (Current.Type == TokenType.Hash)
            {
                var hashKeyword = Peek(1);
                if (hashKeyword.Type == TokenType.Identifier && hashKeyword.Value == "import")
                {
                    _imports.Add(ParseImportDirective());
                }
                else if (hashKeyword.Type == TokenType.Identifier && hashKeyword.Value == "include")
                {
                    ParseIncludeDirective(); // Handle and skip #include
                }
                else
                {
                    throw new InvalidOperationException($"Unexpected directive after #: '{hashKeyword.Value}'");
                }
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "using")
            {
                usings.Add(ParseUsingDirective());
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "namespace")
            {
                ParseNamespaceDirective();
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "struct")
            {
                structs.Add(ParseStructDefinition(functions));
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "enum") // NEW
            {
                enums.Add(ParseEnumDefinition()); // NEW
            }
            else
            {
                functions.Add(ParseGlobalFunction());
            }
        }

        var unitNode = new CompilationUnitNode(filePath, usings, structs, functions, enums); // MODIFIED
        SetParents(unitNode);
        return unitNode;
    }

    private UsingDirectiveNode ParseUsingDirective()
    {
        Eat(TokenType.Keyword); // using
        var firstIdentifier = Eat(TokenType.Identifier);
        string namespaceName;
        string? alias = null;

        if (Current.Type == TokenType.Assignment) // This is 'using alias = namespace;'
        {
            alias = firstIdentifier.Value; // 'rl' in 'using rl = raylib;'
            Eat(TokenType.Assignment);
            namespaceName = Eat(TokenType.Identifier).Value; // 'raylib' in 'using rl = raylib;'
        }
        else // This is 'using namespace;'
        {
            namespaceName = firstIdentifier.Value; // 'raylib' in 'using raylib;'
        }

        Eat(TokenType.Semicolon);
        return new UsingDirectiveNode(namespaceName, alias);
    }

    private void ParseNamespaceDirective()
    {
        Eat(TokenType.Keyword); // namespace
        var name = Eat(TokenType.Identifier);
        Eat(TokenType.Semicolon);
        _currentNamespace = name.Value;
    }

    private ImportDirectiveNode ParseImportDirective()
    {
        Eat(TokenType.Hash);
        Eat(TokenType.Identifier); // import
        var libNameToken = Eat(TokenType.StringLiteral);
        return new ImportDirectiveNode(libNameToken.Value);
    }

    private void ParseIncludeDirective()
    {
        Eat(TokenType.Hash);
        Eat(TokenType.Identifier); // include
        Eat(TokenType.StringLiteral); // "filename"
        // No AST node for include, as it's handled by the preprocessor
    }

    private EnumDefinitionNode ParseEnumDefinition() // NEW
    {
        Eat(TokenType.Keyword); // enum
        var enumName = Eat(TokenType.Identifier);
        Eat(TokenType.LeftBrace);

        var members = new List<EnumMemberNode>();
        int currentValue = 0; // Default enum value starts at 0 and increments

        while (Current.Type != TokenType.RightBrace)
        {
            var memberName = Eat(TokenType.Identifier);
            if (Current.Type == TokenType.Assignment)
            {
                Eat(TokenType.Assignment);
                var valueToken = Eat(TokenType.IntegerLiteral);
                if (!int.TryParse(valueToken.Value, out currentValue))
                {
                    throw new InvalidOperationException($"Invalid integer value for enum member '{memberName.Value}': '{valueToken.Value}'");
                }
            }
            members.Add(new EnumMemberNode(memberName, currentValue));
            currentValue++; // Increment for next default value

            if (Current.Type == TokenType.Comma)
            {
                Eat(TokenType.Comma);
            }
            else if (Current.Type != TokenType.RightBrace)
            {
                throw new InvalidOperationException($"Expected ',' or '}}' after enum member '{memberName.Value}'");
            }
        }

        Eat(TokenType.RightBrace);
        Eat(TokenType.Semicolon);
        return new EnumDefinitionNode(enumName.Value, _currentNamespace, members);
    }

    private StructDefinitionNode ParseStructDefinition(List<FunctionDeclarationNode> programFunctions)
    {
        Eat(TokenType.Keyword); // struct
        var structName = Eat(TokenType.Identifier);
        Eat(TokenType.LeftBrace);

        var members = new List<MemberVariableNode>();
        var currentAccess = AccessSpecifier.Private; // Default for struct is private

        while (Current.Type != TokenType.RightBrace)
        {
            if (Current.Type == TokenType.Keyword && (Current.Value == "public" || Current.Value == "private"))
            {
                currentAccess = (Current.Value == "public") ? AccessSpecifier.Public : AccessSpecifier.Private;
                Eat(TokenType.Keyword);
                Eat(TokenType.Colon);
                continue;
            }

            bool isConst = false; // Check for const for member variables
            if (Current.Type == TokenType.Keyword && Current.Value == "const")
            {
                isConst = true;
                Eat(TokenType.Keyword); // Eat 'const'
            }

            var (type, pointerLevel) = ParseType();
            var name = Eat(TokenType.Identifier);

            if (Current.Type == TokenType.LeftParen)
            {
                // This is a method definition.
                var methodNode = FinishParsingFunction(type, pointerLevel, name.Value, structName.Value, currentAccess, _currentNamespace);
                programFunctions.Add(methodNode);
            }
            else
            {
                // This is a member variable.
                members.Add(new MemberVariableNode(isConst, type, pointerLevel, name, currentAccess)); // Pass isConst
                Eat(TokenType.Semicolon);
            }
        }

        Eat(TokenType.RightBrace);
        Eat(TokenType.Semicolon);
        return new StructDefinitionNode(structName.Value, _currentNamespace, members);
    }

    private void SetParents(AstNode node)
    {
        foreach (var property in node.GetType().GetProperties())
        {
            if (property.CanWrite && property.Name == "Parent") continue;
            if (property.GetValue(node) is AstNode child)
            {
                var parentProp = child.GetType().GetProperty("Parent");
                if (parentProp != null && parentProp.CanWrite) parentProp.SetValue(child, node);
                SetParents(child);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children.ToList()) // ToList to avoid mutation issues
                {
                    var parentProp = c.GetType().GetProperty("Parent");
                    if (parentProp != null && parentProp.CanWrite) parentProp.SetValue(c, node);
                    SetParents(c);
                }
            }
        }
    }

    private (Token type, int pointerLevel) ParseType()
    {
        Token typeToken;
        string? namespaceQualifier = null;

        if (Current.Type == TokenType.Identifier && Peek(1).Type == TokenType.DoubleColon)
        {
            namespaceQualifier = Eat(TokenType.Identifier).Value;
            Eat(TokenType.DoubleColon);
        }

        if (Current.Type == TokenType.Keyword && Current.Value == "struct")
        {
            Eat(TokenType.Keyword); // struct
            typeToken = Eat(TokenType.Identifier);
        }
        else
        {
            typeToken = Current;
            _position++;
        }

        // Only qualify if it's an identifier (a UDT), not a keyword (int, char)
        if (typeToken.Type == TokenType.Identifier)
        {
            if (namespaceQualifier != null)
            {
                typeToken = new Token(typeToken.Type, $"{namespaceQualifier}::{typeToken.Value}");
            }
        }

        int pointerLevel = 0;
        while (Current.Type == TokenType.Star)
        {
            Eat(TokenType.Star);
            pointerLevel++;
        }
        return (typeToken, pointerLevel);
    }

    private FunctionDeclarationNode ParseGlobalFunction()
    {
        var (returnType, returnPointerLevel) = ParseType();
        var identifier = Eat(TokenType.Identifier);
        // Global functions are implicitly public
        return FinishParsingFunction(returnType, returnPointerLevel, identifier.Value, null, AccessSpecifier.Public, _currentNamespace);
    }

    private FunctionDeclarationNode FinishParsingFunction(Token returnType, int returnPointerLevel, string name, string? ownerStructName, AccessSpecifier accessLevel, string? namespaceName)
    {
        Eat(TokenType.LeftParen);

        var parameters = new List<ParameterNode>();
        if (Current.Type != TokenType.RightParen)
        {
            do
            {
                var (paramType, paramPointerLevel) = ParseType();
                var paramName = Eat(TokenType.Identifier);
                parameters.Add(new ParameterNode(paramType, paramPointerLevel, paramName));
            } while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
        }

        Eat(TokenType.RightParen);

        // If this is a method, prepend the implicit 'this' pointer to the parameter list.
        if (ownerStructName != null)
        {
            var thisTypeTokenValue = namespaceName != null ? $"{namespaceName}::{ownerStructName}" : ownerStructName;
            var thisParam = new ParameterNode(new Token(TokenType.Identifier, thisTypeTokenValue), 1, new Token(TokenType.Identifier, "this"));
            parameters.Insert(0, thisParam);
        }

        StatementNode? body = null;
        if (Current.Type == TokenType.LeftBrace)
        {
            body = ParseBlockStatement();
        }
        else
        {
            Eat(TokenType.Semicolon); // For function prototypes
        }

        return new FunctionDeclarationNode(returnType, returnPointerLevel, name, parameters, body, ownerStructName, accessLevel, namespaceName);
    }

    private BlockStatementNode ParseBlockStatement()
    {
        Eat(TokenType.LeftBrace);
        var statements = new List<StatementNode>();
        while (Current.Type != TokenType.RightBrace) statements.Add(ParseStatement());
        Eat(TokenType.RightBrace);
        return new BlockStatementNode(statements);
    }

    private StatementNode ParseStatement()
    {
        if (Current.Type == TokenType.Keyword)
        {
            switch (Current.Value)
            {
                case "return": return ParseReturnStatement();
                case "if": return ParseIfStatement();
                case "while": return ParseWhileStatement();
                case "const": // Handle 'const' keyword for declarations
                case "int":
                case "char":
                case "struct":
                    return ParseDeclarationStatement();
            }
        }

        // Disambiguate between a declaration and an expression statement
        bool isDeclaration = false;
        // Check for 'const' keyword, type keyword, or identifier followed by variable name
        if (Current.Type == TokenType.Identifier || (Current.Type == TokenType.Keyword && (Current.Value == "const" || Current.Value == "int" || Current.Value == "char" || Current.Value == "struct")))
        {
            int tempPos = _position; // Save current position for backtracking
            try
            {
                if (Current.Type == TokenType.Keyword && Current.Value == "const")
                {
                    _position++; // Consume 'const'
                }

                Token potentialTypeToken = Current;
                if (potentialTypeToken.Type == TokenType.Identifier || (potentialTypeToken.Type == TokenType.Keyword && (potentialTypeToken.Value == "int" || potentialTypeToken.Value == "char" || potentialTypeToken.Value == "struct")))
                {
                    _position++; // Consume potential type (Identifier or Keyword like 'int')
                    while (Current.Type == TokenType.Star) _position++; // Consume pointers

                    if (Current.Type == TokenType.Identifier) // Next must be the variable name
                    {
                        isDeclaration = true;
                    }
                    else if (potentialTypeToken.Type == TokenType.Identifier && Peek(0).Type == TokenType.DoubleColon && Peek(1).Type == TokenType.Identifier)
                    {
                        // Case for `ns::TypeName varName`
                        _position++; // Consume ::
                        _position++; // Consume TypeName
                        while (Current.Type == TokenType.Star) _position++; // Consume pointers
                        if (Current.Type == TokenType.Identifier) // Next must be variable name
                        {
                            isDeclaration = true;
                        }
                    }
                }
            }
            finally
            {
                _position = tempPos; // Always rewind position
            }
        }


        if (isDeclaration)
        {
            return ParseDeclarationStatement();
        }

        if (Current.Type == TokenType.LeftBrace) return ParseBlockStatement();

        var expression = ParseExpression();
        Eat(TokenType.Semicolon);
        return new ExpressionStatementNode(expression);
    }

    private IfStatementNode ParseIfStatement()
    {
        Eat(TokenType.Keyword);
        Eat(TokenType.LeftParen);
        var condition = ParseExpression();
        Eat(TokenType.RightParen);
        var thenBody = ParseStatement();
        StatementNode? elseBody = null;
        if (Current.Type == TokenType.Keyword && Current.Value == "else")
        {
            Eat(TokenType.Keyword);
            elseBody = ParseStatement();
        }
        return new IfStatementNode(condition, thenBody, elseBody);
    }

    private StatementNode ParseDeclarationStatement()
    {
        bool isConst = false;
        if (Current.Type == TokenType.Keyword && Current.Value == "const")
        {
            isConst = true;
            Eat(TokenType.Keyword); // Eat 'const'
        }

        var (typeToken, pointerLevel) = ParseType();
        var identifier = Eat(TokenType.Identifier);
        ExpressionNode? initializer = null;
        if (Current.Type == TokenType.Assignment)
        {
            Eat(TokenType.Assignment);
            if (Current.Type == TokenType.LeftBrace)
            {
                initializer = ParseInitializerListExpression();
            }
            else
            {
                initializer = ParseExpression();
            }
        }
        else if (isConst)
        {
            // const variables must be initialized
            throw new InvalidOperationException($"Constant variable '{identifier.Value}' must be initialized.");
        }
        Eat(TokenType.Semicolon);
        return new DeclarationStatementNode(isConst, typeToken, pointerLevel, identifier, initializer);
    }

    private ExpressionNode ParseInitializerListExpression()
    {
        Eat(TokenType.LeftBrace);
        var values = new List<ExpressionNode>();
        if (Current.Type != TokenType.RightBrace)
        {
            do
            {
                values.Add(ParseExpression());
            } while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
        }
        Eat(TokenType.RightBrace);
        return new InitializerListExpressionNode(values);
    }

    private WhileStatementNode ParseWhileStatement()
    {
        Eat(TokenType.Keyword);
        Eat(TokenType.LeftParen);
        var condition = ParseExpression();
        Eat(TokenType.RightParen);
        var body = ParseStatement();
        return new WhileStatementNode(condition, body);
    }

    private ReturnStatementNode ParseReturnStatement()
    {
        Eat(TokenType.Keyword);
        ExpressionNode? expression = null;
        if (Current.Type != TokenType.Semicolon) expression = ParseExpression();
        Eat(TokenType.Semicolon);
        return new ReturnStatementNode(expression);
    }

    private ExpressionNode ParseExpression() => ParseAssignmentExpression();

    private ExpressionNode ParseAssignmentExpression()
    {
        var left = ParseEqualityExpression();
        if (Current.Type == TokenType.Assignment)
        {
            Eat(TokenType.Assignment);
            var right = ParseAssignmentExpression();
            if (left is VariableExpressionNode or MemberAccessExpressionNode or UnaryExpressionNode) return new AssignmentExpressionNode(left, right);
            throw new InvalidOperationException($"Invalid assignment target: {left.GetType().Name}");
        }
        return left;
    }

    private ExpressionNode ParseEqualityExpression()
    {
        var left = ParseRelationalExpression();
        while (Current.Type is TokenType.DoubleEquals or TokenType.NotEquals)
        {
            var op = Current; _position++;
            var right = ParseRelationalExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseRelationalExpression()
    {
        var left = ParseAdditiveExpression();
        while (Current.Type is TokenType.LessThan or TokenType.GreaterThan)
        {
            var op = Current; _position++;
            var right = ParseAdditiveExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseAdditiveExpression()
    {
        var left = ParseMultiplicativeExpression();
        while (Current.Type is TokenType.Plus or TokenType.Minus)
        {
            var op = Current; _position++;
            var right = ParseMultiplicativeExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseMultiplicativeExpression()
    {
        var left = ParseUnaryExpression();
        while (Current.Type is TokenType.Star or TokenType.Slash)
        {
            var op = Current; _position++;
            var right = ParseUnaryExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseUnaryExpression()
    {
        if (Current.Type is TokenType.Minus or TokenType.Plus or TokenType.Star or TokenType.Ampersand)
        {
            var op = Current; _position++;
            return new UnaryExpressionNode(op, ParseUnaryExpression());
        }
        return ParsePostfixExpression();
    }

    private ExpressionNode ParsePostfixExpression()
    {
        var expr = ParsePrimaryExpression();

        while (true)
        {
            if (Current.Type == TokenType.LeftParen) // Call
            {
                Eat(TokenType.LeftParen);
                var arguments = new List<ExpressionNode>();
                if (Current.Type != TokenType.RightParen)
                {
                    do { arguments.Add(ParseExpression()); }
                    while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
                }
                Eat(TokenType.RightParen);
                expr = new CallExpressionNode(expr, arguments);
            }
            else if (Current.Type is TokenType.Dot or TokenType.Arrow) // Member access
            {
                var op = Current;
                _position++;
                var member = Eat(TokenType.Identifier);
                expr = new MemberAccessExpressionNode(expr, op, member);
            }
            else
            {
                break;
            }
        }

        return expr;
    }

    private ExpressionNode ParsePrimaryExpression()
    {
        if (Current.Type == TokenType.IntegerLiteral)
        {
            var token = Eat(TokenType.IntegerLiteral);
            if (int.TryParse(token.Value, out int v)) return new IntegerLiteralNode(v);
            throw new InvalidOperationException($"Could not parse int: {token.Value}");
        }
        if (Current.Type == TokenType.HexLiteral)
        {
            var token = Eat(TokenType.HexLiteral);
            var hex = token.Value.StartsWith("0x") ? token.Value.Substring(2) : token.Value;
            if (int.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int v)) return new IntegerLiteralNode(v);
            throw new InvalidOperationException($"Could not parse hex: {token.Value}");
        }
        if (Current.Type == TokenType.StringLiteral)
        {
            var token = Eat(TokenType.StringLiteral);
            return new StringLiteralNode(token.Value, $"str{_stringLabelCounter++}");
        }
        if (Current.Type == TokenType.Identifier && Peek(1).Type == TokenType.DoubleColon)
        {
            var ns = Eat(TokenType.Identifier);
            Eat(TokenType.DoubleColon);
            var member = Eat(TokenType.Identifier);
            return new QualifiedAccessExpressionNode(ns, member);
        }
        if (Current.Type == TokenType.Identifier) return new VariableExpressionNode(Eat(TokenType.Identifier));
        if (Current.Type == TokenType.LeftParen)
        {
            Eat(TokenType.LeftParen);
            var expr = ParseExpression();
            Eat(TokenType.RightParen);
            return expr;
        }
        throw new InvalidOperationException($"Unexpected expression token: {Current.Type}");
    }
}
</file>

<file path="Preprocessor.cs">
using System.Collections.Generic;
using System.IO;

namespace CTilde;

public class Preprocessor
{
    public List<string> DiscoverDependencies(string entryFilePath)
    {
        var allFiles = new List<string>();
        var processedFiles = new HashSet<string>();
        var filesToProcess = new Queue<string>();

        filesToProcess.Enqueue(Path.GetFullPath(entryFilePath));

        while (filesToProcess.Count > 0)
        {
            var currentFile = filesToProcess.Dequeue();
            if (!File.Exists(currentFile) || processedFiles.Contains(currentFile))
            {
                continue;
            }

            processedFiles.Add(currentFile);
            allFiles.Add(currentFile);

            string directory = Path.GetDirectoryName(currentFile) ?? "";

            foreach (var line in File.ReadLines(currentFile))
            {
                var trimmedLine = line.Trim();
                if (trimmedLine.StartsWith("#include"))
                {
                    var startIndex = trimmedLine.IndexOf('"');
                    var endIndex = trimmedLine.LastIndexOf('"');
                    if (startIndex != -1 && endIndex > startIndex)
                    {
                        var includeFileName = trimmedLine.Substring(startIndex + 1, endIndex - startIndex - 1);
                        var fullIncludePath = Path.GetFullPath(Path.Combine(directory, includeFileName));
                        filesToProcess.Enqueue(fullIncludePath);
                    }
                }
            }
        }

        // The order matters for parsing: dependencies should come first.
        // We reverse because the entry point was added first.
        allFiles.Reverse();
        return allFiles;
    }
}
</file>

<file path="Program.cs">
using System;

namespace CTilde;

public class Program
{
    public static void Main(string[] args)
    {
        var compiler = new Compiler();
        compiler.Compile("Output/main.c");
    }
}
</file>

<file path="Tokenizer.cs">
using System.Collections.Generic;
using System.Text;

namespace CTilde;

public enum TokenType
{
    Keyword,
    Identifier,
    IntegerLiteral,
    HexLiteral,
    StringLiteral,
    Semicolon,
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Comma,
    Dot,
    Hash,
    Assignment,
    Unknown,
    Plus,
    Minus,
    Star,
    Slash,
    DoubleEquals,
    NotEquals,
    LessThan,
    GreaterThan,
    Ampersand,
    Arrow,
    Colon,
    DoubleColon,
    Enum // NEW
}

public record Token(TokenType Type, string Value);

public class Tokenizer
{
    private static readonly HashSet<string> Keywords =
    [
        "int",
        "void",
        "return",
        "while",
        "if",
        "else",
        "struct",
        "char",
        "public",
        "private",
        "namespace",
        "using",
        "const",
        "enum" // MODIFIED
    ];

    public static List<Token> Tokenize(string input)
    {
        List<Token> tokens = [];
        int i = 0;

        while (i < input.Length)
        {
            char c = input[i];

            if (char.IsWhiteSpace(c)) { i++; continue; }
            if (c == '/' && i + 1 < input.Length && input[i + 1] == '/') { while (i < input.Length && input[i] != '\n') i++; continue; }
            if (c == '"')
            {
                i++;
                var sb = new StringBuilder();
                while (i < input.Length && input[i] != '"')
                {
                    char current = input[i];
                    if (current == '\\' && i + 1 < input.Length)
                    {
                        i++;
                        switch (input[i])
                        {
                            case 'n': sb.Append('\n'); break;
                            case 't': sb.Append('\t'); break;
                            case '\\': sb.Append('\\'); break;
                            case '"': sb.Append('"'); break;
                            default: sb.Append('\\'); sb.Append(input[i]); break;
                        }
                    }
                    else sb.Append(current);
                    i++;
                }
                if (i < input.Length) i++;
                tokens.Add(new Token(TokenType.StringLiteral, sb.ToString()));
                continue;
            }

            switch (c)
            {
                case '#': tokens.Add(new(TokenType.Hash, "#")); i++; continue;
                case '.': tokens.Add(new(TokenType.Dot, ".")); i++; continue;
                case ':':
                    if (i + 1 < input.Length && input[i + 1] == ':') { tokens.Add(new(TokenType.DoubleColon, "::")); i += 2; }
                    else { tokens.Add(new(TokenType.Colon, ":")); i++; }
                    continue;
                case '(': tokens.Add(new(TokenType.LeftParen, "(")); i++; continue;
                case ')': tokens.Add(new(TokenType.RightParen, ")")); i++; continue;
                case '{': tokens.Add(new(TokenType.LeftBrace, "{")); i++; continue;
                case '}': tokens.Add(new(TokenType.RightBrace, "}")); i++; continue;
                case ';': tokens.Add(new(TokenType.Semicolon, ";")); i++; continue;
                case ',': tokens.Add(new(TokenType.Comma, ",")); i++; continue;
                case '+': tokens.Add(new(TokenType.Plus, "+")); i++; continue;
                case '-':
                    if (i + 1 < input.Length && input[i + 1] == '>') { tokens.Add(new(TokenType.Arrow, "->")); i += 2; }
                    else { tokens.Add(new(TokenType.Minus, "-")); i++; }
                    continue;
                case '*': tokens.Add(new(TokenType.Star, "*")); i++; continue;
                case '/': tokens.Add(new(TokenType.Slash, "/")); i++; continue;
                case '&': tokens.Add(new(TokenType.Ampersand, "&")); i++; continue;
                case '<': tokens.Add(new(TokenType.LessThan, "<")); i++; continue;
                case '>': tokens.Add(new(TokenType.GreaterThan, ">")); i++; continue;
                case '=':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.DoubleEquals, "==")); i += 2; }
                    else { tokens.Add(new(TokenType.Assignment, "=")); i++; }
                    continue;
                case '!':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.NotEquals, "!=")); i += 2; }
                    else { tokens.Add(new(TokenType.Unknown, c.ToString())); i++; }
                    continue;
            }

            if (c == '0' && i + 1 < input.Length && (input[i + 1] == 'x' || input[i + 1] == 'X'))
            {
                int start = i;
                i += 2;
                while (i < input.Length && "0123456789abcdefABCDEF".Contains(input[i])) i++;
                tokens.Add(new Token(TokenType.HexLiteral, input.Substring(start, i - start)));
                continue;
            }
            if (char.IsDigit(c))
            {
                int start = i;
                while (i < input.Length && char.IsDigit(input[i])) i++;
                tokens.Add(new(TokenType.IntegerLiteral, input.Substring(start, i - start)));
                continue;
            }
            if (char.IsLetter(c) || c == '_')
            {
                int start = i;
                while (i < input.Length && (char.IsLetterOrDigit(input[i]) || input[i] == '_')) i++;
                string value = input.Substring(start, i - start);
                tokens.Add(new(Keywords.Contains(value) ? TokenType.Keyword : TokenType.Identifier, value));
                continue;
            }
            tokens.Add(new(TokenType.Unknown, c.ToString()));
            i++;
        }
        tokens.Add(new(TokenType.Unknown, string.Empty));
        return tokens;
    }
}
</file>

<file path="Analysis\AnalysisContext.cs">
namespace CTilde;

public record AnalysisContext(
    SymbolTable Symbols,
    CompilationUnitNode CompilationUnit,
    FunctionDeclarationNode CurrentFunction
);
</file>

<file path="Analysis\SemanticAnalyzer.cs">
using System;
using System.Linq;

namespace CTilde;

public class SemanticAnalyzer
{
    private readonly TypeManager _typeManager;

    public SemanticAnalyzer(TypeManager typeManager)
    {
        _typeManager = typeManager;
    }

    public string AnalyzeExpressionType(ExpressionNode expr, AnalysisContext context)
    {
        return expr switch
        {
            IntegerLiteralNode => "int",
            StringLiteralNode => "char*",
            VariableExpressionNode v => AnalyzeVariableExpression(v, context),
            AssignmentExpressionNode a => AnalyzeExpressionType(a.Left, context), // Type of assignment is type of l-value
            MemberAccessExpressionNode ma => AnalyzeMemberAccessExpression(ma, context),
            UnaryExpressionNode u => AnalyzeUnaryExpression(u, context),
            CallExpressionNode c => AnalyzeCallExpression(c, context),
            QualifiedAccessExpressionNode q => AnalyzeQualifiedAccessExpression(q, context),
            BinaryExpressionNode => "int", // All binary operations currently result in an integer
            _ => throw new NotImplementedException($"AnalyzeExpressionType not implemented for {expr.GetType().Name}")
        };
    }

    private string AnalyzeVariableExpression(VariableExpressionNode v, AnalysisContext context)
    {
        // 1. Check local variables and parameters in the symbol table.
        if (context.Symbols.TryGetSymbol(v.Identifier.Value, out _, out var type, out _))
        {
            return type;
        }

        // 2. Try resolving as an unqualified enum member (e.g., `KEY_D`).
        var unqualifiedEnumValue = _typeManager.ResolveUnqualifiedEnumMember(v.Identifier.Value, context.CompilationUnit, context.CurrentFunction.Namespace);
        if (unqualifiedEnumValue.HasValue)
        {
            return "int";
        }

        // 3. If in a method, try resolving as an implicit `this->member`.
        if (context.CurrentFunction.OwnerStructName != null)
        {
            try
            {
                (StructDefinitionNode _, string fullName) = _typeManager.GetStructTypeFromUnqualifiedName(context.CurrentFunction.OwnerStructName, context.CurrentFunction.Namespace);
                (int _, string memberTypeResolved) = _typeManager.GetMemberInfo(fullName, v.Identifier.Value, context.CompilationUnit);
                return memberTypeResolved;
            }
            catch (InvalidOperationException) { /* Fall through to the final error */ }
        }

        throw new InvalidOperationException($"Cannot determine type for undefined variable '{v.Identifier.Value}'.");
    }

    private string AnalyzeMemberAccessExpression(MemberAccessExpressionNode ma, AnalysisContext context)
    {
        var leftType = AnalyzeExpressionType(ma.Left, context);
        string baseStructType = leftType.TrimEnd('*');
        var (_, resolvedMemberType) = _typeManager.GetMemberInfo(baseStructType, ma.Member.Value, context.CompilationUnit);
        return resolvedMemberType;
    }

    private string AnalyzeUnaryExpression(UnaryExpressionNode u, AnalysisContext context)
    {
        if (u.Operator.Type == TokenType.Ampersand) // Address-of operator
        {
            return AnalyzeExpressionType(u.Right, context) + "*";
        }

        if (u.Operator.Type == TokenType.Star) // Dereference operator
        {
            var operandType = AnalyzeExpressionType(u.Right, context);
            if (!operandType.EndsWith("*"))
            {
                throw new InvalidOperationException($"Cannot dereference non-pointer type '{operandType}'.");
            }
            return operandType[..^1]; // Remove one level of indirection
        }

        // For other unary operators like negation ('-'), the type does not change.
        return AnalyzeExpressionType(u.Right, context);
    }

    private string AnalyzeCallExpression(CallExpressionNode call, AnalysisContext context)
    {
        FunctionDeclarationNode func;
        if (call.Callee is MemberAccessExpressionNode callMemberAccess) // Method call: myText.draw()
        {
            var ownerTypeName = AnalyzeExpressionType(callMemberAccess.Left, context).TrimEnd('*');
            var (ownerStruct, _) = _typeManager.GetStructTypeFromFullName(ownerTypeName);
            func = _typeManager.ResolveMethod(ownerStruct, callMemberAccess.Member.Value);
        }
        else // Global or namespaced function call: DrawText(), rl::DrawText()
        {
            func = _typeManager.ResolveFunctionCall(call.Callee, context.CompilationUnit, context.CurrentFunction);
        }

        string returnTypeNameRaw = _typeManager.GetTypeName(func.ReturnType, func.ReturnPointerLevel);

        // If the return type is not a primitive keyword (and not void), it's a UDT that needs full resolution.
        if (func.ReturnType.Type != TokenType.Keyword && !returnTypeNameRaw.StartsWith("void"))
        {
            string baseReturnName = returnTypeNameRaw.TrimEnd('*');
            string returnPointerSuffix = new('*', returnTypeNameRaw.Length - baseReturnName.Length);
            return _typeManager.ResolveTypeName(baseReturnName, func.Namespace, context.CompilationUnit) + returnPointerSuffix;
        }

        return returnTypeNameRaw;
    }

    private string AnalyzeQualifiedAccessExpression(QualifiedAccessExpressionNode q, AnalysisContext context)
    {
        // A qualified access can be an enum member (e.g., `rl::KEY_D`) which has a value.
        string? enumTypeFQN = _typeManager.ResolveEnumTypeName(q.Namespace.Value, context.CurrentFunction.Namespace, context.CompilationUnit);
        if (enumTypeFQN != null)
        {
            if (_typeManager.GetEnumValue(enumTypeFQN, q.Member.Value).HasValue)
            {
                return "int"; // Enum members are integers.
            }
            throw new InvalidOperationException($"Enum '{q.Namespace.Value}' (resolved to '{enumTypeFQN}') does not contain member '{q.Member.Value}'.");
        }

        // If not an enum, it's a qualified name like `rl::DrawText`. This is not a value on its own.
        // It's only valid as the `Callee` of a `CallExpression`, which is handled by `AnalyzeCallExpression`.
        throw new InvalidOperationException($"Qualified access '{q.Namespace.Value}::{q.Member.Value}' cannot be evaluated as a value directly. Only enum members or function calls are supported.");
    }
}
</file>

<file path="Generator\AssemblyBuilder.cs">
using System.Text;

namespace CTilde;

public class AssemblyBuilder
{
    private readonly StringBuilder _sb = new();

    public void AppendDirective(string directive)
    {
        _sb.AppendLine(directive);
    }

    public void AppendLabel(string label)
    {
        _sb.AppendLine($"{label}:");
    }

    public void AppendInstruction(string? instruction, string? comment = null)
    {
        string line = instruction is null 
            ? "" 
            : $"    {instruction}";

        _sb.AppendLine(line.PadRight(35) + (comment is null ? "" : $"; {comment}"));
    }

    public void AppendData(string label, string value)
    {
        _sb.AppendLine($"    {label} db {value}");
    }

    public void AppendBlankLine()
    {
        _sb.AppendLine();
    }

    public override string ToString()
    {
        return _sb.ToString();
    }
}
</file>

<file path="Generator\CodeGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class CodeGenerator
{
    internal ProgramNode Program { get; }
    internal TypeManager TypeManager { get; }
    internal SemanticAnalyzer SemanticAnalyzer { get; }
    internal AssemblyBuilder Builder { get; } = new();

    private int _labelIdCounter;
    private readonly Dictionary<string, string> _stringLiterals = new();
    internal HashSet<string> ExternalFunctions { get; } = new();

    private readonly StatementGenerator _statementGenerator;
    internal ExpressionGenerator ExpressionGenerator { get; }

    public CodeGenerator(ProgramNode program)
    {
        Program = program;
        TypeManager = new TypeManager(program);
        SemanticAnalyzer = new SemanticAnalyzer(TypeManager);

        ExpressionGenerator = new ExpressionGenerator(this);
        _statementGenerator = new StatementGenerator(this);
    }

    public string Generate()
    {
        FindAllStringLiterals(Program);

        foreach (var unit in Program.CompilationUnits)
            foreach (var f in unit.Functions.Where(f => f.Body == null))
            {
                ExternalFunctions.Add(f.Name);
            }

        var fasmWriter = new FasmWriter();
        fasmWriter.WritePreamble(Builder);
        fasmWriter.WriteDataSection(Builder, _stringLiterals);
        fasmWriter.WriteTextSectionHeader(Builder);
        fasmWriter.WriteEntryPoint(Builder);

        foreach (var unit in Program.CompilationUnits)
        {
            foreach (var function in unit.Functions.Where(f => f.Body != null))
            {
                GenerateFunction(function, unit);
                Builder.AppendBlankLine();
            }
        }

        fasmWriter.WriteImportDataSection(Builder, Program, ExternalFunctions);

        return Builder.ToString();
    }

    internal int GetNextLabelId() => _labelIdCounter++;

    private void FindAllStringLiterals(AstNode node)
    {
        if (node is StringLiteralNode str && !_stringLiterals.ContainsValue(str.Value))
        {
            _stringLiterals.Add(str.Label, str.Value);
        }

        foreach (var property in node.GetType().GetProperties())
        {
            if (property.Name == "Parent") continue;

            if (property.GetValue(node) is AstNode child)
            {
                FindAllStringLiterals(child);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children)
                {
                    FindAllStringLiterals(c);
                }
            }
        }
    }

    private void GenerateFunction(FunctionDeclarationNode function, CompilationUnitNode unit)
    {
        var symbols = new SymbolTable(function, TypeManager, unit);
        var context = new AnalysisContext(symbols, unit, function);

        string mangledName;
        if (function.Name == "main")
        {
            mangledName = "_main";
        }
        else
        {
            var nameParts = new List<string>();
            if (function.Namespace != null) nameParts.Add(function.Namespace);
            if (function.OwnerStructName != null) nameParts.Add(function.OwnerStructName);
            nameParts.Add(function.Name);
            mangledName = "_" + string.Join("_", nameParts);
        }

        Builder.AppendLabel(mangledName);
        Builder.AppendInstruction("push ebp");
        Builder.AppendInstruction("mov ebp, esp");
        Builder.AppendInstruction("push ebx", "Preserve non-volatile registers");
        Builder.AppendInstruction("push esi");
        Builder.AppendInstruction("push edi");
        Builder.AppendBlankLine();

        int totalLocalSize = symbols.TotalLocalSize;
        if (totalLocalSize > 0)
        {
            Builder.AppendInstruction($"sub esp, {totalLocalSize}", "Allocate space for all local variables");
        }

        if (function.Body != null)
        {
            _statementGenerator.GenerateStatement(function.Body, context);
        }

        Builder.AppendBlankLine();
        Builder.AppendInstruction(null, "Implicit return cleanup");
        GenerateFunctionEpilogue();
    }

    internal void GenerateFunctionEpilogue()
    {
        Builder.AppendInstruction("pop edi");
        Builder.AppendInstruction("pop esi");
        Builder.AppendInstruction("pop ebx");
        Builder.AppendInstruction("mov esp, ebp");
        Builder.AppendInstruction("pop ebp");
        Builder.AppendInstruction("ret");
    }
}
</file>

<file path="Generator\ExpressionGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class ExpressionGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeManager TypeManager => _context.TypeManager;
    private SemanticAnalyzer SemanticAnalyzer => _context.SemanticAnalyzer;
    private HashSet<string> ExternalFunctions => _context.ExternalFunctions;

    public ExpressionGenerator(CodeGenerator context)
    {
        _context = context;
    }

    // L-Value Generation (Address-Of)
    public void GenerateLValueAddress(ExpressionNode expression, AnalysisContext context)
    {
        switch (expression)
        {
            case VariableExpressionNode varExpr:
                GenerateLValueForVariable(varExpr, context);
                break;
            case MemberAccessExpressionNode memberAccess:
                GenerateLValueForMemberAccess(memberAccess, context);
                break;
            case UnaryExpressionNode u when u.Operator.Type == TokenType.Star:
                // The address of a dereference is the value of the pointer expression itself.
                GenerateExpression(u.Right, context);
                break;
            default:
                throw new InvalidOperationException($"Expression '{expression.GetType().Name}' is not a valid L-value.");
        }
    }

    private void GenerateLValueForVariable(VariableExpressionNode varExpr, AnalysisContext context)
    {
        // Case 1: Local variable or parameter
        if (context.Symbols.TryGetSymbol(varExpr.Identifier.Value, out var offset, out _, out _))
        {
            string sign = offset > 0 ? "+" : ""; // Params are positive, locals are negative
            Builder.AppendInstruction($"lea eax, [ebp {sign} {offset}]", $"Get address of var/param {varExpr.Identifier.Value}");
            return;
        }

        // Case 2: Implicit 'this->member' inside a method
        if (context.CurrentFunction.OwnerStructName != null)
        {
            try
            {
                var (Def, FullName) = TypeManager.GetStructTypeFromUnqualifiedName(context.CurrentFunction.OwnerStructName, context.CurrentFunction.Namespace);
                var (memberOffset, _) = TypeManager.GetMemberInfo(FullName, varExpr.Identifier.Value, context.CompilationUnit);
                context.Symbols.TryGetSymbol("this", out var thisOffset, out _, out _);

                Builder.AppendInstruction($"mov eax, [ebp + {thisOffset}]", "Get `this` pointer value");
                if (memberOffset > 0)
                {
                    Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for implicit this->{varExpr.Identifier.Value}");
                }
                return;
            }
            catch (InvalidOperationException) { /* Fall through to error */ }
        }

        throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'");
    }

    private void GenerateLValueForMemberAccess(MemberAccessExpressionNode memberAccess, AnalysisContext context)
    {
        var leftType = SemanticAnalyzer.AnalyzeExpressionType(memberAccess.Left, context);
        string baseStructType = leftType.TrimEnd('*');

        var (memberOffset, _) = TypeManager.GetMemberInfo(baseStructType, memberAccess.Member.Value, context.CompilationUnit);

        // For `obj.member`, get the address of `obj` first.
        if (memberAccess.Operator.Type == TokenType.Dot)
        {
            GenerateLValueAddress(memberAccess.Left, context);
        }
        // For `ptr->member`, get the value of `ptr` first.
        else
        {
            GenerateExpression(memberAccess.Left, context);
        }

        if (memberOffset > 0)
        {
            Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for member {memberAccess.Operator.Value}{memberAccess.Member.Value}");
        }
    }

    // R-Value Generation (Value-Of)
    public void GenerateExpression(ExpressionNode expression, AnalysisContext context)
    {
        switch (expression)
        {
            case IntegerLiteralNode literal:
                GenerateIntegerLiteral(literal);
                break;
            case StringLiteralNode str:
                GenerateStringLiteral(str);
                break;
            case VariableExpressionNode varExpr:
                GenerateVariableExpression(varExpr, context);
                break;
            case UnaryExpressionNode u:
                GenerateUnaryExpression(u, context);
                break;
            case MemberAccessExpressionNode m:
                GenerateMemberAccessExpression(m, context);
                break;
            case AssignmentExpressionNode assign:
                GenerateAssignmentExpression(assign, context);
                break;
            case BinaryExpressionNode binExpr:
                GenerateBinaryExpression(binExpr, context);
                break;
            case CallExpressionNode callExpr:
                GenerateCallExpression(callExpr, context);
                break;
            case QualifiedAccessExpressionNode qNode:
                GenerateQualifiedAccessExpression(qNode, context);
                break;
            default:
                throw new NotImplementedException($"Expr: {expression.GetType().Name}");
        }
    }

    private void GenerateIntegerLiteral(IntegerLiteralNode literal)
    {
        Builder.AppendInstruction($"mov eax, {literal.Value}");
    }

    private void GenerateStringLiteral(StringLiteralNode str)
    {
        Builder.AppendInstruction($"mov eax, {str.Label}");
    }

    private void GenerateVariableExpression(VariableExpressionNode varExpr, AnalysisContext context)
    {
        // Case 1: Local variable or parameter
        if (context.Symbols.TryGetSymbol(varExpr.Identifier.Value, out int offset, out string symbolResolvedType, out _))
        {
            // If the variable is a struct value type (not a pointer), its "value" is its address.
            if (!symbolResolvedType.EndsWith("*") && TypeManager.IsStruct(symbolResolvedType))
            {
                GenerateLValueAddress(varExpr, context);
            }
            else
            {
                // For primitives and pointers, load the value from its memory location.
                string sign = offset > 0 ? "+" : "";
                if (TypeManager.GetSizeOfType(symbolResolvedType, context.CompilationUnit) == 1)
                    Builder.AppendInstruction($"movzx eax, byte [ebp {sign} {offset}]", $"Load value of {varExpr.Identifier.Value}");
                else
                    Builder.AppendInstruction($"mov eax, [ebp {sign} {offset}]", $"Load value of {varExpr.Identifier.Value}");
            }
            return;
        }

        // Case 2: Unqualified enum member (e.g., `KEY_D`)
        var enumValue = TypeManager.ResolveUnqualifiedEnumMember(varExpr.Identifier.Value, context.CompilationUnit, context.CurrentFunction.Namespace);
        if (enumValue.HasValue)
        {
            Builder.AppendInstruction($"mov eax, {enumValue.Value}", $"Enum member {varExpr.Identifier.Value}");
            return;
        }

        // Case 3: Implicit 'this->member'
        if (context.CurrentFunction.OwnerStructName != null)
        {
            var thisMemberAccess = new MemberAccessExpressionNode(new VariableExpressionNode(new Token(TokenType.Identifier, "this")), new Token(TokenType.Arrow, "->"), varExpr.Identifier)
            {
                Parent = varExpr.Parent
            };
            GenerateMemberAccessExpression(thisMemberAccess, context);
            return;
        }

        throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'.");
    }

    private void GenerateUnaryExpression(UnaryExpressionNode u, AnalysisContext context)
    {
        // Address-of operator
        if (u.Operator.Type == TokenType.Ampersand)
        {
            GenerateLValueAddress(u.Right, context);
            return;
        }

        // Regular value expression for the operand
        GenerateExpression(u.Right, context);

        switch (u.Operator.Type)
        {
            case TokenType.Minus:
                Builder.AppendInstruction("neg eax");
                break;
            case TokenType.Star: // Dereference
                var type = SemanticAnalyzer.AnalyzeExpressionType(u, context);
                if (TypeManager.GetSizeOfType(type, context.CompilationUnit) == 1)
                    Builder.AppendInstruction("movzx eax, byte [eax]");
                else
                    Builder.AppendInstruction("mov eax, [eax]");
                break;
        }
    }

    private void GenerateMemberAccessExpression(MemberAccessExpressionNode m, AnalysisContext context)
    {
        GenerateLValueAddress(m, context); // Get address of member
        var memberType = SemanticAnalyzer.AnalyzeExpressionType(m, context);

        // Load value from the address in EAX
        if (TypeManager.IsStruct(memberType))
        {
            // For struct members, the "value" is its address, which is already in EAX. Do nothing.
        }
        else if (TypeManager.GetSizeOfType(memberType, context.CompilationUnit) == 1)
        {
            Builder.AppendInstruction("movzx eax, byte [eax]");
        }
        else
        {
            Builder.AppendInstruction("mov eax, [eax]");
        }
    }

    private void GenerateAssignmentExpression(AssignmentExpressionNode assign, AnalysisContext context)
    {
        string lValueType = SemanticAnalyzer.AnalyzeExpressionType(assign.Left, context);
        bool isStructAssign = TypeManager.IsStruct(lValueType);

        if (isStructAssign)
        {
            // Right-hand side (source address)
            GenerateExpression(assign.Right, context);
            Builder.AppendInstruction("push eax", "Push source address");

            // Left-hand side (destination address)
            GenerateLValueAddress(assign.Left, context);
            Builder.AppendInstruction("mov edi, eax", "Pop destination into EDI"); // Dest
            Builder.AppendInstruction("pop esi", "Pop source into ESI"); // Source

            int size = TypeManager.GetSizeOfType(lValueType, context.CompilationUnit);
            Builder.AppendInstruction($"mov ecx, {size / 4}");
            Builder.AppendInstruction("rep movsd");
            if (size % 4 > 0)
            {
                Builder.AppendInstruction($"mov ecx, {size % 4}");
                Builder.AppendInstruction("rep movsb");
            }
        }
        else
        {
            // Right-hand side (value)
            GenerateExpression(assign.Right, context);
            Builder.AppendInstruction("push eax", "Push value");

            // Left-hand side (address)
            GenerateLValueAddress(assign.Left, context);
            Builder.AppendInstruction("pop ecx", "Pop value into ECX");

            if (TypeManager.GetSizeOfType(lValueType, context.CompilationUnit) == 1)
                Builder.AppendInstruction("mov [eax], cl", "Assign byte");
            else
                Builder.AppendInstruction("mov [eax], ecx", "Assign dword");
        }
        // An assignment expression's value is the value that was assigned.
        // For primitives, it's already in ECX. Move to EAX. For structs, it's an address.
        if (!isStructAssign)
        {
            Builder.AppendInstruction("mov eax, ecx");
        }
    }

    private void GenerateCallExpression(CallExpressionNode callExpr, AnalysisContext context)
    {
        int totalArgSize = 0;

        // Push arguments onto the stack in reverse order
        foreach (var arg in callExpr.Arguments.AsEnumerable().Reverse())
        {
            var argType = SemanticAnalyzer.AnalyzeExpressionType(arg, context);
            var isStruct = TypeManager.IsStruct(argType);

            GenerateExpression(arg, context); // Result is address (for struct) or value (for primitive) in EAX

            if (isStruct)
            {
                int argSize = TypeManager.GetSizeOfType(argType, context.CompilationUnit);
                for (int offset = argSize - 4; offset >= 0; offset -= 4)
                {
                    Builder.AppendInstruction($"push dword [eax + {offset}]");
                }
                totalArgSize += argSize;
            }
            else
            {
                Builder.AppendInstruction("push eax");
                totalArgSize += 4;
            }
        }

        string calleeTarget;
        if (callExpr.Callee is MemberAccessExpressionNode memberAccess) // Method call
        {
            var leftType = SemanticAnalyzer.AnalyzeExpressionType(memberAccess.Left, context);
            var (structDef, _) = TypeManager.GetStructTypeFromFullName(leftType.TrimEnd('*'));
            var method = TypeManager.ResolveMethod(structDef, memberAccess.Member.Value);

            // Push `this` pointer
            GenerateLValueAddress(memberAccess.Left, context);
            Builder.AppendInstruction("push eax", "Push 'this' pointer");
            totalArgSize += 4;

            var nameParts = new List<string?> { method.Namespace, method.OwnerStructName, method.Name }.Where(n => n != null);
            calleeTarget = "_" + string.Join("_", nameParts);
        }
        else // Global/namespaced function call
        {
            var func = TypeManager.ResolveFunctionCall(callExpr.Callee, context.CompilationUnit, context.CurrentFunction);
            if (func.Body == null)
            {
                ExternalFunctions.Add(func.Name);
                calleeTarget = $"[{func.Name}]";
            }
            else
            {
                var nameParts = new List<string?> { func.Namespace, func.OwnerStructName, func.Name }.Where(n => n != null);
                calleeTarget = "_" + string.Join("_", nameParts);
            }
        }

        Builder.AppendInstruction($"call {calleeTarget}");

        if (totalArgSize > 0)
        {
            Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up args");
        }
    }

    private void GenerateBinaryExpression(BinaryExpressionNode binExpr, AnalysisContext context)
    {
        GenerateExpression(binExpr.Right, context);
        Builder.AppendInstruction("push eax");
        GenerateExpression(binExpr.Left, context);
        Builder.AppendInstruction("pop ecx");

        switch (binExpr.Operator.Type)
        {
            case TokenType.Plus: Builder.AppendInstruction("add eax, ecx"); break;
            case TokenType.Minus: Builder.AppendInstruction("sub eax, ecx"); break;
            case TokenType.Star: Builder.AppendInstruction("imul eax, ecx"); break;
            case TokenType.Slash: Builder.AppendInstruction("cdq"); Builder.AppendInstruction("idiv ecx"); break;
            case TokenType.DoubleEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("sete al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.NotEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setne al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.LessThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setl al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.GreaterThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setg al"); Builder.AppendInstruction("movzx eax, al"); break;
            default: throw new NotImplementedException($"Op: {binExpr.Operator.Type}");
        }
    }

    private void GenerateQualifiedAccessExpression(QualifiedAccessExpressionNode qNode, AnalysisContext context)
    {
        // Case 1: Enum member access (e.g. `rl::KEY_D`)
        string? enumTypeFQN = TypeManager.ResolveEnumTypeName(qNode.Namespace.Value, context.CurrentFunction.Namespace, context.CompilationUnit);
        if (enumTypeFQN != null)
        {
            var enumValue = TypeManager.GetEnumValue(enumTypeFQN, qNode.Member.Value);
            if (enumValue.HasValue)
            {
                Builder.AppendInstruction($"mov eax, {enumValue.Value}", $"Enum member {qNode.Namespace.Value}::{qNode.Member.Value}");
                return;
            }
        }

        // Case 2: Qualified function name (e.g. `rl::DrawText`)
        var func = TypeManager.ResolveFunctionCall(qNode, context.CompilationUnit, context.CurrentFunction);
        if (func.Body == null)
        {
            ExternalFunctions.Add(func.Name);
            Builder.AppendInstruction($"mov eax, [{func.Name}]");
        }
        else
        {
            var nameParts = new List<string?> { func.Namespace, func.OwnerStructName, func.Name }.Where(n => n != null);
            Builder.AppendInstruction($"mov eax, _{string.Join("_", nameParts)}");
        }
    }
}
</file>

<file path="Generator\FasmWriter.cs">
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CTilde;

public class FasmWriter
{
    public void WritePreamble(AssemblyBuilder builder)
    {
        builder.AppendDirective("format PE GUI 4.0");
        builder.AppendDirective("entry start");
        builder.AppendBlankLine();
        builder.AppendDirective("include 'win32a.inc'");
        builder.AppendBlankLine();
    }

    public void WriteDataSection(AssemblyBuilder builder, Dictionary<string, string> stringLiterals)
    {
        builder.AppendDirective("section '.data' data readable writeable");
        foreach (var (label, value) in stringLiterals)
        {
            builder.AppendData(label, FormatStringForFasm(value));
        }
        builder.AppendBlankLine();
    }

    public void WriteTextSectionHeader(AssemblyBuilder builder)
    {
        builder.AppendDirective("section '.text' code readable executable");
        builder.AppendBlankLine();
    }

    public void WriteEntryPoint(AssemblyBuilder builder)
    {
        builder.AppendLabel("start");
        builder.AppendInstruction("call _main");
        builder.AppendInstruction("mov ebx, eax");
        builder.AppendInstruction("push ebx");
        builder.AppendInstruction("call [ExitProcess]");
        builder.AppendBlankLine();
    }

    public void WriteImportDataSection(AssemblyBuilder builder, ProgramNode program, IEnumerable<string> externalFunctions)
    {
        builder.AppendDirective("section '.idata' import data readable");
        builder.AppendBlankLine();

        var libraries = new Dictionary<string, List<string>>
        {
            { "kernel32.dll", new List<string> { "ExitProcess" } },
            { "msvcrt.dll", new List<string> { "printf" } }
        };

        foreach (var import in program.Imports)
        {
            if (!libraries.ContainsKey(import.LibraryName)) libraries[import.LibraryName] = new List<string>();
        }

        foreach (var funcName in externalFunctions)
        {
            bool found = false;
            foreach (var import in program.Imports)
            {
                if (import.LibraryName != "kernel32.dll" && import.LibraryName != "msvcrt.dll")
                {
                    libraries[import.LibraryName].Add(funcName);
                    found = true;
                    break;
                }
            }
            if (!found && funcName != "printf")
            {
                if (!libraries.ContainsKey("user32.dll")) libraries["user32.dll"] = new List<string>();
                if (!libraries["user32.dll"].Contains(funcName)) libraries["user32.dll"].Add(funcName);
            }
        }

        var libDefs = libraries.Keys.Select(lib => $"{lib.Split('.')[0]},'{lib}'");
        builder.AppendDirective($"    library {string.Join(", ", libDefs)}");
        builder.AppendBlankLine();

        foreach (var (libName, functions) in libraries)
        {
            if (functions.Count > 0)
            {
                var libAlias = libName.Split('.')[0];
                var importDefs = functions.Distinct().Select(f => $"{f},'{f}'");
                builder.AppendDirective($"    import {libAlias}, {string.Join(", ", importDefs)}");
            }
        }
    }

    private string FormatStringForFasm(string value)
    {
        var parts = new List<string>();
        var currentString = new StringBuilder();

        foreach (char c in value)
        {
            if (c is '\n' or '\t' or '\r' or '\'' or '"')
            {
                if (currentString.Length > 0)
                {
                    parts.Add($"'{currentString}'");
                    currentString.Clear();
                }
                parts.Add(((byte)c).ToString());
            }
            else currentString.Append(c);
        }

        if (currentString.Length > 0) parts.Add($"'{currentString}'");
        parts.Add("0");
        return string.Join(", ", parts);
    }
}
</file>

<file path="Generator\StatementGenerator.cs">
using System;
using System.Linq;

namespace CTilde;

public class StatementGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeManager TypeManager => _context.TypeManager;
    private ExpressionGenerator ExpressionGenerator => _context.ExpressionGenerator;

    public StatementGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public void GenerateStatement(StatementNode statement, AnalysisContext context)
    {
        switch (statement)
        {
            case ReturnStatementNode ret: GenerateReturn(ret, context); break;
            case BlockStatementNode block: foreach (var s in block.Statements) GenerateStatement(s, context); break;
            case WhileStatementNode w: GenerateWhile(w, context); break;
            case IfStatementNode i: GenerateIf(i, context); break;
            case DeclarationStatementNode decl:
                if (decl.Initializer != null)
                {
                    if (decl.Initializer is InitializerListExpressionNode initList)
                    {
                        string rawTypeName = TypeManager.GetTypeName(decl.Type, decl.PointerLevel);

                        // Resolve the base type name, then append the pointer suffix back if any
                        string baseTypeName = rawTypeName.TrimEnd('*');
                        string pointerSuffix = new string('*', rawTypeName.Length - baseTypeName.Length);
                        string resolvedTypeName = TypeManager.ResolveTypeName(baseTypeName, context.CurrentFunction.Namespace, context.CompilationUnit) + pointerSuffix;

                        if (!TypeManager.IsStruct(resolvedTypeName))
                            throw new InvalidOperationException($"Initializer list can only be used for struct types, not '{rawTypeName}'.");

                        var structDef = TypeManager.FindStruct(resolvedTypeName)
                            ?? throw new InvalidOperationException($"Could not find struct definition for initializer list type '{resolvedTypeName}'.");

                        if (initList.Values.Count > structDef.Members.Count)
                            throw new InvalidOperationException($"Too many values in initializer list for struct '{structDef.Name}'.");

                        context.Symbols.TryGetSymbol(decl.Identifier.Value, out var structBaseOffset, out _, out _); // Added out _
                        int currentMemberOffset = 0;

                        for (int j = 0; j < initList.Values.Count; j++)
                        {
                            var member = structDef.Members[j];
                            var valueExpr = initList.Values[j];

                            // Resolve the member type name before getting its size
                            var rawMemberTypeName = TypeManager.GetTypeName(member.Type, member.PointerLevel);
                            var baseMemberName = rawMemberTypeName.TrimEnd('*');
                            var memberPointerSuffix = new string('*', rawMemberTypeName.Length - baseMemberName.Length);

                            string resolvedMemberTypeName;
                            if (member.Type.Type == TokenType.Keyword || baseMemberName.Equals("void", StringComparison.OrdinalIgnoreCase))
                            {
                                resolvedMemberTypeName = rawMemberTypeName; // Primitive types, void don't need resolution
                            }
                            else
                            {
                                // Resolve member type using the namespace of the *struct definition*, not the current function's context
                                resolvedMemberTypeName = TypeManager.ResolveTypeName(baseMemberName, structDef.Namespace, context.CompilationUnit) + memberPointerSuffix;
                            }

                            var memberSize = TypeManager.GetSizeOfType(resolvedMemberTypeName, context.CompilationUnit);
                            var totalOffset = structBaseOffset + currentMemberOffset;

                            ExpressionGenerator.GenerateExpression(valueExpr, context);
                            if (memberSize == 1) Builder.AppendInstruction($"mov byte [ebp + {totalOffset}], al", $"Init member {member.Name.Value}");
                            else Builder.AppendInstruction($"mov dword [ebp + {totalOffset}], eax", $"Init member {member.Name.Value}");

                            currentMemberOffset += memberSize;
                        }
                    }
                    else // Simple variable initialization (e.g., int x = 5; or const int x = 5;)
                    {
                        var variableName = decl.Identifier.Value;
                        var varType = context.Symbols.GetSymbolType(variableName); // Get FQN type from symbol table

                        ExpressionGenerator.GenerateExpression(decl.Initializer, context); // Value to assign is in EAX
                        context.Symbols.TryGetSymbol(variableName, out var offset, out _, out _); // Added out _

                        if (TypeManager.GetSizeOfType(varType, context.CompilationUnit) == 1)
                        {
                            Builder.AppendInstruction($"mov byte [ebp + {offset}], al", $"Initialize {variableName}");
                        }
                        else
                        {
                            Builder.AppendInstruction($"mov dword [ebp + {offset}], eax", $"Initialize {variableName}");
                        }
                    }
                }
                break;
            case ExpressionStatementNode exprStmt: ExpressionGenerator.GenerateExpression(exprStmt.Expression, context); break;
            default: throw new NotImplementedException($"Stmt: {statement.GetType().Name}");
        }
    }

    private void GenerateReturn(ReturnStatementNode ret, AnalysisContext context)
    {
        if (ret.Expression != null) ExpressionGenerator.GenerateExpression(ret.Expression, context);
        _context.GenerateFunctionEpilogue();
    }

    private void GenerateWhile(WhileStatementNode w, AnalysisContext context)
    {
        int i = _context.GetNextLabelId();
        Builder.AppendLabel($"_while_start_{i}");
        ExpressionGenerator.GenerateExpression(w.Condition, context);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction($"je _while_end_{i}");
        GenerateStatement(w.Body, context);
        Builder.AppendInstruction($"jmp _while_start_{i}");
        Builder.AppendLabel($"_while_end_{i}");
    }

    private void GenerateIf(IfStatementNode i, AnalysisContext context)
    {
        int idx = _context.GetNextLabelId();
        ExpressionGenerator.GenerateExpression(i.Condition, context);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction(i.ElseBody != null ? $"je _if_else_{idx}" : $"je _if_end_{idx}");
        GenerateStatement(i.ThenBody, context);
        if (i.ElseBody != null)
        {
            Builder.AppendInstruction($"jmp _if_end_{idx}");
            Builder.AppendLabel($"_if_else_{idx}");
            GenerateStatement(i.ElseBody, context);
        }
        Builder.AppendLabel($"_if_end_{idx}");
    }
}
</file>

<file path="Generator\SymbolTable.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class SymbolTable
{
    private readonly Dictionary<string, (int Offset, string Type, bool IsConst)> _symbols = new(); // Added IsConst

    public int TotalLocalSize { get; }

    public SymbolTable(FunctionDeclarationNode function, TypeManager typeManager, CompilationUnitNode currentUnit)
    {
        var allLocalDeclarations = new List<DeclarationStatementNode>();
        CollectDeclarations(function.Body, allLocalDeclarations); // Recursively collect all declarations

        // Pre-calculate space for all local variables
        TotalLocalSize = 0;
        foreach (var d in allLocalDeclarations)
        {
            var rawTypeName = typeManager.GetTypeName(d.Type, d.PointerLevel);

            // Resolve the base type name, then append the pointer suffix back if any
            string baseTypeName = rawTypeName.TrimEnd('*');
            string pointerSuffix = new string('*', rawTypeName.Length - baseTypeName.Length);

            string resolvedTypeName;
            if (d.Type.Type == TokenType.Keyword || baseTypeName.Equals("void", StringComparison.OrdinalIgnoreCase))
            {
                resolvedTypeName = rawTypeName; // Primitive types like int, char, or void don't need resolution
            }
            else
            {
                resolvedTypeName = typeManager.ResolveTypeName(baseTypeName, function.Namespace, currentUnit) + pointerSuffix;
            }

            TotalLocalSize += typeManager.GetSizeOfType(resolvedTypeName, currentUnit);
        }

        // Map parameter offsets (positive on stack frame)
        int currentParamOffset = 8; // EBP + 8 is first parameter
        foreach (var param in function.Parameters)
        {
            var rawTypeName = typeManager.GetTypeName(param.Type, param.PointerLevel);

            // Resolve the base type name, then append the pointer suffix back if any
            string baseTypeName = rawTypeName.TrimEnd('*');
            string pointerSuffix = new string('*', rawTypeName.Length - baseTypeName.Length);

            string resolvedTypeName;
            if (param.Type.Type == TokenType.Keyword || baseTypeName.Equals("void", StringComparison.OrdinalIgnoreCase))
            {
                resolvedTypeName = rawTypeName;
            }
            else
            {
                // For 'this' pointer in methods, its type is already fully qualified from Parser
                if (param.Name.Value == "this" && param.Type.Value.Contains("::"))
                {
                    resolvedTypeName = rawTypeName;
                }
                else
                {
                    resolvedTypeName = typeManager.ResolveTypeName(baseTypeName, function.Namespace, currentUnit) + pointerSuffix;
                }
            }

            // Parameters are not marked as 'const' in this simple implementation, they are effectively copies.
            _symbols[param.Name.Value] = (currentParamOffset, resolvedTypeName, false);
            currentParamOffset += Math.Max(4, typeManager.GetSizeOfType(resolvedTypeName, currentUnit)); // Arguments on stack are 4-byte aligned
        }

        // Map local variable offsets (negative on stack frame)
        int currentLocalOffset = 0;
        foreach (var decl in allLocalDeclarations) // Use all collected declarations
        {
            var rawTypeName = typeManager.GetTypeName(decl.Type, decl.PointerLevel);

            // Resolve the base type name, then append the pointer suffix back if any
            string baseTypeName = rawTypeName.TrimEnd('*');
            string pointerSuffix = new string('*', rawTypeName.Length - baseTypeName.Length);

            string resolvedTypeName;
            if (decl.Type.Type == TokenType.Keyword || baseTypeName.Equals("void", StringComparison.OrdinalIgnoreCase))
            {
                resolvedTypeName = rawTypeName;
            }
            else
            {
                resolvedTypeName = typeManager.ResolveTypeName(baseTypeName, function.Namespace, currentUnit) + pointerSuffix;
            }

            int size = typeManager.GetSizeOfType(resolvedTypeName, currentUnit);
            currentLocalOffset -= size;
            _symbols[decl.Identifier.Value] = (currentLocalOffset, resolvedTypeName, decl.IsConst); // Store IsConst
        }
    }

    private void CollectDeclarations(AstNode? node, List<DeclarationStatementNode> declarations)
    {
        if (node == null) return;

        if (node is DeclarationStatementNode decl)
        {
            declarations.Add(decl);
        }
        else if (node is BlockStatementNode block)
        {
            foreach (var stmt in block.Statements)
            {
                CollectDeclarations(stmt, declarations);
            }
        }
        else if (node is IfStatementNode ifStmt)
        {
            CollectDeclarations(ifStmt.ThenBody, declarations);
            CollectDeclarations(ifStmt.ElseBody, declarations);
        }
        else if (node is WhileStatementNode whileStmt)
        {
            CollectDeclarations(whileStmt.Body, declarations);
        }
        // Add other statement types if they can contain declarations
    }

    // Updated TryGetSymbol to include isConst
    public bool TryGetSymbol(string name, out int offset, out string type, out bool isConst)
    {
        if (_symbols.TryGetValue(name, out var symbol))
        {
            offset = symbol.Offset;
            type = symbol.Type;
            isConst = symbol.IsConst;
            return true;
        }

        offset = 0;
        type = string.Empty;
        isConst = false;
        return false;
    }

    public string GetSymbolType(string name)
    {
        if (_symbols.TryGetValue(name, out var symbol))
        {
            return symbol.Type;
        }
        throw new InvalidOperationException($"Symbol '{name}' not found in current scope.");
    }

    // This method is now less critical as TryGetSymbol is updated, but kept for clarity
    public bool IsSymbolConst(string name)
    {
        if (_symbols.TryGetValue(name, out var symbol))
        {
            return symbol.IsConst;
        }
        return false;
    }
}
</file>

<file path="Generator\TypeManager.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CTilde;

public class TypeManager
{
    private readonly ProgramNode _program;
    private readonly Dictionary<string, StructDefinitionNode> _structs;
    private readonly List<FunctionDeclarationNode> _functions;
    private readonly Dictionary<string, EnumDefinitionNode> _enums;
    private readonly Dictionary<string, CompilationUnitNode> _structUnitMap;
    private readonly Dictionary<string, CompilationUnitNode> _enumUnitMap;

    public TypeManager(ProgramNode program)
    {
        _program = program;
        _structs = program.CompilationUnits.SelectMany(cu => cu.Structs)
            .ToDictionary(s => s.Namespace != null ? $"{s.Namespace}::{s.Name}" : s.Name);
        _functions = program.CompilationUnits.SelectMany(cu => cu.Functions).ToList();
        _enums = program.CompilationUnits.SelectMany(cu => cu.Enums)
            .ToDictionary(e => e.Namespace != null ? $"{e.Namespace}::{e.Name}" : e.Name);

        _structUnitMap = new Dictionary<string, CompilationUnitNode>();
        _enumUnitMap = new Dictionary<string, CompilationUnitNode>();

        foreach (var cu in program.CompilationUnits)
        {
            foreach (var s in cu.Structs)
            {
                _structUnitMap[s.Namespace != null ? $"{s.Namespace}::{s.Name}" : s.Name] = cu;
            }
            // Populate _enumUnitMap
            foreach (var e in cu.Enums)
            {
                _enumUnitMap[e.Namespace != null ? $"{e.Namespace}::{e.Name}" : e.Name] = cu;
            }
        }
    }

    /// <summary>
    /// Resolves an unqualified or aliased type name to its fully qualified name.
    /// Does NOT handle pointer suffixes (*). Expects base type name (e.g., "Color", "rl::Color").
    /// </summary>
    /// <param name="name">The unqualified or aliased type name (e.g., "Color", "rl::Color").</param>
    /// <param name="currentNamespace">The namespace of the current context (e.g., function's namespace).</param>
    /// <param name="context">The compilation unit context to get `using` directives.</param>
    /// <returns>The fully qualified type name (e.g., "raylib::Color").</returns>
    public string ResolveTypeName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        if (name.Contains("::"))
        {
            var parts = name.Split("::");
            var nsPart = parts[0];
            var typeName = parts[1];

            var aliased = context.Usings.FirstOrDefault(u => u.Alias == nsPart);
            if (aliased != null)
            {
                var fqn = $"{aliased.Namespace}::{typeName}";
                return _structs.ContainsKey(fqn) ? fqn : throw new InvalidOperationException($"Type '{name}' with aliased namespace '{nsPart}' not found.");
            }
            // If it's already a qualified name and not an alias, check it directly
            return _structs.ContainsKey(name) ? name : throw new InvalidOperationException($"Type '{name}' not found.");
        }

        var candidates = new List<string>();

        // 1. Check current namespace
        if (currentNamespace != null)
        {
            var fqn = $"{currentNamespace}::{name}";
            if (_structs.ContainsKey(fqn)) candidates.Add(fqn);
        }

        // 2. Check using namespaces (without aliases)
        foreach (UsingDirectiveNode? u in context.Usings.Where(u => u.Alias == null))
        {
            string fqn = $"{u.Namespace}::{name}";

            if (!_structs.ContainsKey(fqn))
            {
                continue;
            }

            candidates.Add(fqn);
        }

        // 3. Check global namespace
        if (_structs.ContainsKey(name)) candidates.Add(name);

        if (candidates.Count == 0) throw new InvalidOperationException($"Type '{name}' could not be resolved in the current context.");
        if (candidates.Distinct().Count() > 1) throw new InvalidOperationException($"Type '{name}' is ambiguous between: {string.Join(", ", candidates.Distinct())}");

        return candidates.First();
    }

    public FunctionDeclarationNode ResolveFunctionCall(ExpressionNode callee, CompilationUnitNode context, FunctionDeclarationNode currentFunction)
    {
        if (callee is VariableExpressionNode varNode)
        {
            return ResolveFunctionByName(varNode.Identifier.Value, currentFunction.Namespace, context);
        }
        if (callee is QualifiedAccessExpressionNode qNode)
        {
            var qualifier = qNode.Namespace.Value; // This is now potentially an enum type name OR a namespace alias/name
            var funcName = qNode.Member.Value;

            // First, check if the qualifier refers to an enum type name.
            string? enumTypeFQN = ResolveEnumTypeName(qualifier, currentFunction.Namespace, context);
            if (enumTypeFQN != null)
            {
                // If it resolves to an enum type, then this is not a function call.
                // It's an error to call a function using EnumType::member syntax, so this path should not be reached for successful enum member lookups
                throw new InvalidOperationException($"'{qualifier}::{funcName}' is an enum member, not a function.");
            }

            // If it's not an enum type, treat the qualifier as a namespace or alias.
            string? resolvedNamespace = qualifier;
            var aliased = context.Usings.FirstOrDefault(u => u.Alias == qualifier);
            if (aliased != null) resolvedNamespace = aliased.Namespace;

            var func = _functions.FirstOrDefault(f => f.OwnerStructName == null && f.Namespace == resolvedNamespace && f.Name == funcName);
            if (func == null) throw new InvalidOperationException($"Function '{resolvedNamespace}::{funcName}' not found.");
            return func;
        }
        throw new NotSupportedException($"Unsupported callee type for resolution: {callee.GetType().Name}");
    }

    private FunctionDeclarationNode ResolveFunctionByName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        var candidates = new List<FunctionDeclarationNode>();

        if (currentNamespace != null)
        {
            candidates.AddRange(_functions.Where(f => f.OwnerStructName == null && f.Namespace == currentNamespace && f.Name == name));
        }

        foreach (var u in context.Usings.Where(u => u.Alias == null))
        {
            candidates.AddRange(_functions.Where(f => f.OwnerStructName == null && f.Namespace == u.Namespace && f.Name == name));
        }

        candidates.AddRange(_functions.Where(f => f.OwnerStructName == null && f.Namespace == null && f.Name == name));

        var distinctCandidates = candidates.Distinct().ToList();

        if (distinctCandidates.Count == 0) throw new InvalidOperationException($"Function '{name}' could not be resolved in the current context.");
        if (distinctCandidates.Count > 1)
        {
            var sigs = distinctCandidates.Select(f => f.Namespace != null ? $"{f.Namespace}::{f.Name}" : f.Name);
            throw new InvalidOperationException($"Function call '{name}' is ambiguous between: {string.Join(", ", sigs)}");
        }

        return distinctCandidates.First();
    }

    public FunctionDeclarationNode ResolveMethod(StructDefinitionNode owner, string name)
    {
        var method = _functions.FirstOrDefault(f => f.OwnerStructName == owner.Name && f.Namespace == owner.Namespace && f.Name == name);
        return method == null ? throw new InvalidOperationException($"Method '{name}' not found on struct '{owner.Name}'") : method;
    }

    /// <summary>
    /// Resolves an unqualified or aliased enum type name to its fully qualified name.
    /// </summary>
    /// <param name="name">The unqualified or aliased enum type name (e.g., "KeyboardKey", "rl::KeyboardKey").</param>
    /// <param name="currentNamespace">The namespace of the current context.</param>
    /// <param name="context">The compilation unit context to get `using` directives.</param>
    /// <returns>The fully qualified enum type name (e.g., "raylib::KeyboardKey"), or null if not found.</returns>
    public string? ResolveEnumTypeName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        if (name.Contains("::"))
        {
            var parts = name.Split("::");
            var nsPart = parts[0];
            var enumName = parts[1];

            var aliased = context.Usings.FirstOrDefault(u => u.Alias == nsPart);
            if (aliased != null)
            {
                var fqn = $"{aliased.Namespace}::{enumName}";
                return _enums.ContainsKey(fqn) ? fqn : null;
            }
            // If it's already a qualified name and not an alias, check it directly
            return _enums.ContainsKey(name) ? name : null;
        }

        // Try current namespace
        if (currentNamespace != null)
        {
            var fqn = $"{currentNamespace}::{name}";
            if (_enums.ContainsKey(fqn)) return fqn;
        }

        // Try using namespaces (without aliases)
        foreach (var u in context.Usings.Where(u => u.Alias == null))
        {
            var fqn = $"{u.Namespace}::{name}";
            if (_enums.ContainsKey(fqn)) return fqn;
        }

        // Try global namespace
        if (_enums.ContainsKey(name)) return name;

        return null; // Enum type not found
    }


    /// <summary>
    /// Gets the integer value of an enum member given its fully qualified enum type name.
    /// </summary>
    /// <param name="enumFQN">The fully qualified name of the enum type (e.g., "raylib::KeyboardKey").</param>
    /// <param name="memberName">The name of the enum member (e.g., "KEY_D").</param>
    /// <returns>The integer value of the enum member, or null if not found.</returns>
    public int? GetEnumValue(string enumFQN, string memberName)
    {
        if (_enums.TryGetValue(enumFQN, out var enumDef))
        {
            var member = enumDef.Members.FirstOrDefault(m => m.Name.Value == memberName);
            if (member != null) return member.Value;
        }
        return null;
    }


    /// <summary>
    /// Resolves an unqualified enum member access to its integer value.
    /// Used for bare identifiers like `KEY_D` when `using` directives or current namespace apply.
    /// </summary>
    /// <param name="memberName">The enum member name (e.g., "KEY_D").</param>
    /// <param name="context">The compilation unit context for `using` directives.</param>
    /// <param name="currentContextNamespace">The namespace of the current context.</param>
    /// <returns>The integer value of the enum member, or null if not found.</returns>
    public int? ResolveUnqualifiedEnumMember(string memberName, CompilationUnitNode context, string? currentContextNamespace)
    {
        // 1. Check current namespace for any enum containing this member
        if (currentContextNamespace != null)
        {
            foreach (var enumDef in _enums.Values.Where(e => e.Namespace == currentContextNamespace))
            {
                var member = enumDef.Members.FirstOrDefault(m => m.Name.Value == memberName);
                if (member != null) return member.Value;
            }
        }

        // 2. Check using namespaces (without aliases) for any enum containing this member
        foreach (var u in context.Usings.Where(u => u.Alias == null))
        {
            foreach (var enumDef in _enums.Values.Where(e => e.Namespace == u.Namespace))
            {
                var member = enumDef.Members.FirstOrDefault(m => m.Name.Value == memberName);
                if (member != null) return member.Value;
            }
        }

        // 3. Check global namespace (enums with null namespace) for any enum containing this member
        foreach (var enumDef in _enums.Values.Where(e => e.Namespace == null))
        {
            var member = enumDef.Members.FirstOrDefault(m => m.Name.Value == memberName);
            if (member != null) return member.Value;
        }
        return null;
    }


    public StructDefinitionNode? FindStruct(string qualifiedName) => _structs.TryGetValue(qualifiedName, out var def) ? def : null;

    public (StructDefinitionNode Def, string FullName) GetStructTypeFromUnqualifiedName(string name, string? currentNamespace)
    {
        var qualifiedName = currentNamespace != null ? $"{currentNamespace}::{name}" : name;
        if (_structs.TryGetValue(qualifiedName, out var def)) return (def, qualifiedName);
        if (currentNamespace != null && _structs.TryGetValue(name, out def)) return (def, name); // Check global scope if not found in current namespace
        throw new InvalidOperationException($"Could not resolve struct type '{name}' in context '{currentNamespace}'.");
    }

    public (StructDefinitionNode Def, string FullName) GetStructTypeFromFullName(string fullName)
    {
        if (_structs.TryGetValue(fullName, out var def)) return (def, fullName);
        throw new InvalidOperationException($"Could not find struct definition for '{fullName}'.");
    }

    public string GetTypeName(Token type, int pointerLevel)
    {
        var sb = new StringBuilder(type.Value);
        for (int i = 0; i < pointerLevel; i++) sb.Append('*');
        return sb.ToString();
    }

    public int GetSizeOfType(string typeName, CompilationUnitNode context)
    {
        if (typeName.EndsWith("*")) return 4; // Pointers are always 4 bytes
        if (typeName == "int") return 4;
        if (typeName == "char") return 1;

        // If it's not a primitive or pointer, it must be a struct type.
        // It must be a fully qualified name here.
        if (_structs.TryGetValue(typeName, out var structDef))
        {
            // When calculating the size of a struct, resolve its members' types
            // using the *struct's own compilation unit context*, not the calling context.
            var structDefUnit = _structUnitMap[typeName]; // Get the unit where this struct was defined

            return structDef.Members.Sum(mem =>
            {
                var rawMemberType = GetTypeName(mem.Type, mem.PointerLevel);

                string baseMemberName = rawMemberType.TrimEnd('*');
                string pointerSuffix = new string('*', rawMemberType.Length - baseMemberName.Length);

                string resolvedMemberTypeForSize;
                if (mem.Type.Type == TokenType.Keyword || baseMemberName.Equals("void", StringComparison.OrdinalIgnoreCase))
                {
                    resolvedMemberTypeForSize = rawMemberType; // Primitive types, void don't need resolution
                }
                else
                {
                    // Resolve member type using the namespace and usings of the *struct definition's unit*
                    resolvedMemberTypeForSize = ResolveTypeName(baseMemberName, structDef.Namespace, structDefUnit) + pointerSuffix;
                }
                return GetSizeOfType(resolvedMemberTypeForSize, structDefUnit); // Recursive call, passing struct's unit
            });
        }
        throw new InvalidOperationException($"Unknown type '{typeName}' for size calculation.");
    }

    public bool IsStruct(string typeName) => _structs.ContainsKey(typeName.TrimEnd('*')); // Check if base type name is a struct

    public (int offset, string type) GetMemberInfo(string structName, string memberName, CompilationUnitNode context)
    {
        if (!_structs.TryGetValue(structName, out var structDef))
            throw new InvalidOperationException($"Undefined struct '{structName}'");

        int currentOffset = 0;
        // Get the compilation unit where this struct was defined to use its usings for member type resolution
        var structDefUnit = _structUnitMap[structName];

        foreach (var mem in structDef.Members) // Changed loop variable from 'member' to 'mem' to avoid conflict
        {
            var rawMemberType = GetTypeName(mem.Type, mem.PointerLevel);

            string baseMemberName = rawMemberType.TrimEnd('*');
            string pointerSuffix = new string('*', rawMemberType.Length - baseMemberName.Length);

            string resolvedMemberType;
            if (mem.Type.Type == TokenType.Keyword || baseMemberName.Equals("void", StringComparison.OrdinalIgnoreCase))
            {
                resolvedMemberType = rawMemberType; // Primitive, no resolution needed
            }
            else
            {
                // Resolve member type using the namespace and usings of the *struct definition's unit*
                resolvedMemberType = ResolveTypeName(baseMemberName, structDef.Namespace, structDefUnit) + pointerSuffix;
            }

            if (mem.Name.Value == memberName)
            {
                return (currentOffset, resolvedMemberType);
            }
            currentOffset += GetSizeOfType(resolvedMemberType, structDefUnit); // Pass struct's unit here too
        }
        throw new InvalidOperationException($"Struct '{structName}' has no member '{memberName}'");
    }

    public bool IsMemberConst(string structName, string memberName)
    {
        if (!_structs.TryGetValue(structName, out var structDef))
            throw new InvalidOperationException($"Undefined struct '{structName}'");

        var member = structDef.Members.FirstOrDefault(m => m.Name.Value == memberName);
        if (member == null)
        {
            throw new InvalidOperationException($"Struct '{structName}' has no member '{memberName}'.");
        }
        return member.IsConst;
    }
}
</file>

<file path="main.c">
#import "raylib.dll"
#include "raylib.c"
#include "text_object.c"

using rl = raylib;

int main() 
{
    const int screenWidth = 800; // Declared as const
    const int screenHeight = 600; // Declared as const
    int deltaTimeMs; 
    int currentFPS; 

    rl::Color rayWhite = {245, 245, 245, 255};
    rl::Color maroon = {190, 33, 55, 255};

    TextObject myText;
    myText.init(140, 275, "Encapsulation!", 20, maroon);

    rl::InitWindow(screenWidth, screenHeight, "CTilde with Access Specifiers!");
    rl::SetTargetFPS(60); // Set target frames per second

    while (rl::WindowShouldClose() == 0) 
    {
        currentFPS = rl::GetFPS(); 
        // Calculate deltaTime in milliseconds. Avoid division by zero.
        if (currentFPS > 0) {
            deltaTimeMs = 1000 / currentFPS; 
        } else {
            deltaTimeMs = 0; // No movement if FPS is zero
        }

        rl::BeginDrawing();
        rl::ClearBackground(rayWhite);
        
        myText.move_right(deltaTimeMs); // Pass reliable deltaTime in milliseconds
        myText.draw();
        
        rl::EndDrawing();
    }

    rl::CloseWindow();
    
    return 0;
}
</file>

<file path="merged.c">
#import "raylib.dll"
namespace raylib;

struct Color 
{
    char r;
    char g;
    char b;
    char a;
};

void InitWindow(int width, int height, int title);
int WindowShouldClose();
void BeginDrawing();
void EndDrawing();
void ClearBackground(Color color);
void DrawText(int text, int posX, int posY, int fontSize, Color color);
void CloseWindow();

using raylib;

struct TextObject 
{
private:
    int x;

public:
    int y;
    int text;
    int fontSize;
    Color color;

    void init(int startX, int startY, int newText, int fSize, Color newColor) 
    {
        x = startX;
        y = startY;
        text = newText;
        fontSize = fSize;
        color = newColor;
    }

    void draw() 
    {
        DrawText(text, x, y, fontSize, color);
    }
    
    void move_right() 
    {
        x = x + 1;
    }
};


using raylib;

int main() 
{
    int screenWidth = 800;
    int screenHeight = 600;

    Color rayWhite = {245, 245, 245, 255};
    Color maroon = {190, 33, 55, 255};

    TextObject myText;
    // Initialize the object using its public method.
    // Direct access like `myText.x = 140;` would fail because x is private.
    myText.init(140, 275, "Encapsulation!", 20, maroon);

    InitWindow(screenWidth, screenHeight, "CTilde with Access Specifiers!");

    while (WindowShouldClose() == 0) 
    {
        BeginDrawing();
        ClearBackground(rayWhite);
        
        myText.move_right();
        myText.draw();
        
        EndDrawing();
    }

    CloseWindow();
    
    return 0;
}
</file>

<file path="raylib.c">
namespace raylib;

struct Color 
{
    char r;
    char g;
    char b;
    char a;
};

enum KeyboardKey { // No 'raylib::' prefix needed here as it's already in the namespace
    KEY_D = 68,
    KEY_A = 65,
    KEY_W = 87,
    KEY_S = 83,
    KEY_LEFT = 263,
    KEY_RIGHT = 262,
    KEY_UP = 265,
    KEY_DOWN = 264
};

void InitWindow(int width, int height, int title);
void SetTargetFPS(int fps); // Added for basic game loop control
int WindowShouldClose();
void BeginDrawing();
void EndDrawing();
void ClearBackground(Color color);
void DrawText(int text, int posX, int posY, int fontSize, Color color);
void CloseWindow();
// Removed GetFrameTime() prototype as it returns float in Raylib, which truncates to 0 for int
int GetFPS(); // Added for integer-based delta time calculation
int IsKeyDown(int key); // Added for input handling (takes int key code)
</file>

<file path="text_object.c">
using raylib;

struct TextObject 
{
private:
    int x; // Made 'x' const
    int speed; 

public:
    int y;
    int text;
    int fontSize;
    Color color;

    void init(int startX, int startY, int newText, int fSize, Color newColor) 
    {
        x = startX; // This will now violate const
        y = startY;
        text = newText;
        fontSize = fSize;
        color = newColor;
        speed = 100; 
    }

    void draw() 
    {
        DrawText(text, x, y, fontSize, color);
    }
    
    void move_right(int deltaTime) 
    {
        if (IsKeyDown(KeyboardKey::KEY_D)) // MODIFIED: Using C++-style enum access
        {
            x = x + (speed * deltaTime / 1000); // This will also violate const
        }
    }
};
</file>

