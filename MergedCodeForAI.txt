<file path="Ast.cs">
using System.Collections.Generic;

namespace CTilde;

public enum AccessSpecifier { Public, Private }

// Base classes
public abstract record AstNode
{
    public AstNode? Parent { get; set; }

    public IEnumerable<AstNode> Ancestors()
    {
        var current = Parent;
        while (current != null)
        {
            yield return current;
            current = current.Parent;
        }
    }
}
public abstract record StatementNode : AstNode;
public abstract record ExpressionNode : AstNode;

// Program structure
public record ImportDirectiveNode(string LibraryName) : AstNode;
public record UsingDirectiveNode(string Namespace, string? Alias) : AstNode;
public record MemberVariableNode(bool IsConst, Token Type, int PointerLevel, Token Name, AccessSpecifier AccessLevel) : AstNode;
public record StructDefinitionNode(string Name, string? BaseStructName, string? Namespace, List<MemberVariableNode> Members, List<FunctionDeclarationNode> Methods, List<ConstructorDeclarationNode> Constructors, List<DestructorDeclarationNode> Destructors) : AstNode;
public record ParameterNode(Token Type, int PointerLevel, Token Name) : AstNode;
public record FunctionDeclarationNode(Token ReturnType, int ReturnPointerLevel, string Name, List<ParameterNode> Parameters, StatementNode? Body, string? OwnerStructName, AccessSpecifier AccessLevel, bool IsVirtual, bool IsOverride, string? Namespace) : AstNode;
public record BaseInitializerNode(List<ExpressionNode> Arguments) : AstNode;
public record ConstructorDeclarationNode(string OwnerStructName, string? Namespace, AccessSpecifier AccessLevel, List<ParameterNode> Parameters, BaseInitializerNode? Initializer, StatementNode Body) : AstNode;
public record DestructorDeclarationNode(string OwnerStructName, string? Namespace, AccessSpecifier AccessLevel, bool IsVirtual, StatementNode Body) : AstNode;
public record EnumDefinitionNode(string Name, string? Namespace, List<EnumMemberNode> Members) : AstNode;
public record EnumMemberNode(Token Name, int Value) : AstNode;

// New top-level structure for compilation units
public record CompilationUnitNode(string FilePath, List<UsingDirectiveNode> Usings, List<StructDefinitionNode> Structs, List<FunctionDeclarationNode> Functions, List<EnumDefinitionNode> Enums) : AstNode;
public record ProgramNode(List<ImportDirectiveNode> Imports, List<CompilationUnitNode> CompilationUnits) : AstNode;


// Statements
public record BlockStatementNode(List<StatementNode> Statements) : StatementNode;
public record ReturnStatementNode(ExpressionNode? Expression) : StatementNode;
public record WhileStatementNode(ExpressionNode Condition, StatementNode Body) : StatementNode;
public record IfStatementNode(ExpressionNode Condition, StatementNode ThenBody, StatementNode? ElseBody) : StatementNode;
public record DeclarationStatementNode(bool IsConst, Token Type, int PointerLevel, Token Identifier, ExpressionNode? Initializer, List<ExpressionNode>? ConstructorArguments) : StatementNode;
public record ExpressionStatementNode(ExpressionNode Expression) : StatementNode;
public record DeleteStatementNode(ExpressionNode Expression) : StatementNode; // NEW


// Expressions
public record InitializerListExpressionNode(List<ExpressionNode> Values) : ExpressionNode;
public record IntegerLiteralNode(int Value) : ExpressionNode;
public record StringLiteralNode(string Value, string Label) : ExpressionNode;
public record UnaryExpressionNode(Token Operator, ExpressionNode Right) : ExpressionNode;
public record AssignmentExpressionNode(ExpressionNode Left, ExpressionNode Right) : ExpressionNode;
public record VariableExpressionNode(Token Identifier) : ExpressionNode;
public record CallExpressionNode(ExpressionNode Callee, List<ExpressionNode> Arguments) : ExpressionNode;
public record BinaryExpressionNode(ExpressionNode Left, Token Operator, ExpressionNode Right) : ExpressionNode;
public record MemberAccessExpressionNode(ExpressionNode Left, Token Operator, Token Member) : ExpressionNode;
public record QualifiedAccessExpressionNode(ExpressionNode Left, Token Member) : ExpressionNode;
public record NewExpressionNode(Token Type, List<ExpressionNode> Arguments) : ExpressionNode; // NEW
</file>

<file path="Compiler.cs">
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CTilde;

public class Compiler
{
    public void Compile(string entryFilePath)
    {
        // 1. Discover all source files from #includes
        var preprocessor = new Preprocessor();
        var allFiles = preprocessor.DiscoverDependencies(entryFilePath);

        // 2. Parse each file into a CompilationUnit
        var compilationUnits = new List<CompilationUnitNode>();
        var allImports = new List<ImportDirectiveNode>();

        foreach (var file in allFiles)
        {
            var code = File.ReadAllText(file);
            var tokens = Tokenizer.Tokenize(code);
            var parser = new Parser(tokens);
            var unit = parser.Parse(file);

            // Collect all #import directives globally
            var importsInFile = parser.GetImports();
            allImports.AddRange(importsInFile);

            compilationUnits.Add(unit);
        }

        var programNode = new ProgramNode(allImports.DistinctBy(i => i.LibraryName).ToList(), compilationUnits);

        // 3. Generate Code
        var generator = new CodeGenerator(programNode);
        string asmCode = generator.Generate();

        // 4. Output
        File.WriteAllText("Output/output.asm", asmCode);
        Console.WriteLine("Compilation successful. Assembly code written to output.asm");
    }
}
</file>

<file path="Preprocessor.cs">
namespace CTilde;

public class Preprocessor
{
    public List<string> DiscoverDependencies(string entryFilePath)
    {
        var allFiles = new List<string>();
        var processedFiles = new HashSet<string>();
        var filesToProcess = new Queue<string>();

        filesToProcess.Enqueue(Path.GetFullPath(entryFilePath));

        while (filesToProcess.Count > 0)
        {
            var currentFile = filesToProcess.Dequeue();
            if (!File.Exists(currentFile) || processedFiles.Contains(currentFile))
            {
                continue;
            }

            processedFiles.Add(currentFile);
            allFiles.Add(currentFile);

            string directory = Path.GetDirectoryName(currentFile) ?? "";

            foreach (var line in File.ReadLines(currentFile))
            {
                var trimmedLine = line.Trim();
                if (trimmedLine.StartsWith("#include"))
                {
                    var startIndex = trimmedLine.IndexOf('"');
                    var endIndex = trimmedLine.LastIndexOf('"');
                    if (startIndex != -1 && endIndex > startIndex)
                    {
                        var includeFileName = trimmedLine.Substring(startIndex + 1, endIndex - startIndex - 1);
                        var fullIncludePath = Path.GetFullPath(Path.Combine(directory, includeFileName));
                        filesToProcess.Enqueue(fullIncludePath);
                    }
                }
            }
        }

        // The order matters for parsing: dependencies should come first.
        // We reverse because the entry point was added first.
        allFiles.Reverse();
        return allFiles;
    }
}
</file>

<file path="Program.cs">
using System;

namespace CTilde;

public class Program
{
    public static void Main(string[] args)
    {
        var compiler = new Compiler();
        compiler.Compile("Output/main.c");
    }
}
</file>

<file path="Analysis\AnalysisContext.cs">
namespace CTilde;

public record AnalysisContext(
    SymbolTable Symbols,
    CompilationUnitNode CompilationUnit,
    FunctionDeclarationNode CurrentFunction
);
</file>

<file path="Analysis\FunctionResolver.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class FunctionResolver
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;
    private readonly ProgramNode _program; // For accessing all functions

    public FunctionResolver(TypeRepository typeRepository, TypeResolver typeResolver, ProgramNode program)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
        _program = program;
    }

    public FunctionDeclarationNode ResolveFunctionCall(ExpressionNode callee, CompilationUnitNode context, FunctionDeclarationNode? currentFunction)
    {
        if (callee is VariableExpressionNode varNode) return ResolveFunctionByName(varNode.Identifier.Value, currentFunction?.Namespace, context);
        if (callee is QualifiedAccessExpressionNode qNode)
        {
            string qualifier = TypeResolver.ResolveQualifier(qNode.Left);
            var funcName = qNode.Member.Value;
            string? resolvedNamespace = qualifier;
            var aliased = context.Usings.FirstOrDefault(u => u.Alias == qualifier);
            if (aliased != null) resolvedNamespace = aliased.Namespace;

            var globalFunctions = _program.CompilationUnits.SelectMany(cu => cu.Functions);
            var func = globalFunctions.FirstOrDefault(f => f.OwnerStructName == null && f.Namespace == resolvedNamespace && f.Name == funcName);
            if (func == null) throw new InvalidOperationException($"Function '{resolvedNamespace}::{funcName}' not found.");
            return func;
        }
        throw new NotSupportedException($"Unsupported callee type for resolution: {callee.GetType().Name}");
    }

    private FunctionDeclarationNode ResolveFunctionByName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        var globalFunctions = _program.CompilationUnits.SelectMany(cu => cu.Functions);
        var candidates = globalFunctions.Where(f => f.OwnerStructName == null && f.Name == name)
            .Where(f => f.Namespace == currentNamespace || f.Namespace == null || context.Usings.Any(u => u.Alias == null && u.Namespace == f.Namespace)).ToList();
        if (candidates.Count == 0) throw new InvalidOperationException($"Function '{name}' could not be resolved in the current context.");
        if (candidates.Select(f => f.Namespace).Distinct().Count() > 1) throw new InvalidOperationException($"Function call '{name}' is ambiguous.");
        return candidates.First();
    }

    public FunctionDeclarationNode ResolveMethod(StructDefinitionNode owner, string name) => owner.Methods.FirstOrDefault(m => m.Name == name) ?? throw new InvalidOperationException($"Method '{name}' not found on struct '{owner.Name}'");

    public FunctionDeclarationNode? FindMethod(string structFqn, string methodName)
    {
        var structDef = _typeRepository.FindStruct(structFqn);
        return structDef?.Methods.FirstOrDefault(m => m.Name == methodName);
    }

    public ConstructorDeclarationNode? FindConstructor(string structFqn, List<string> argTypeFqns)
    {
        var structDef = _typeRepository.FindStruct(structFqn);
        if (structDef == null) return null;

        var ctorUnit = _typeRepository.GetCompilationUnitForStruct(structFqn);

        foreach (var ctor in structDef.Constructors)
        {
            if (ctor.Parameters.Count != argTypeFqns.Count) continue;

            bool allParamsMatch = true;
            for (int i = 0; i < argTypeFqns.Count; i++)
            {
                var param = ctor.Parameters[i];
                var rawParamType = TypeRepository.GetTypeNameFromToken(param.Type, param.PointerLevel);
                var baseParamType = rawParamType.TrimEnd('*');
                var pointerSuffix = new string('*', rawParamType.Length - baseParamType.Length);

                string resolvedParamType;
                if (param.Type.Type == TokenType.Keyword || baseParamType.Equals("void", StringComparison.OrdinalIgnoreCase))
                {
                    resolvedParamType = rawParamType;
                }
                else
                {
                    resolvedParamType = _typeResolver.ResolveTypeName(baseParamType, ctor.Namespace, ctorUnit) + pointerSuffix;
                }

                string argumentType = argTypeFqns[i];
                bool isMatch = resolvedParamType == argumentType;

                if (!isMatch && resolvedParamType == "char" && argumentType == "int")
                {
                    isMatch = true;
                }

                if (!isMatch)
                {
                    allParamsMatch = false;
                    break;
                }
            }

            if (allParamsMatch) return ctor;
        }

        return null;
    }

    public DestructorDeclarationNode? FindDestructor(string fqn)
    {
        var structDef = _typeRepository.FindStruct(fqn);
        return structDef?.Destructors.FirstOrDefault();
    }

    public int? GetEnumValue(string enumFQN, string memberName)
    {
        var ed = _typeRepository.FindEnum(enumFQN);
        return ed?.Members.FirstOrDefault(m => m.Name.Value == memberName)?.Value;
    }

    public int? ResolveUnqualifiedEnumMember(string memberName, CompilationUnitNode context, string? currentContextNamespace)
    {
        var namespacesToCheck = new List<string?> { currentContextNamespace }
            .Concat(context.Usings.Where(u => u.Alias == null).Select(u => u.Namespace))
            .Append(null);

        foreach (var ns in namespacesToCheck.Distinct())
        {
            foreach (var enumDef in _typeRepository.GetAllEnums().Where(e => e.Namespace == ns))
            {
                if (enumDef.Members.Any(m => m.Name.Value == memberName))
                {
                    return GetEnumValue(TypeRepository.GetFullyQualifiedName(enumDef), memberName);
                }
            }
        }
        return null;
    }
}
</file>

<file path="Analysis\SemanticAnalyzer.cs">
using System;
using System.Linq;

namespace CTilde;

public class SemanticAnalyzer
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;
    private readonly FunctionResolver _functionResolver;
    private readonly MemoryLayoutManager _memoryLayoutManager;

    public SemanticAnalyzer(TypeRepository typeRepository, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
        _functionResolver = functionResolver;
        _memoryLayoutManager = memoryLayoutManager;
    }

    public string AnalyzeExpressionType(ExpressionNode expr, AnalysisContext context)
    {
        return expr switch
        {
            IntegerLiteralNode => "int",
            StringLiteralNode => "char*",
            VariableExpressionNode v => AnalyzeVariableExpression(v, context),
            AssignmentExpressionNode a => AnalyzeExpressionType(a.Left, context), // Type of assignment is type of l-value
            MemberAccessExpressionNode ma => AnalyzeMemberAccessExpression(ma, context),
            UnaryExpressionNode u => AnalyzeUnaryExpression(u, context),
            CallExpressionNode c => AnalyzeCallExpression(c, context),
            QualifiedAccessExpressionNode q => AnalyzeQualifiedAccessExpression(q, context),
            NewExpressionNode n => AnalyzeNewExpression(n, context),
            BinaryExpressionNode bin => AnalyzeBinaryExpression(bin, context),
            _ => throw new NotImplementedException($"AnalyzeExpressionType not implemented for {expr.GetType().Name}")
        };
    }

    public string AnalyzeFunctionReturnType(FunctionDeclarationNode func, AnalysisContext context)
    {
        var returnTypeNameRaw = TypeRepository.GetTypeNameFromToken(func.ReturnType, func.ReturnPointerLevel);
        string resolvedReturnName;

        if (func.ReturnType.Type != TokenType.Keyword && !returnTypeNameRaw.StartsWith("void"))
        {
            string baseReturnName = returnTypeNameRaw.TrimEnd('*');
            string pointerSuffix = new string('*', returnTypeNameRaw.Length - baseReturnName.Length);
            resolvedReturnName = _typeResolver.ResolveTypeName(baseReturnName, func.Namespace, context.CompilationUnit) + pointerSuffix;
        }
        else
        {
            resolvedReturnName = returnTypeNameRaw;
        }

        return resolvedReturnName;
    }

    private string AnalyzeBinaryExpression(BinaryExpressionNode bin, AnalysisContext context)
    {
        var leftTypeFqn = AnalyzeExpressionType(bin.Left, context);
        var rightTypeFqn = AnalyzeExpressionType(bin.Right, context);

        // Handle pointer arithmetic
        if (bin.Operator.Type is TokenType.Plus or TokenType.Minus)
        {
            if (leftTypeFqn.EndsWith("*") && rightTypeFqn == "int")
            {
                return leftTypeFqn; // e.g., char* + int -> char*
            }
            if (leftTypeFqn == "int" && rightTypeFqn.EndsWith("*") && bin.Operator.Type == TokenType.Plus)
            {
                return rightTypeFqn; // e.g., int + char* -> char*
            }
        }

        if (_typeRepository.IsStruct(leftTypeFqn))
        {
            try
            {
                var opName = $"operator_{NameMangler.MangleOperator(bin.Operator.Value)}";
                var overload = _functionResolver.FindMethod(leftTypeFqn, opName);

                if (overload != null)
                {
                    return AnalyzeFunctionReturnType(overload, context);
                }
            }
            catch (NotImplementedException)
            {
                // This operator is not overloadable.
            }
            throw new InvalidOperationException($"Operator '{bin.Operator.Value}' is not defined for type '{leftTypeFqn}'.");
        }

        // For other primitive operations (int + int, comparisons, etc.), the result is always int.
        return "int";
    }

    private string AnalyzeNewExpression(NewExpressionNode n, AnalysisContext context)
    {
        // A new expression always returns a pointer to the type.
        var typeName = _typeResolver.ResolveTypeName(n.Type.Value, context.CurrentFunction.Namespace, context.CompilationUnit);
        return typeName + "*";
    }

    private string AnalyzeVariableExpression(VariableExpressionNode v, AnalysisContext context)
    {
        // 1. Check local variables and parameters in the symbol table.
        if (context.Symbols.TryGetSymbol(v.Identifier.Value, out _, out var type, out _))
        {
            return type;
        }

        // 2. Try resolving as an unqualified enum member (e.g., `KEY_D`).
        var unqualifiedEnumValue = _functionResolver.ResolveUnqualifiedEnumMember(v.Identifier.Value, context.CompilationUnit, context.CurrentFunction.Namespace);
        if (unqualifiedEnumValue.HasValue)
        {
            return "int";
        }

        // 3. If in a method, try resolving as an implicit `this->member`.
        if (context.CurrentFunction.OwnerStructName != null)
        {
            try
            {
                string ownerStructFqn = context.CurrentFunction.Namespace != null
                    ? $"{context.CurrentFunction.Namespace}::{context.CurrentFunction.OwnerStructName}"
                    : context.CurrentFunction.OwnerStructName;

                (_, string memberTypeResolved) = _memoryLayoutManager.GetMemberInfo(ownerStructFqn, v.Identifier.Value, context.CompilationUnit);
                return memberTypeResolved;
            }
            catch (InvalidOperationException) { /* Fall through to the final error */ }
        }

        throw new InvalidOperationException($"Cannot determine type for undefined variable '{v.Identifier.Value}'.");
    }

    private string AnalyzeMemberAccessExpression(MemberAccessExpressionNode ma, AnalysisContext context)
    {
        var leftType = AnalyzeExpressionType(ma.Left, context);
        string baseStructType = leftType.TrimEnd('*');
        var (_, resolvedMemberType) = _memoryLayoutManager.GetMemberInfo(baseStructType, ma.Member.Value, context.CompilationUnit);
        return resolvedMemberType;
    }

    private string AnalyzeUnaryExpression(UnaryExpressionNode u, AnalysisContext context)
    {
        if (u.Operator.Type == TokenType.Ampersand) // Address-of operator
        {
            var operandType = AnalyzeExpressionType(u.Right, context);
            if (operandType.EndsWith("*"))
            {
                // Taking address of a pointer (e.g. `string**`)
                return operandType + "*";
            }
            // Taking address of a value type (e.g. `string s; &s;` -> `string*`)
            return operandType + "*";
        }

        if (u.Operator.Type == TokenType.Star) // Dereference operator
        {
            var operandType = AnalyzeExpressionType(u.Right, context);
            if (!operandType.EndsWith("*"))
            {
                throw new InvalidOperationException($"Cannot dereference non-pointer type '{operandType}'.");
            }
            return operandType[..^1]; // Remove one level of indirection
        }

        // For other unary operators like negation ('-'), the type does not change.
        return AnalyzeExpressionType(u.Right, context);
    }

    private string AnalyzeCallExpression(CallExpressionNode call, AnalysisContext context)
    {
        FunctionDeclarationNode func;
        if (call.Callee is MemberAccessExpressionNode callMemberAccess) // Method call: myText.draw()
        {
            var ownerTypeName = AnalyzeExpressionType(callMemberAccess.Left, context).TrimEnd('*');
            var ownerStruct = _typeRepository.FindStruct(ownerTypeName) ?? throw new InvalidOperationException($"Could not find struct definition for '{ownerTypeName}'.");
            func = _functionResolver.ResolveMethod(ownerStruct, callMemberAccess.Member.Value);
        }
        else // Global or namespaced function call: DrawText(), rl::DrawText()
        {
            func = _functionResolver.ResolveFunctionCall(call.Callee, context.CompilationUnit, context.CurrentFunction);
        }

        return AnalyzeFunctionReturnType(func, context);
    }

    private string AnalyzeQualifiedAccessExpression(QualifiedAccessExpressionNode q, AnalysisContext context)
    {
        // This expression is a value, so it must be an enum member.
        // `q.Left` resolves to the enum type (e.g., `raylib::KeyboardKey`)
        // `q.Member` resolves to the enum member (e.g., `KEY_D`)

        string potentialEnumTypeName = TypeResolver.ResolveQualifier(q.Left);
        string memberName = q.Member.Value;

        string? enumTypeFQN = _typeResolver.ResolveEnumTypeName(potentialEnumTypeName, context.CurrentFunction.Namespace, context.CompilationUnit);
        if (enumTypeFQN != null)
        {
            if (_functionResolver.GetEnumValue(enumTypeFQN, memberName).HasValue)
            {
                return "int"; // Enum members are integers.
            }
            throw new InvalidOperationException($"Enum '{potentialEnumTypeName}' (resolved to '{enumTypeFQN}') does not contain member '{memberName}'.");
        }

        // If not an enum, it's a qualified name like `rl::DrawText`. This is not a value on its own.
        // It's only valid as the `Callee` of a `CallExpression`, which is handled by `AnalyzeCallExpression`.
        throw new InvalidOperationException($"Qualified access '{potentialEnumTypeName}::{memberName}' cannot be evaluated as a value directly. Only enum members or function calls are supported.");
    }
}
</file>

<file path="Analysis\TypeResolver.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class TypeResolver
{
    private readonly TypeRepository _typeRepository;

    public TypeResolver(TypeRepository typeRepository)
    {
        _typeRepository = typeRepository;
    }

    public static string ResolveQualifier(ExpressionNode expr)
    {
        return expr switch
        {
            VariableExpressionNode v => v.Identifier.Value,
            QualifiedAccessExpressionNode q => $"{ResolveQualifier(q.Left)}::{q.Member.Value}",
            _ => throw new InvalidOperationException($"Cannot resolve qualifier from expression of type {expr.GetType().Name}")
        };
    }

    public string ResolveTypeName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        if (name.Contains("::"))
        {
            var parts = name.Split("::");
            var nsPart = parts[0];
            var typeName = parts[1];
            var aliased = context.Usings.FirstOrDefault(u => u.Alias == nsPart);
            if (aliased != null)
            {
                var fqn = $"{aliased.Namespace}::{typeName}";
                return _typeRepository.FindStruct(fqn) != null ? fqn : throw new InvalidOperationException($"Type '{name}' with aliased namespace '{nsPart}' not found.");
            }
            return _typeRepository.FindStruct(name) != null ? name : throw new InvalidOperationException($"Type '{name}' not found.");
        }

        var candidates = new List<string>();
        if (currentNamespace != null)
        {
            var fqn = $"{currentNamespace}::{name}";
            if (_typeRepository.FindStruct(fqn) != null) candidates.Add(fqn);
        }
        foreach (var u in context.Usings.Where(u => u.Alias == null))
        {
            string fqn = $"{u.Namespace}::{name}";
            if (_typeRepository.FindStruct(fqn) != null) candidates.Add(fqn);
        }
        if (_typeRepository.FindStruct(name) != null) candidates.Add(name);

        if (candidates.Count == 0) throw new InvalidOperationException($"Type '{name}' could not be resolved in the current context.");
        if (candidates.Distinct().Count() > 1) throw new InvalidOperationException($"Type '{name}' is ambiguous between: {string.Join(", ", candidates.Distinct())}");
        return candidates.First();
    }

    public string? ResolveEnumTypeName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        if (name.Contains("::"))
        {
            var parts = name.Split("::");
            var aliased = context.Usings.FirstOrDefault(u => u.Alias == parts[0]);
            var fqn = aliased != null ? $"{aliased.Namespace}::{parts[1]}" : name;
            return _typeRepository.FindEnum(fqn) != null ? fqn : null;
        }

        var namespacesToCheck = new List<string?> { currentNamespace }
            .Concat(context.Usings.Where(u => u.Alias == null).Select(u => u.Namespace))
            .Append(null);

        foreach (var ns in namespacesToCheck.Distinct())
        {
            var fqn = ns != null ? $"{ns}::{name}" : name;
            if (_typeRepository.FindEnum(fqn) != null) return fqn;
        }

        return null;
    }
}
</file>

<file path="Generator\AssemblyBuilder.cs">
using System.Text;

namespace CTilde;

public class AssemblyBuilder
{
    private readonly StringBuilder _sb = new();

    public void AppendDirective(string directive)
    {
        _sb.AppendLine(directive);
    }

    public void AppendLabel(string label)
    {
        _sb.AppendLine($"{label}:");
    }

    public void AppendInstruction(string? instruction, string? comment = null)
    {
        string line = instruction is null 
            ? "" 
            : $"    {instruction}";

        _sb.AppendLine(line.PadRight(35) + (comment is null ? "" : $"; {comment}"));
    }

    public void AppendData(string label, string value)
    {
        _sb.AppendLine($"    {label} db {value}");
    }

    public void AppendBlankLine()
    {
        _sb.AppendLine();
    }

    public override string ToString()
    {
        return _sb.ToString();
    }
}
</file>

<file path="Generator\CodeGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class CodeGenerator
{
    internal ProgramNode Program { get; }
    internal TypeRepository TypeRepository { get; }
    internal TypeResolver TypeResolver { get; }
    internal FunctionResolver FunctionResolver { get; }
    internal VTableManager VTableManager { get; }
    internal MemoryLayoutManager MemoryLayoutManager { get; }
    internal SemanticAnalyzer SemanticAnalyzer { get; }
    internal AssemblyBuilder Builder { get; } = new();

    private int _labelIdCounter;
    private readonly Dictionary<string, string> _stringLiterals = new();
    internal HashSet<string> ExternalFunctions { get; } = new();

    internal StatementGenerator StatementGenerator { get; }
    internal ExpressionGenerator ExpressionGenerator { get; }
    private readonly DeclarationGenerator _declarationGenerator;

    public CodeGenerator(ProgramNode program)
    {
        Program = program;
        TypeRepository = new TypeRepository(program);
        TypeResolver = new TypeResolver(TypeRepository);
        FunctionResolver = new FunctionResolver(TypeRepository, TypeResolver, program);
        VTableManager = new VTableManager(TypeRepository, TypeResolver);
        MemoryLayoutManager = new MemoryLayoutManager(TypeRepository, TypeResolver, VTableManager);
        SemanticAnalyzer = new SemanticAnalyzer(TypeRepository, TypeResolver, FunctionResolver, MemoryLayoutManager);

        ExpressionGenerator = new ExpressionGenerator(this);
        StatementGenerator = new StatementGenerator(this);
        _declarationGenerator = new DeclarationGenerator(this);
    }

    public string Generate()
    {
        FindAllStringLiterals(Program);

        foreach (var unit in Program.CompilationUnits)
            foreach (var f in unit.Functions.Where(f => f.Body == null))
            {
                ExternalFunctions.Add(f.Name);
            }

        var fasmWriter = new FasmWriter();
        fasmWriter.WritePreamble(Builder);

        GenerateVTables();
        fasmWriter.WriteDataSection(Builder, _stringLiterals);

        fasmWriter.WriteTextSectionHeader(Builder);
        fasmWriter.WriteEntryPoint(Builder);

        foreach (var unit in Program.CompilationUnits)
        {
            foreach (var function in unit.Functions.Where(f => f.Body != null))
            {
                _declarationGenerator.GenerateFunction(function, unit, null);
                Builder.AppendBlankLine();
            }

            foreach (var s in unit.Structs)
            {
                foreach (var method in s.Methods.Where(m => m.Body != null))
                {
                    _declarationGenerator.GenerateFunction(method, unit, s);
                    Builder.AppendBlankLine();
                }
                foreach (var ctor in s.Constructors)
                {
                    _declarationGenerator.GenerateConstructor(ctor, unit);
                    Builder.AppendBlankLine();
                }
                foreach (var dtor in s.Destructors)
                {
                    _declarationGenerator.GenerateDestructor(dtor, unit);
                    Builder.AppendBlankLine();
                }
            }
        }

        fasmWriter.WriteImportDataSection(Builder, Program, ExternalFunctions);

        return Builder.ToString();
    }

    private void GenerateVTables()
    {
        Builder.AppendDirective("section '.rdata' data readable");
        foreach (var s in Program.CompilationUnits.SelectMany(cu => cu.Structs))
        {
            var structFqn = TypeRepository.GetFullyQualifiedName(s);
            if (VTableManager.HasVTable(structFqn))
            {
                Builder.AppendLabel(NameMangler.GetVTableLabel(s));
                var vtable = VTableManager.GetVTable(structFqn);
                foreach (var entry in vtable)
                {
                    var mangledName = entry switch
                    {
                        FunctionDeclarationNode f => NameMangler.Mangle(f),
                        DestructorDeclarationNode d => NameMangler.Mangle(d),
                        _ => throw new InvalidOperationException("Invalid vtable entry type")
                    };
                    Builder.AppendInstruction($"dd {mangledName}");
                }
                Builder.AppendBlankLine();
            }
        }
    }

    internal int GetNextLabelId() => _labelIdCounter++;

    private void FindAllStringLiterals(AstNode node)
    {
        if (node is StringLiteralNode str && !_stringLiterals.ContainsValue(str.Value))
        {
            _stringLiterals.Add(str.Label, str.Value);
        }

        foreach (var property in node.GetType().GetProperties())
        {
            if (property.Name == "Parent") continue;

            if (property.GetValue(node) is AstNode child)
            {
                FindAllStringLiterals(child);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children) FindAllStringLiterals(c);
            }
        }
    }
}
</file>

<file path="Generator\DeclarationGenerator.cs">
namespace CTilde;

public class DeclarationGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeRepository TypeRepository => _context.TypeRepository;
    private TypeResolver TypeResolver => _context.TypeResolver;
    private FunctionResolver FunctionResolver => _context.FunctionResolver;
    private VTableManager VTableManager => _context.VTableManager;
    private MemoryLayoutManager MemoryLayoutManager => _context.MemoryLayoutManager;
    private SemanticAnalyzer SemanticAnalyzer => _context.SemanticAnalyzer;
    private StatementGenerator StatementGenerator => _context.StatementGenerator;
    private ExpressionGenerator ExpressionGenerator => _context.ExpressionGenerator;

    public DeclarationGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public void GenerateConstructor(ConstructorDeclarationNode ctor, CompilationUnitNode unit)
    {
        var symbols = new SymbolTable(ctor, TypeResolver, FunctionResolver, MemoryLayoutManager, unit);
        // Create a dummy function node to provide context for analysis, preventing NullReferenceException.
        var dummyFunctionForContext = new FunctionDeclarationNode(
            new Token(TokenType.Keyword, "void"), 0, ctor.OwnerStructName,
            ctor.Parameters, ctor.Body, ctor.OwnerStructName, ctor.AccessLevel,
            false, false, ctor.Namespace
        );
        var context = new AnalysisContext(symbols, unit, dummyFunctionForContext);

        Builder.AppendLabel(NameMangler.Mangle(ctor));
        GeneratePrologue(symbols);

        if (ctor.Initializer != null)
        {
            var ownerStruct = TypeRepository.FindStructByUnqualifiedName(ctor.OwnerStructName, ctor.Namespace) ?? throw new InvalidOperationException("Owner struct not found");

            var argTypes = ctor.Initializer.Arguments
                .Select(arg => SemanticAnalyzer.AnalyzeExpressionType(arg, context))
                .ToList();
            var baseFqn = TypeResolver.ResolveTypeName(ownerStruct.BaseStructName!, ownerStruct.Namespace, unit);
            var baseCtor = FunctionResolver.FindConstructor(baseFqn, argTypes) ?? throw new InvalidOperationException("Base constructor not found for given argument types.");


            int totalArgSize = 0;
            foreach (var arg in ctor.Initializer.Arguments.AsEnumerable().Reverse())
            {
                totalArgSize += ExpressionGenerator.PushArgument(arg, context);
            }

            context.Symbols.TryGetSymbol("this", out var thisOffset, out _, out _);
            Builder.AppendInstruction($"mov eax, [ebp + {thisOffset}]", "Get 'this' pointer");
            Builder.AppendInstruction("push eax", "Push 'this' for base ctor");
            totalArgSize += 4;

            Builder.AppendInstruction($"call {NameMangler.Mangle(baseCtor)}");
            Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up base ctor args");
            Builder.AppendBlankLine();
        }

        StatementGenerator.GenerateStatement(ctor.Body, context);
        GenerateEpilogue(new List<(string, int, string)>());
    }

    public void GenerateDestructor(DestructorDeclarationNode dtor, CompilationUnitNode unit)
    {
        var symbols = new SymbolTable(dtor, TypeResolver, FunctionResolver, MemoryLayoutManager, unit);
        // Create a dummy function node to provide context for analysis.
        var dummyFunctionForContext = new FunctionDeclarationNode(
            new Token(TokenType.Keyword, "void"), 0, dtor.OwnerStructName,
            new List<ParameterNode>(), dtor.Body, dtor.OwnerStructName, dtor.AccessLevel,
            dtor.IsVirtual, false, dtor.Namespace
        );
        var context = new AnalysisContext(symbols, unit, dummyFunctionForContext);

        Builder.AppendLabel(NameMangler.Mangle(dtor));
        GeneratePrologue(symbols);
        StatementGenerator.GenerateStatement(dtor.Body, context);
        GenerateEpilogue(new List<(string, int, string)>());
    }

    public void GenerateFunction(FunctionDeclarationNode function, CompilationUnitNode unit, StructDefinitionNode? owner)
    {
        var tempContext = new AnalysisContext(null, unit, function);
        var returnTypeFqn = SemanticAnalyzer.AnalyzeFunctionReturnType(function, tempContext);
        var returnsStructByValue = TypeRepository.IsStruct(returnTypeFqn) && !returnTypeFqn.EndsWith("*");

        var parametersWithRetPtr = new List<ParameterNode>(function.Parameters);
        if (returnsStructByValue)
        {
            var retPtrParam = new ParameterNode(new Token(TokenType.Keyword, "void"), 1, new Token(TokenType.Identifier, "__ret_ptr"));
            parametersWithRetPtr.Add(retPtrParam);
        }

        var functionForSymbols = function with { Parameters = parametersWithRetPtr };
        var symbols = new SymbolTable(functionForSymbols, TypeResolver, FunctionResolver, MemoryLayoutManager, unit);

        var context = new AnalysisContext(symbols, unit, function);
        var destructibleLocals = symbols.GetDestructibleLocals(FunctionResolver);

        string mangledName = function.Name == "main" ? "_main" : NameMangler.Mangle(function);

        Builder.AppendLabel(mangledName);
        GeneratePrologue(symbols);

        if (function.Body != null) StatementGenerator.GenerateStatement(function.Body, context);

        GenerateEpilogue(destructibleLocals);
    }

    private void GeneratePrologue(SymbolTable symbols)
    {
        Builder.AppendInstruction("push ebp");
        Builder.AppendInstruction("mov ebp, esp");
        Builder.AppendInstruction("push ebx", "Preserve non-volatile registers");
        Builder.AppendInstruction("push esi");
        Builder.AppendInstruction("push edi");
        Builder.AppendBlankLine();

        int totalLocalSize = symbols.TotalLocalSize;
        if (totalLocalSize > 0)
        {
            Builder.AppendInstruction($"sub esp, {totalLocalSize}", "Allocate space for all local variables");
        }
    }

    private void GenerateEpilogue(List<(string Name, int Offset, string TypeFqn)> destructibleLocals)
    {
        if (destructibleLocals.Any())
        {
            Builder.AppendBlankLine();
            Builder.AppendInstruction(null, "Destructor cleanup");
            foreach (var (name, offset, type) in destructibleLocals.AsEnumerable().Reverse())
            {
                var dtor = FunctionResolver.FindDestructor(type);
                if (dtor != null)
                {
                    Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Get address of '{name}' for dtor");
                    Builder.AppendInstruction("push eax");

                    if (dtor.IsVirtual)
                    {
                        // The destructor is always at index 0 in the vtable if virtual
                        Builder.AppendInstruction("mov eax, [eax]", "Get vtable ptr");
                        Builder.AppendInstruction("mov eax, [eax]", "Get dtor from vtable[0]");
                        Builder.AppendInstruction("call eax");
                    }
                    else
                    {
                        Builder.AppendInstruction($"call {NameMangler.Mangle(dtor)}");
                    }
                    Builder.AppendInstruction("add esp, 4", "Clean up 'this'");
                }
            }
        }

        Builder.AppendBlankLine();
        Builder.AppendInstruction("pop edi");
        Builder.AppendInstruction("pop esi");
        Builder.AppendInstruction("pop ebx");
        Builder.AppendInstruction("mov esp, ebp");
        Builder.AppendInstruction("pop ebp");
        Builder.AppendInstruction("ret");
    }
}
</file>

<file path="Generator\ExpressionGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class ExpressionGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeRepository TypeRepository => _context.TypeRepository;
    private TypeResolver TypeResolver => _context.TypeResolver;
    private FunctionResolver FunctionResolver => _context.FunctionResolver;
    private VTableManager VTableManager => _context.VTableManager;
    private MemoryLayoutManager MemoryLayoutManager => _context.MemoryLayoutManager;
    private SemanticAnalyzer SemanticAnalyzer => _context.SemanticAnalyzer;
    private HashSet<string> ExternalFunctions => _context.ExternalFunctions;

    public ExpressionGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public int PushArgument(ExpressionNode arg, AnalysisContext context)
    {
        var argType = SemanticAnalyzer.AnalyzeExpressionType(arg, context);
        GenerateExpression(arg, context); // Result is address (for struct) or value (for primitive) in EAX

        if (TypeRepository.IsStruct(argType) && !argType.EndsWith("*"))
        {
            int argSize = MemoryLayoutManager.GetSizeOfType(argType, context.CompilationUnit);
            for (int offset = argSize - 4; offset >= 0; offset -= 4)
            {
                Builder.AppendInstruction($"push dword [eax + {offset}]");
            }
            return argSize;
        }
        else
        {
            Builder.AppendInstruction("push eax");
            return 4;
        }
    }

    public void GenerateLValueAddress(ExpressionNode expression, AnalysisContext context)
    {
        switch (expression)
        {
            case VariableExpressionNode varExpr: GenerateLValueForVariable(varExpr, context); break;
            case MemberAccessExpressionNode memberAccess: GenerateLValueForMemberAccess(memberAccess, context); break;
            case UnaryExpressionNode u when u.Operator.Type == TokenType.Star: GenerateExpression(u.Right, context); break;
            default: throw new InvalidOperationException($"Expression '{expression.GetType().Name}' is not a valid L-value.");
        }
    }

    private void GenerateLValueForVariable(VariableExpressionNode varExpr, AnalysisContext context)
    {
        if (context.Symbols.TryGetSymbol(varExpr.Identifier.Value, out var offset, out _, out _))
        {
            string sign = offset > 0 ? "+" : "";
            Builder.AppendInstruction($"lea eax, [ebp {sign} {offset}]", $"Get address of var/param {varExpr.Identifier.Value}");
            return;
        }

        if (context.CurrentFunction?.OwnerStructName != null)
        {
            try
            {
                string ownerStructFqn = context.CurrentFunction.Namespace != null ? $"{context.CurrentFunction.Namespace}::{context.CurrentFunction.OwnerStructName}" : context.CurrentFunction.OwnerStructName;
                var (memberOffset, _) = MemoryLayoutManager.GetMemberInfo(ownerStructFqn, varExpr.Identifier.Value, context.CompilationUnit);
                context.Symbols.TryGetSymbol("this", out var thisOffset, out _, out _);
                Builder.AppendInstruction($"mov eax, [ebp + {thisOffset}]", "Get `this` pointer value");
                if (memberOffset > 0) Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for implicit this->{varExpr.Identifier.Value}");
                return;
            }
            catch (InvalidOperationException) { /* Fall through */ }
        }
        throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'.");
    }

    private void GenerateLValueForMemberAccess(MemberAccessExpressionNode memberAccess, AnalysisContext context)
    {
        var leftType = SemanticAnalyzer.AnalyzeExpressionType(memberAccess.Left, context);
        string baseStructType = leftType.TrimEnd('*');
        var (memberOffset, _) = MemoryLayoutManager.GetMemberInfo(baseStructType, memberAccess.Member.Value, context.CompilationUnit);

        if (memberAccess.Operator.Type == TokenType.Dot) GenerateLValueAddress(memberAccess.Left, context);
        else GenerateExpression(memberAccess.Left, context);

        if (memberOffset > 0) Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for member {memberAccess.Operator.Value}{memberAccess.Member.Value}");
    }

    public void GenerateExpression(ExpressionNode expression, AnalysisContext context)
    {
        switch (expression)
        {
            case IntegerLiteralNode literal: GenerateIntegerLiteral(literal); break;
            case StringLiteralNode str: GenerateStringLiteral(str); break;
            case VariableExpressionNode varExpr: GenerateVariableExpression(varExpr, context); break;
            case UnaryExpressionNode u: GenerateUnaryExpression(u, context); break;
            case MemberAccessExpressionNode m: GenerateMemberAccessExpression(m, context); break;
            case AssignmentExpressionNode assign: GenerateAssignmentExpression(assign, context); break;
            case BinaryExpressionNode binExpr: GenerateBinaryExpression(binExpr, context); break;
            case CallExpressionNode callExpr: GenerateCallExpression(callExpr, context); break;
            case QualifiedAccessExpressionNode qNode: GenerateQualifiedAccessExpression(qNode, context); break;
            case NewExpressionNode n: GenerateNewExpression(n, context); break;
            default: throw new NotImplementedException($"Expr: {expression.GetType().Name}");
        }
    }

    private void GenerateNewExpression(NewExpressionNode n, AnalysisContext context)
    {
        var typeFqn = TypeResolver.ResolveTypeName(n.Type.Value, context.CurrentFunction.Namespace, context.CompilationUnit);
        var size = MemoryLayoutManager.GetSizeOfType(typeFqn, context.CompilationUnit);

        Builder.AppendInstruction($"push {size}", "Push size for malloc");
        Builder.AppendInstruction("call [malloc]");
        Builder.AppendInstruction("add esp, 4", "Clean up malloc arg");
        Builder.AppendInstruction("mov edi, eax", "Save new'd pointer in edi");

        var argTypes = n.Arguments.Select(arg => SemanticAnalyzer.AnalyzeExpressionType(arg, context)).ToList();
        var ctor = FunctionResolver.FindConstructor(typeFqn, argTypes) ?? throw new InvalidOperationException($"No matching constructor for 'new {typeFqn}'");

        if (VTableManager.HasVTable(typeFqn))
        {
            var structDef = TypeRepository.FindStruct(typeFqn);
            var vtableLabel = NameMangler.GetVTableLabel(structDef);
            Builder.AppendInstruction($"mov dword [edi], {vtableLabel}", "Set vtable pointer on heap object");
        }

        int totalArgSize = 0;
        foreach (var arg in n.Arguments.AsEnumerable().Reverse())
        {
            totalArgSize += PushArgument(arg, context);
        }

        Builder.AppendInstruction("push edi", "Push 'this' pointer for constructor");
        totalArgSize += 4;

        Builder.AppendInstruction($"call {NameMangler.Mangle(ctor)}");
        Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up ctor args");

        Builder.AppendInstruction("mov eax, edi", "Return pointer to new object in eax");
    }

    private void GenerateIntegerLiteral(IntegerLiteralNode literal) => Builder.AppendInstruction($"mov eax, {literal.Value}");
    private void GenerateStringLiteral(StringLiteralNode str) => Builder.AppendInstruction($"mov eax, {str.Label}");

    private void GenerateVariableExpression(VariableExpressionNode varExpr, AnalysisContext context)
    {
        if (context.Symbols.TryGetSymbol(varExpr.Identifier.Value, out int offset, out string type, out _))
        {
            if (TypeRepository.IsStruct(type) && !type.EndsWith("*")) GenerateLValueAddress(varExpr, context);
            else
            {
                string sign = offset > 0 ? "+" : "";
                string instruction = MemoryLayoutManager.GetSizeOfType(type, context.CompilationUnit) == 1 ? "movzx eax, byte" : "mov eax,";
                Builder.AppendInstruction($"{instruction} [ebp {sign} {offset}]", $"Load value of {varExpr.Identifier.Value}");
            }
            return;
        }

        var enumValue = FunctionResolver.ResolveUnqualifiedEnumMember(varExpr.Identifier.Value, context.CompilationUnit, context.CurrentFunction?.Namespace);
        if (enumValue.HasValue)
        {
            Builder.AppendInstruction($"mov eax, {enumValue.Value}", $"Enum member {varExpr.Identifier.Value}");
            return;
        }

        if (context.CurrentFunction?.OwnerStructName != null)
        {
            var thisMemberAccess = new MemberAccessExpressionNode(new VariableExpressionNode(new Token(TokenType.Identifier, "this")), new Token(TokenType.Arrow, "->"), varExpr.Identifier) { Parent = varExpr.Parent };
            GenerateMemberAccessExpression(thisMemberAccess, context);
            return;
        }
        throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'.");
    }

    private void GenerateUnaryExpression(UnaryExpressionNode u, AnalysisContext context)
    {
        if (u.Operator.Type == TokenType.Ampersand)
        {
            GenerateLValueAddress(u.Right, context);
            return;
        }
        GenerateExpression(u.Right, context);
        switch (u.Operator.Type)
        {
            case TokenType.Minus: Builder.AppendInstruction("neg eax"); break;
            case TokenType.Star:
                var type = SemanticAnalyzer.AnalyzeExpressionType(u, context);
                string instruction = MemoryLayoutManager.GetSizeOfType(type, context.CompilationUnit) == 1 ? "movzx eax, byte [eax]" : "mov eax, [eax]";
                Builder.AppendInstruction(instruction);
                break;
        }
    }

    private void GenerateMemberAccessExpression(MemberAccessExpressionNode m, AnalysisContext context)
    {
        GenerateLValueAddress(m, context);
        var memberType = SemanticAnalyzer.AnalyzeExpressionType(m, context);
        if (TypeRepository.IsStruct(memberType) && !memberType.EndsWith("*")) return;

        string instruction = MemoryLayoutManager.GetSizeOfType(memberType, context.CompilationUnit) == 1 ? "movzx eax, byte [eax]" : "mov eax, [eax]";
        Builder.AppendInstruction(instruction);
    }

    private void GenerateAssignmentExpression(AssignmentExpressionNode assign, AnalysisContext context)
    {
        string lValueType = SemanticAnalyzer.AnalyzeExpressionType(assign.Left, context);
        bool isStructAssign = TypeRepository.IsStruct(lValueType);

        if (isStructAssign)
        {
            GenerateExpression(assign.Right, context);
            Builder.AppendInstruction("push eax", "Push source address");
            GenerateLValueAddress(assign.Left, context);
            Builder.AppendInstruction("mov edi, eax", "Pop destination into EDI");
            Builder.AppendInstruction("pop esi", "Pop source into ESI");
            int size = MemoryLayoutManager.GetSizeOfType(lValueType, context.CompilationUnit);
            Builder.AppendInstruction($"push {size}");
            Builder.AppendInstruction("push esi");
            Builder.AppendInstruction("push edi");
            Builder.AppendInstruction("call [memcpy]");
            Builder.AppendInstruction("add esp, 12");
        }
        else
        {
            GenerateExpression(assign.Right, context);
            Builder.AppendInstruction("push eax", "Push value");
            GenerateLValueAddress(assign.Left, context);
            Builder.AppendInstruction("pop ecx", "Pop value into ECX");
            string instruction = MemoryLayoutManager.GetSizeOfType(lValueType, context.CompilationUnit) == 1 ? "mov [eax], cl" : "mov [eax], ecx";
            Builder.AppendInstruction(instruction, "Assign value");
        }
        if (!isStructAssign) Builder.AppendInstruction("mov eax, ecx");
    }

    private void GenerateCallExpression(CallExpressionNode callExpr, AnalysisContext context)
    {
        int totalArgSize = 0;
        FunctionDeclarationNode func;

        if (callExpr.Callee is MemberAccessExpressionNode memberAccess)
        {
            var ownerTypeName = SemanticAnalyzer.AnalyzeExpressionType(memberAccess.Left, context).TrimEnd('*');
            var ownerStruct = TypeRepository.FindStruct(ownerTypeName) ?? throw new InvalidOperationException($"Could not find struct definition for '{ownerTypeName}'.");
            func = FunctionResolver.ResolveMethod(ownerStruct, memberAccess.Member.Value);
        }
        else
        {
            func = FunctionResolver.ResolveFunctionCall(callExpr.Callee, context.CompilationUnit, context.CurrentFunction);
        }

        var returnType = SemanticAnalyzer.AnalyzeFunctionReturnType(func, context);
        bool returnsStructByValue = TypeRepository.IsStruct(returnType) && !returnType.EndsWith("*");

        if (returnsStructByValue)
        {
            var size = MemoryLayoutManager.GetSizeOfType(returnType, context.CompilationUnit);
            Builder.AppendInstruction($"sub esp, {size}", "Make space for return value");
            Builder.AppendInstruction("push esp", "Push hidden return value pointer");
            totalArgSize += 4;
        }

        foreach (var arg in callExpr.Arguments.AsEnumerable().Reverse())
        {
            totalArgSize += PushArgument(arg, context);
        }

        if (callExpr.Callee is MemberAccessExpressionNode ma)
        {
            if (ma.Operator.Type == TokenType.Arrow) GenerateExpression(ma.Left, context);
            else GenerateLValueAddress(ma.Left, context);

            Builder.AppendInstruction("push eax", "Push 'this' pointer");
            totalArgSize += 4;

            if (func.IsVirtual || func.IsOverride)
            {
                var ownerTypeFqn = SemanticAnalyzer.AnalyzeExpressionType(ma.Left, context).TrimEnd('*');
                var vtableIndex = VTableManager.GetMethodVTableIndex(ownerTypeFqn, func.Name);
                int thisPtrOffset = totalArgSize - 4; // 'this' is the last thing pushed before call
                Builder.AppendInstruction($"mov eax, [esp + {thisPtrOffset}]", "Get 'this' from stack");
                Builder.AppendInstruction("mov eax, [eax]", "Get vtable pointer from object");
                Builder.AppendInstruction($"mov eax, [eax + {vtableIndex * 4}]", $"Get method address from vtable[{vtableIndex}]");
                Builder.AppendInstruction("call eax");
            }
            else { Builder.AppendInstruction($"call {NameMangler.Mangle(func)}"); }
        }
        else
        {
            string calleeTarget = func.Body == null ? $"[{func.Name}]" : NameMangler.Mangle(func);
            if (func.Body == null) ExternalFunctions.Add(func.Name);
            Builder.AppendInstruction($"call {calleeTarget}");
        }

        Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up args");

        if (returnsStructByValue)
        {
            Builder.AppendInstruction("lea eax, [esp]", "Get address of hidden return temporary");
        }
    }

    private void GenerateBinaryExpression(BinaryExpressionNode binExpr, AnalysisContext context)
    {
        var leftTypeFqn = SemanticAnalyzer.AnalyzeExpressionType(binExpr.Left, context);

        if (TypeRepository.IsStruct(leftTypeFqn))
        {
            var opName = $"operator_{NameMangler.MangleOperator(binExpr.Operator.Value)}";
            var overload = FunctionResolver.FindMethod(leftTypeFqn.TrimEnd('*'), opName) ?? throw new InvalidOperationException($"Internal compiler error: overload for '{opName}' not found.");

            var returnType = SemanticAnalyzer.AnalyzeFunctionReturnType(overload, context);
            bool returnsStructByValue = TypeRepository.IsStruct(returnType) && !returnType.EndsWith("*");
            int totalArgSize = 0;

            if (returnsStructByValue)
            {
                var size = MemoryLayoutManager.GetSizeOfType(returnType, context.CompilationUnit);
                Builder.AppendInstruction($"sub esp, {size}", "Make space for op+ return value");
                Builder.AppendInstruction("push esp", "Push hidden return value pointer");
                totalArgSize += 4;
            }

            totalArgSize += PushArgument(binExpr.Right, context);

            GenerateLValueAddress(binExpr.Left, context);
            Builder.AppendInstruction("push eax", "Push 'this' pointer");
            totalArgSize += 4;

            Builder.AppendInstruction($"call {NameMangler.Mangle(overload)}");
            Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up op+ args");

            if (returnsStructByValue)
            {
                Builder.AppendInstruction("lea eax, [esp]", "Get address of hidden return temporary");
            }
        }
        else
        {
            GenerateExpression(binExpr.Left, context);
            Builder.AppendInstruction("push eax");
            GenerateExpression(binExpr.Right, context);
            Builder.AppendInstruction("mov ecx, eax");
            Builder.AppendInstruction("pop eax");

            switch (binExpr.Operator.Type)
            {
                case TokenType.Plus: Builder.AppendInstruction("add eax, ecx"); break;
                case TokenType.Minus: Builder.AppendInstruction("sub eax, ecx"); break;
                case TokenType.Star: Builder.AppendInstruction("imul eax, ecx"); break;
                case TokenType.Slash: Builder.AppendInstruction("cdq"); Builder.AppendInstruction("idiv ecx"); break;
                case TokenType.DoubleEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("sete al"); Builder.AppendInstruction("movzx eax, al"); break;
                case TokenType.NotEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setne al"); Builder.AppendInstruction("movzx eax, al"); break;
                case TokenType.LessThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setl al"); Builder.AppendInstruction("movzx eax, al"); break;
                case TokenType.GreaterThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setg al"); Builder.AppendInstruction("movzx eax, al"); break;
                default: throw new NotImplementedException($"Op: {binExpr.Operator.Type}");
            }
        }
    }

    private void GenerateQualifiedAccessExpression(QualifiedAccessExpressionNode qNode, AnalysisContext context)
    {
        string potentialEnumTypeName = TypeResolver.ResolveQualifier(qNode.Left);
        string memberName = qNode.Member.Value;
        string? enumTypeFQN = TypeResolver.ResolveEnumTypeName(potentialEnumTypeName, context.CurrentFunction?.Namespace, context.CompilationUnit);
        if (enumTypeFQN != null)
        {
            var enumValue = FunctionResolver.GetEnumValue(enumTypeFQN, memberName);
            if (enumValue.HasValue)
            {
                Builder.AppendInstruction($"mov eax, {enumValue.Value}", $"Enum member {potentialEnumTypeName}::{memberName}");
                return;
            }
        }

        var func = FunctionResolver.ResolveFunctionCall(qNode, context.CompilationUnit, context.CurrentFunction);
        string calleeTarget = func.Body == null ? $"[{func.Name}]" : NameMangler.Mangle(func);
        if (func.Body == null) ExternalFunctions.Add(func.Name);
        Builder.AppendInstruction($"mov eax, {calleeTarget}");
    }
}
</file>

<file path="Generator\FasmWriter.cs">
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CTilde;

public class FasmWriter
{
    public void WritePreamble(AssemblyBuilder builder)
    {
        builder.AppendDirective("format PE GUI 4.0");
        builder.AppendDirective("entry start");
        builder.AppendBlankLine();
        builder.AppendDirective("include 'win32a.inc'");
        builder.AppendBlankLine();
    }

    public void WriteDataSection(AssemblyBuilder builder, Dictionary<string, string> stringLiterals)
    {
        builder.AppendDirective("section '.data' data readable writeable");
        foreach (var (label, value) in stringLiterals)
        {
            builder.AppendData(label, FormatStringForFasm(value));
        }
        builder.AppendBlankLine();
    }

    public void WriteTextSectionHeader(AssemblyBuilder builder)
    {
        builder.AppendDirective("section '.text' code readable executable");
        builder.AppendBlankLine();
    }

    public void WriteEntryPoint(AssemblyBuilder builder)
    {
        builder.AppendLabel("start");
        builder.AppendInstruction("call _main");
        builder.AppendInstruction("mov ebx, eax");
        builder.AppendInstruction("push ebx");
        builder.AppendInstruction("call [ExitProcess]");
        builder.AppendBlankLine();
    }

    public void WriteImportDataSection(AssemblyBuilder builder, ProgramNode program, IEnumerable<string> externalFunctions)
    {
        builder.AppendDirective("section '.idata' import data readable");
        builder.AppendBlankLine();

        var libraries = new Dictionary<string, HashSet<string>>
        {
            { "kernel32.dll", new HashSet<string> { "ExitProcess" } },
            { "msvcrt.dll", new HashSet<string> { "printf", "malloc", "free", "strlen", "strcpy", "memcpy" } }
        };

        // Register all libraries from #import directives
        foreach (var import in program.Imports)
        {
            if (!libraries.ContainsKey(import.LibraryName))
            {
                libraries[import.LibraryName] = new HashSet<string>();
            }
        }

        // Get all functions that are already assigned to a default library
        var claimedFunctions = new HashSet<string>(libraries.SelectMany(kvp => kvp.Value));

        // Distribute all other external functions among the imported libraries
        foreach (var funcName in externalFunctions.Except(claimedFunctions))
        {
            // Assign the function to the first non-standard DLL found in the #import list.
            var ownerLib = program.Imports
                .Select(i => i.LibraryName)
                .FirstOrDefault(lib => lib != "kernel32.dll" && lib != "msvcrt.dll");

            if (ownerLib != null)
            {
                libraries[ownerLib].Add(funcName);
            }
            else // Fallback for functions if only standard libs are imported (e.g. user32 functions)
            {
                if (!libraries.ContainsKey("user32.dll")) libraries["user32.dll"] = new HashSet<string>();
                libraries["user32.dll"].Add(funcName);
            }
        }

        // Filter out libraries that have no functions to import
        var finalLibraries = libraries
            .Where(kvp => kvp.Value.Any())
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList());

        if (!finalLibraries.Any()) return;

        var libDefs = finalLibraries.Keys.OrderBy(k => k).Select(lib => $"{lib.Split('.')[0]},'{lib}'");
        builder.AppendDirective($"    library {string.Join(", ", libDefs)}");
        builder.AppendBlankLine();

        foreach (var (libName, functions) in finalLibraries.OrderBy(kvp => kvp.Key))
        {
            var libAlias = libName.Split('.')[0];
            functions.Sort();
            var importDefs = functions.Select(f => $"{f},'{f}'");
            builder.AppendDirective($"    import {libAlias}, {string.Join(", ", importDefs)}");
        }
    }

    private string FormatStringForFasm(string value)
    {
        var parts = new List<string>();
        var currentString = new StringBuilder();

        foreach (char c in value)
        {
            if (c is '\n' or '\t' or '\r' or '\'' or '"')
            {
                if (currentString.Length > 0)
                {
                    parts.Add($"'{currentString}'");
                    currentString.Clear();
                }
                parts.Add(((byte)c).ToString());
            }
            else currentString.Append(c);
        }

        if (currentString.Length > 0) parts.Add($"'{currentString}'");
        parts.Add("0");
        return string.Join(", ", parts);
    }
}
</file>

<file path="Generator\MemoryLayoutManager.cs">
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class MemoryLayoutManager
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;
    private readonly VTableManager _vtableManager;

    public MemoryLayoutManager(TypeRepository typeRepository, TypeResolver typeResolver, VTableManager vtableManager)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
        _vtableManager = vtableManager;
    }

    public int GetSizeOfType(string typeNameFqn, CompilationUnitNode context)
    {
        if (typeNameFqn.EndsWith("*")) return 4;
        if (typeNameFqn == "int") return 4;
        if (typeNameFqn == "char") return 1;

        if (_typeRepository.FindStruct(typeNameFqn) is { } structDef)
        {
            int size = 0;
            var structUnit = _typeRepository.GetCompilationUnitForStruct(typeNameFqn);
            if (structDef.BaseStructName != null)
            {
                string baseFqn = _typeResolver.ResolveTypeName(structDef.BaseStructName, structDef.Namespace, structUnit);
                var baseUnit = _typeRepository.GetCompilationUnitForStruct(baseFqn);
                size += GetSizeOfType(baseFqn, baseUnit);
            }
            else if (_vtableManager.HasVTable(typeNameFqn))
            {
                size += 4; // vtable pointer
            }

            foreach (var member in structDef.Members)
            {
                var rawMemberType = TypeRepository.GetTypeNameFromToken(member.Type, member.PointerLevel);
                string baseMemberName = rawMemberType.TrimEnd('*');
                string pointerSuffix = new string('*', rawMemberType.Length - baseMemberName.Length);

                string resolvedMemberType = (member.Type.Type == TokenType.Keyword || baseMemberName.Equals("void"))
                    ? rawMemberType
                    : _typeResolver.ResolveTypeName(baseMemberName, structDef.Namespace, structUnit) + pointerSuffix;

                var memberUnit = _typeRepository.IsStruct(resolvedMemberType)
                    ? _typeRepository.GetCompilationUnitForStruct(resolvedMemberType.TrimEnd('*'))
                    : structUnit;
                size += GetSizeOfType(resolvedMemberType, memberUnit);
            }
            return size;
        }
        throw new System.InvalidOperationException($"Unknown type '{typeNameFqn}' for size calculation.");
    }

    public (int offset, string type) GetMemberInfo(string structName, string memberName, CompilationUnitNode context)
    {
        var member = GetAllMembers(structName, context).FirstOrDefault(m => m.name == memberName);
        if (member == default) throw new System.InvalidOperationException($"Struct '{structName}' has no member '{memberName}'");
        return (member.offset, member.type);
    }

    public List<(string name, string type, int offset, bool isConst)> GetAllMembers(string structFqn, CompilationUnitNode context)
    {
        if (_typeRepository.FindStruct(structFqn) is not { } structDef) throw new System.InvalidOperationException($"Struct '{structFqn}' not found.");

        var allMembers = new List<(string, string, int, bool)>();
        int currentOffset = 0;

        if (structDef.BaseStructName != null)
        {
            var structUnit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            string baseFqn = _typeResolver.ResolveTypeName(structDef.BaseStructName, structDef.Namespace, structUnit);
            var baseUnit = _typeRepository.GetCompilationUnitForStruct(baseFqn);
            allMembers.AddRange(GetAllMembers(baseFqn, baseUnit));
            currentOffset = GetSizeOfType(baseFqn, baseUnit);
        }
        else if (_vtableManager.HasVTable(structFqn))
        {
            currentOffset = 4; // vtable pointer
        }

        foreach (var mem in structDef.Members)
        {
            var ownUnit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            var rawMemberType = TypeRepository.GetTypeNameFromToken(mem.Type, mem.PointerLevel);
            var baseMemberName = rawMemberType.TrimEnd('*');
            var pointerSuffix = new string('*', rawMemberType.Length - baseMemberName.Length);
            var resolvedMemberType = (mem.Type.Type == TokenType.Keyword || baseMemberName.Equals("void"))
                ? rawMemberType
                : _typeResolver.ResolveTypeName(baseMemberName, structDef.Namespace, ownUnit) + pointerSuffix;

            allMembers.Add((mem.Name.Value, resolvedMemberType, currentOffset, mem.IsConst));

            var memberUnit = _typeRepository.IsStruct(resolvedMemberType)
                ? _typeRepository.GetCompilationUnitForStruct(resolvedMemberType.TrimEnd('*'))
                : ownUnit;
            currentOffset += GetSizeOfType(resolvedMemberType, memberUnit);
        }
        return allMembers;
    }
}
</file>

<file path="Generator\NameMangler.cs">
namespace CTilde;

public static class NameMangler
{
    public static string Mangle(FunctionDeclarationNode f)
    {
        return MangleName(f.Namespace, f.OwnerStructName, f.Name);
    }

    private static string MangleType(Token type, int pointerLevel)
    {
        var typeName = type.Value;
        string mangled;
        if (type.Type == TokenType.Keyword)
        {
            mangled = typeName[0].ToString();
        }
        else // Identifier, could be qualified
        {
            var cleanName = typeName.Replace("::", "_");
            mangled = $"{cleanName.Length}{cleanName}";
        }

        for (int i = 0; i < pointerLevel; i++)
        {
            mangled = "p" + mangled;
        }
        return mangled;
    }

    public static string Mangle(ConstructorDeclarationNode c)
    {
        var paramSignature = string.Concat(c.Parameters.Select(p => MangleType(p.Type, p.PointerLevel)));
        return MangleName(c.Namespace, c.OwnerStructName, $"{c.OwnerStructName}_ctor_{paramSignature}");
    }

    public static string Mangle(DestructorDeclarationNode d)
    {
        return MangleName(d.Namespace, d.OwnerStructName, $"{d.OwnerStructName}_dtor");
    }

    public static string GetVTableLabel(StructDefinitionNode s)
    {
        return $"_vtable_{s.Namespace?.Replace("::", "_")}_{s.Name}".Replace("__", "_");
    }

    public static string MangleOperator(string op)
    {
        return op switch
        {
            "+" => "plus",
            _ => throw new System.NotImplementedException($"Operator mangling for '{op}' is not implemented.")
        };
    }

    private static string MangleName(string? ns, string? owner, string name)
    {
        var parts = new List<string?> { ns, owner, name }
            .Where(p => !string.IsNullOrEmpty(p))
            .Select(p => p!.Replace("::", "_"));

        return $"_{string.Join("_", parts)}";
    }
}
</file>

<file path="Generator\StatementGenerator.cs">
using System;
using System.Linq;

namespace CTilde;

public class StatementGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeRepository TypeRepository => _context.TypeRepository;
    private FunctionResolver FunctionResolver => _context.FunctionResolver;
    private MemoryLayoutManager MemoryLayoutManager => _context.MemoryLayoutManager;
    private ExpressionGenerator ExpressionGenerator => _context.ExpressionGenerator;

    public StatementGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public void GenerateStatement(StatementNode statement, AnalysisContext context)
    {
        switch (statement)
        {
            case ReturnStatementNode ret: GenerateReturn(ret, context); break;
            case BlockStatementNode block: foreach (var s in block.Statements) GenerateStatement(s, context); break;
            case WhileStatementNode w: GenerateWhile(w, context); break;
            case IfStatementNode i: GenerateIf(i, context); break;
            case DeleteStatementNode d: GenerateDelete(d, context); break;
            case DeclarationStatementNode decl:
                GenerateDeclaration(decl, context);
                break;
            case ExpressionStatementNode exprStmt:
                ExpressionGenerator.GenerateExpression(exprStmt.Expression, context);
                // Check if the expression statement was a function call that returned a temporary struct
                var exprType = _context.SemanticAnalyzer.AnalyzeExpressionType(exprStmt.Expression, context);
                if (_context.TypeRepository.IsStruct(exprType) && !exprType.EndsWith("*"))
                {
                    if (exprStmt.Expression is CallExpressionNode or BinaryExpressionNode)
                    {
                        // The temporary is on the stack but its value is unused. We must destroy it.
                        var tempDtor = FunctionResolver.FindDestructor(exprType);
                        if (tempDtor != null)
                        {
                            Builder.AppendInstruction(null, "Destroying temporary from expression statement");
                            Builder.AppendInstruction("lea eax, [esp]"); // Address of temporary is at ESP
                            Builder.AppendInstruction("push eax"); // Push 'this'
                            if (tempDtor.IsVirtual)
                            {
                                Builder.AppendInstruction("mov eax, [eax]", "Get vtable ptr");
                                Builder.AppendInstruction("mov eax, [eax]", "Get dtor from vtable[0]");
                                Builder.AppendInstruction("call eax");
                            }
                            else
                            {
                                Builder.AppendInstruction($"call {NameMangler.Mangle(tempDtor)}");
                            }
                            Builder.AppendInstruction("add esp, 4"); // Clean up 'this'
                        }
                        var size = MemoryLayoutManager.GetSizeOfType(exprType, context.CompilationUnit);
                        Builder.AppendInstruction($"add esp, {size}", "Clean up temporary return object from stack");
                    }
                }
                break;
            default: throw new NotImplementedException($"Stmt: {statement.GetType().Name}");
        }
    }

    private void GenerateDelete(DeleteStatementNode deleteNode, AnalysisContext context)
    {
        ExpressionGenerator.GenerateExpression(deleteNode.Expression, context);
        Builder.AppendInstruction("mov edi, eax", "Save pointer to be deleted in edi");
        Builder.AppendInstruction("push edi", "Push 'this' pointer for destructor call");

        var pointerType = _context.SemanticAnalyzer.AnalyzeExpressionType(deleteNode.Expression, context);
        var objectType = pointerType.TrimEnd('*');
        var dtor = FunctionResolver.FindDestructor(objectType);

        if (dtor != null)
        {
            if (dtor.IsVirtual)
            {
                Builder.AppendInstruction("mov eax, [edi]", "Get vtable pointer from object");
                Builder.AppendInstruction("mov eax, [eax]", "Get destructor from vtable[0]");
                Builder.AppendInstruction("call eax");
            }
            else
            {
                Builder.AppendInstruction($"call {NameMangler.Mangle(dtor)}");
            }
        }

        Builder.AppendInstruction("add esp, 4", "Clean up 'this' from dtor call");
        Builder.AppendInstruction("push edi", "Push pointer for free()");
        Builder.AppendInstruction("call [free]");
        Builder.AppendInstruction("add esp, 4", "Clean up pointer from free() call");
    }

    private void GenerateDeclaration(DeclarationStatementNode decl, AnalysisContext context)
    {
        var variableName = decl.Identifier.Value;
        var varTypeFqn = context.Symbols.GetSymbolType(variableName);
        context.Symbols.TryGetSymbol(variableName, out var offset, out _, out _);

        if (TypeRepository.IsStruct(varTypeFqn))
        {
            var structDef = TypeRepository.FindStruct(varTypeFqn);
            if (_context.VTableManager.HasVTable(varTypeFqn))
            {
                var vtableLabel = NameMangler.GetVTableLabel(structDef);
                Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Get address of object '{variableName}'");
                Builder.AppendInstruction($"mov dword [eax], {vtableLabel}", "Set vtable pointer");
            }

            if (decl.ConstructorArguments != null) // e.g. string s("hello");
            {
                var argTypes = decl.ConstructorArguments
                    .Select(arg => _context.SemanticAnalyzer.AnalyzeExpressionType(arg, context))
                    .ToList();
                var ctor = FunctionResolver.FindConstructor(varTypeFqn, argTypes) ?? throw new InvalidOperationException($"No constructor found for '{varTypeFqn}' matching signature.");

                int totalArgSize = 0;
                foreach (var arg in decl.ConstructorArguments.AsEnumerable().Reverse())
                {
                    totalArgSize += ExpressionGenerator.PushArgument(arg, context);
                }

                Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Push 'this' for constructor");
                Builder.AppendInstruction("push eax");
                totalArgSize += 4;

                Builder.AppendInstruction($"call {NameMangler.Mangle(ctor)}");
                Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up ctor args");
            }
            else if (decl.Initializer != null)
            {
                if (decl.Initializer is InitializerListExpressionNode initList) // e.g. MyStruct s = {1, 2};
                {
                    var allMembers = MemoryLayoutManager.GetAllMembers(varTypeFqn, context.CompilationUnit);
                    if (initList.Values.Count > allMembers.Count) throw new InvalidOperationException($"Too many values in initializer list for struct '{varTypeFqn}'.");

                    for (int j = 0; j < initList.Values.Count; j++)
                    {
                        var (memberName, memberType, memberOffset, _) = allMembers[j];
                        var valueExpr = initList.Values[j];
                        var memberSize = MemoryLayoutManager.GetSizeOfType(memberType, context.CompilationUnit);
                        var totalOffset = offset + memberOffset;

                        ExpressionGenerator.GenerateExpression(valueExpr, context);
                        if (memberSize == 1) Builder.AppendInstruction($"mov byte [ebp + {totalOffset}], al", $"Init member {memberName}");
                        else Builder.AppendInstruction($"mov dword [ebp + {totalOffset}], eax", $"Init member {memberName}");
                    }
                }
                else // e.g. string s = "hello"; or string s = other_s; (Implicit constructor call)
                {
                    string initializerType = _context.SemanticAnalyzer.AnalyzeExpressionType(decl.Initializer, context);
                    var ctor = FunctionResolver.FindConstructor(varTypeFqn, new List<string> { initializerType });

                    bool takeAddressOfInitializer = false;
                    if (ctor == null && TypeRepository.IsStruct(initializerType))
                    {
                        // Try to find a copy constructor that takes a pointer, e.g. string(string*)
                        ctor = FunctionResolver.FindConstructor(varTypeFqn, new List<string> { initializerType + "*" });
                        if (ctor != null)
                        {
                            takeAddressOfInitializer = true;
                        }
                    }

                    if (ctor == null)
                    {
                        throw new InvalidOperationException($"No constructor found for '{varTypeFqn}' that takes an argument of type '{initializerType}'.");
                    }

                    int totalArgSize;
                    if (takeAddressOfInitializer)
                    {
                        // We need the address of the initializer object. `GenerateExpression` on a struct-type expression gives its address.
                        ExpressionGenerator.GenerateExpression(decl.Initializer, context);
                        Builder.AppendInstruction("push eax", "Push pointer to initializer object for copy ctor");
                        totalArgSize = 4;
                    }
                    else
                    {
                        // The constructor takes the initializer by value (either a primitive/pointer, or a struct).
                        // PushArgument handles both cases correctly (pushing value, or member-wise copy).
                        totalArgSize = ExpressionGenerator.PushArgument(decl.Initializer, context);
                    }

                    Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Push 'this' for constructor");
                    Builder.AppendInstruction("push eax");
                    totalArgSize += 4;

                    Builder.AppendInstruction($"call {NameMangler.Mangle(ctor)}");
                    Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up ctor args");

                    // CRITICAL FIX: If the initializer created a temporary, it's still on the stack. Destroy it.
                    if (decl.Initializer is CallExpressionNode or BinaryExpressionNode &&
                        _context.TypeRepository.IsStruct(initializerType) && !initializerType.EndsWith("*"))
                    {
                        var tempDtor = FunctionResolver.FindDestructor(initializerType);
                        if (tempDtor != null)
                        {
                            Builder.AppendInstruction(null, "Destroying temporary from initialization");
                            Builder.AppendInstruction("lea eax, [esp]"); // Address of temporary is now at ESP
                            Builder.AppendInstruction("push eax"); // Push 'this'
                            if (tempDtor.IsVirtual)
                            {
                                Builder.AppendInstruction("mov eax, [eax]", "Get vtable ptr");
                                Builder.AppendInstruction("mov eax, [eax]", "Get dtor from vtable[0]");
                                Builder.AppendInstruction("call eax");
                            }
                            else
                            {
                                Builder.AppendInstruction($"call {NameMangler.Mangle(tempDtor)}");
                            }
                            Builder.AppendInstruction("add esp, 4"); // Clean up 'this'
                        }
                        var size = MemoryLayoutManager.GetSizeOfType(initializerType, context.CompilationUnit);
                        Builder.AppendInstruction($"add esp, {size}", "Clean up temporary return object from stack");
                    }
                }
            }
        }
        else if (decl.Initializer != null) // Primitive types
        {
            ExpressionGenerator.GenerateExpression(decl.Initializer, context);
            if (MemoryLayoutManager.GetSizeOfType(varTypeFqn, context.CompilationUnit) == 1)
                Builder.AppendInstruction($"mov byte [ebp + {offset}], al", $"Initialize {variableName}");
            else
                Builder.AppendInstruction($"mov dword [ebp + {offset}], eax", $"Initialize {variableName}");
        }
    }

    private void GenerateReturn(ReturnStatementNode ret, AnalysisContext context)
    {
        var returnTypeFqn = _context.SemanticAnalyzer.AnalyzeFunctionReturnType(context.CurrentFunction, context);
        if (TypeRepository.IsStruct(returnTypeFqn) && !returnTypeFqn.EndsWith("*"))
        {
            if (ret.Expression == null) throw new InvalidOperationException("Must return a value from a function with a struct return type.");

            // Get the address of the local object being returned (e.g. &result)
            ExpressionGenerator.GenerateExpression(ret.Expression, context);
            Builder.AppendInstruction("mov esi, eax", "Source address for return value");

            // Get the hidden pointer to the destination (passed by the caller)
            context.Symbols.TryGetSymbol("__ret_ptr", out var retPtrOffset, out _, out _);
            Builder.AppendInstruction($"mov edi, [ebp + {retPtrOffset}]", "Destination address for return value");

            // Find a copy constructor, e.g. string(string*)
            var copyCtor = FunctionResolver.FindConstructor(returnTypeFqn, new List<string> { returnTypeFqn + "*" });

            if (copyCtor != null)
            {
                Builder.AppendInstruction(null, "Calling copy constructor for return value");
                Builder.AppendInstruction("push esi", "Push source pointer argument");
                Builder.AppendInstruction("push edi", "Push destination pointer as 'this'");
                Builder.AppendInstruction($"call {NameMangler.Mangle(copyCtor)}");
                Builder.AppendInstruction("add esp, 8", "Clean up copy ctor args");
            }
            else
            {
                // Fallback to memcpy for POD structs without a copy constructor
                var size = MemoryLayoutManager.GetSizeOfType(returnTypeFqn, context.CompilationUnit);
                Builder.AppendInstruction($"push {size}");
                Builder.AppendInstruction("push esi");
                Builder.AppendInstruction("push edi");
                Builder.AppendInstruction("call [memcpy]");
                Builder.AppendInstruction("add esp, 12");
            }
        }
        else
        {
            // Handle return for primitive types
            if (ret.Expression != null) ExpressionGenerator.GenerateExpression(ret.Expression, context);
        }

        // The actual `ret` instruction is in the epilogue to ensure destructors are called.
    }

    private void GenerateWhile(WhileStatementNode w, AnalysisContext context)
    {
        int i = _context.GetNextLabelId();
        Builder.AppendLabel($"_while_start_{i}");
        ExpressionGenerator.GenerateExpression(w.Condition, context);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction($"je _while_end_{i}");
        GenerateStatement(w.Body, context);
        Builder.AppendInstruction($"jmp _while_start_{i}");
        Builder.AppendLabel($"_while_end_{i}");
    }

    private void GenerateIf(IfStatementNode i, AnalysisContext context)
    {
        int idx = _context.GetNextLabelId();
        ExpressionGenerator.GenerateExpression(i.Condition, context);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction(i.ElseBody != null ? $"je _if_else_{idx}" : $"je _if_end_{idx}");
        GenerateStatement(i.ThenBody, context);
        if (i.ElseBody != null)
        {
            Builder.AppendInstruction($"jmp _if_end_{idx}");
            Builder.AppendLabel($"_if_else_{idx}");
            GenerateStatement(i.ElseBody, context);
        }
        Builder.AppendLabel($"_if_end_{idx}");
    }
}
</file>

<file path="Generator\SymbolTable.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class SymbolTable
{
    private readonly Dictionary<string, (int Offset, string Type, bool IsConst)> _symbols = new();
    public int TotalLocalSize { get; private set; }

    // Constructor for Functions/Methods
    public SymbolTable(FunctionDeclarationNode function, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager, CompilationUnitNode currentUnit)
    {
        var allLocalDeclarations = new List<DeclarationStatementNode>();
        CollectDeclarations(function.Body, allLocalDeclarations);
        Initialize(function.Parameters, allLocalDeclarations, typeResolver, memoryLayoutManager, function.Namespace, currentUnit);
    }

    // Constructor for Constructors
    public SymbolTable(ConstructorDeclarationNode ctor, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager, CompilationUnitNode currentUnit)
    {
        var allLocalDeclarations = new List<DeclarationStatementNode>();
        CollectDeclarations(ctor.Body, allLocalDeclarations);

        var thisTypeName = ctor.Namespace != null ? $"{ctor.Namespace}::{ctor.OwnerStructName}" : ctor.OwnerStructName;
        var thisParam = new ParameterNode(new Token(TokenType.Identifier, thisTypeName), 1, new Token(TokenType.Identifier, "this"));

        var allParams = new List<ParameterNode> { thisParam };
        allParams.AddRange(ctor.Parameters);
        Initialize(allParams, allLocalDeclarations, typeResolver, memoryLayoutManager, ctor.Namespace, currentUnit);
    }

    // Constructor for Destructors
    public SymbolTable(DestructorDeclarationNode dtor, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager, CompilationUnitNode currentUnit)
    {
        var allLocalDeclarations = new List<DeclarationStatementNode>();
        CollectDeclarations(dtor.Body, allLocalDeclarations);

        var thisTypeName = dtor.Namespace != null ? $"{dtor.Namespace}::{dtor.OwnerStructName}" : dtor.OwnerStructName;
        var thisParam = new ParameterNode(new Token(TokenType.Identifier, thisTypeName), 1, new Token(TokenType.Identifier, "this"));

        Initialize(new List<ParameterNode> { thisParam }, allLocalDeclarations, typeResolver, memoryLayoutManager, dtor.Namespace, currentUnit);
    }

    private void Initialize(List<ParameterNode> parameters, List<DeclarationStatementNode> localDeclarations, TypeResolver typeResolver, MemoryLayoutManager memoryLayoutManager, string? currentNamespace, CompilationUnitNode currentUnit)
    {
        TotalLocalSize = 0;
        foreach (var d in localDeclarations)
        {
            var rawTypeName = TypeRepository.GetTypeNameFromToken(d.Type, d.PointerLevel);
            var baseTypeName = rawTypeName.TrimEnd('*');
            var pointerSuffix = new string('*', rawTypeName.Length - baseTypeName.Length);
            var resolvedTypeName = d.Type.Type == TokenType.Keyword || baseTypeName.Equals("void", StringComparison.OrdinalIgnoreCase)
                ? rawTypeName
                : typeResolver.ResolveTypeName(baseTypeName, currentNamespace, currentUnit) + pointerSuffix;
            TotalLocalSize += memoryLayoutManager.GetSizeOfType(resolvedTypeName, currentUnit);
        }

        int currentParamOffset = 8; // EBP + 8 is first parameter
        foreach (var param in parameters)
        {
            var rawTypeName = TypeRepository.GetTypeNameFromToken(param.Type, param.PointerLevel);
            var baseTypeName = rawTypeName.TrimEnd('*');
            var pointerSuffix = new string('*', rawTypeName.Length - baseTypeName.Length);
            string resolvedTypeName;

            if (param.Type.Type == TokenType.Keyword || baseTypeName.Equals("void", StringComparison.OrdinalIgnoreCase))
            {
                resolvedTypeName = rawTypeName;
            }
            else if (param.Type.Value.Contains("::"))
            {
                // This correctly handles the pre-qualified 'this' parameter type.
                resolvedTypeName = rawTypeName;
            }
            else
            {
                resolvedTypeName = typeResolver.ResolveTypeName(baseTypeName, currentNamespace, currentUnit) + pointerSuffix;
            }

            _symbols[param.Name.Value] = (currentParamOffset, resolvedTypeName, false);
            currentParamOffset += Math.Max(4, memoryLayoutManager.GetSizeOfType(resolvedTypeName, currentUnit));
        }

        int currentLocalOffset = 0;
        foreach (var decl in localDeclarations)
        {
            var rawTypeName = TypeRepository.GetTypeNameFromToken(decl.Type, decl.PointerLevel);
            var baseTypeName = rawTypeName.TrimEnd('*');
            var pointerSuffix = new string('*', rawTypeName.Length - baseTypeName.Length);
            var resolvedTypeName = decl.Type.Type == TokenType.Keyword || baseTypeName.Equals("void", StringComparison.OrdinalIgnoreCase)
                ? rawTypeName
                : typeResolver.ResolveTypeName(baseTypeName, currentNamespace, currentUnit) + pointerSuffix;

            int size = memoryLayoutManager.GetSizeOfType(resolvedTypeName, currentUnit);
            currentLocalOffset -= size;
            _symbols[decl.Identifier.Value] = (currentLocalOffset, resolvedTypeName, decl.IsConst);
        }
    }



    private void CollectDeclarations(AstNode? node, List<DeclarationStatementNode> declarations)
    {
        if (node == null) return;
        if (node is DeclarationStatementNode decl) declarations.Add(decl);
        else if (node is BlockStatementNode block) foreach (var stmt in block.Statements) CollectDeclarations(stmt, declarations);
        else if (node is IfStatementNode ifStmt) { CollectDeclarations(ifStmt.ThenBody, declarations); CollectDeclarations(ifStmt.ElseBody, declarations); }
        else if (node is WhileStatementNode whileStmt) CollectDeclarations(whileStmt.Body, declarations);
    }

    public List<(string Name, int Offset, string TypeFqn)> GetDestructibleLocals(FunctionResolver functionResolver)
    {
        var result = new List<(string, int, string)>();
        foreach (var (name, (offset, type, _)) in _symbols)
        {
            if (offset < 0 && functionResolver.FindDestructor(type) != null) // Locals have negative offset
            {
                result.Add((name, offset, type));
            }
        }
        return result;
    }

    public bool TryGetSymbol(string name, out int offset, out string type, out bool isConst)
    {
        if (_symbols.TryGetValue(name, out var symbol))
        {
            offset = symbol.Offset;
            type = symbol.Type;
            isConst = symbol.IsConst;
            return true;
        }
        offset = 0; type = string.Empty; isConst = false;
        return false;
    }

    public string GetSymbolType(string name)
    {
        return _symbols.TryGetValue(name, out var symbol)
            ? symbol.Type
            : throw new InvalidOperationException($"Symbol '{name}' not found in current scope.");
    }
}
</file>

<file path="Generator\TypeRepository.cs">
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class TypeRepository
{
    private readonly Dictionary<string, StructDefinitionNode> _structs;
    private readonly Dictionary<string, EnumDefinitionNode> _enums;
    private readonly Dictionary<string, CompilationUnitNode> _structUnitMap;
    private readonly Dictionary<string, CompilationUnitNode> _enumUnitMap;

    public TypeRepository(ProgramNode program)
    {
        _structs = program.CompilationUnits.SelectMany(cu => cu.Structs)
            .ToDictionary(s => GetFullyQualifiedName(s));
        _enums = program.CompilationUnits.SelectMany(cu => cu.Enums)
            .ToDictionary(e => GetFullyQualifiedName(e));

        _structUnitMap = new Dictionary<string, CompilationUnitNode>();
        foreach (var cu in program.CompilationUnits)
            foreach (var s in cu.Structs)
                _structUnitMap[GetFullyQualifiedName(s)] = cu;

        _enumUnitMap = new Dictionary<string, CompilationUnitNode>();
        foreach (var cu in program.CompilationUnits)
            foreach (var e in cu.Enums)
                _enumUnitMap[GetFullyQualifiedName(e)] = cu;
    }

    public static string GetFullyQualifiedName(StructDefinitionNode s) => s.Namespace != null ? $"{s.Namespace}::{s.Name}" : s.Name;
    public static string GetFullyQualifiedName(EnumDefinitionNode e) => e.Namespace != null ? $"{e.Namespace}::{e.Name}" : e.Name;

    public StructDefinitionNode? FindStruct(string qualifiedName) => _structs.TryGetValue(qualifiedName, out var def) ? def : null;

    public StructDefinitionNode? FindStructByUnqualifiedName(string name, string? currentNamespace)
    {
        var fqn = currentNamespace != null ? $"{currentNamespace}::{name}" : name;
        if (_structs.TryGetValue(fqn, out var def)) return def;
        return _structs.TryGetValue(name, out def) ? def : null;
    }

    public EnumDefinitionNode? FindEnum(string qualifiedName) => _enums.TryGetValue(qualifiedName, out var def) ? def : null;

    public IEnumerable<StructDefinitionNode> GetAllStructs() => _structs.Values;
    public IEnumerable<EnumDefinitionNode> GetAllEnums() => _enums.Values;

    public CompilationUnitNode GetCompilationUnitForStruct(string structFqn) => _structUnitMap[structFqn];
    public CompilationUnitNode GetCompilationUnitForEnum(string enumFqn) => _enumUnitMap[enumFqn];

    public bool IsStruct(string typeName) => _structs.ContainsKey(typeName.TrimEnd('*'));

    public static string GetTypeNameFromToken(Token type, int pointerLevel) => type.Value + new string('*', pointerLevel);
}
</file>

<file path="Generator\VTableManager.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class VTableManager
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;

    private readonly Dictionary<string, List<AstNode>> _vtableCache = new();
    private readonly Dictionary<string, bool> _hasVTableCache = new();

    public VTableManager(TypeRepository typeRepository, TypeResolver typeResolver)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
    }

    public bool HasVTable(string structFqn)
    {
        if (_hasVTableCache.TryGetValue(structFqn, out var hasVTable)) return hasVTable;

        var structDef = _typeRepository.FindStruct(structFqn);
        if (structDef == null) return false;

        bool result = structDef.Methods.Any(m => m.IsVirtual) || structDef.Destructors.Any(d => d.IsVirtual);
        if (result)
        {
            _hasVTableCache[structFqn] = true;
            return true;
        }

        if (structDef.BaseStructName != null)
        {
            var unit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            var baseFqn = _typeResolver.ResolveTypeName(structDef.BaseStructName, structDef.Namespace, unit);
            result = HasVTable(baseFqn);
        }

        _hasVTableCache[structFqn] = result;
        return result;
    }

    public List<AstNode> GetVTable(string structFqn)
    {
        if (_vtableCache.TryGetValue(structFqn, out var vtable)) return vtable;

        var structDef = _typeRepository.FindStruct(structFqn) ?? throw new InvalidOperationException($"Struct {structFqn} not found.");

        var newVTable = new List<AstNode>();
        if (structDef.BaseStructName != null)
        {
            var unit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            var baseFqn = _typeResolver.ResolveTypeName(structDef.BaseStructName, structDef.Namespace, unit);
            newVTable.AddRange(GetVTable(baseFqn));
        }

        var dtor = structDef.Destructors.FirstOrDefault();
        if (dtor?.IsVirtual ?? false)
        {
            if (newVTable.Any(n => n is DestructorDeclarationNode)) newVTable[0] = dtor;
            else newVTable.Insert(0, dtor);
        }

        foreach (var method in structDef.Methods)
        {
            int index = newVTable.FindIndex(m => m is FunctionDeclarationNode f && f.Name == method.Name);
            if (method.IsOverride)
            {
                if (index == -1) throw new InvalidOperationException($"Method '{method.Name}' marked 'override' but no virtual method found in base class.");
                newVTable[index] = method;
            }
            else if (method.IsVirtual)
            {
                if (index != -1) throw new InvalidOperationException($"Virtual method '{method.Name}' cannot be redeclared. Use 'override'.");
                newVTable.Add(method);
            }
        }
        _vtableCache[structFqn] = newVTable;
        return newVTable;
    }

    public int GetMethodVTableIndex(string structFqn, string methodName)
    {
        var vtable = GetVTable(structFqn);
        var index = vtable.FindIndex(n => n is FunctionDeclarationNode f && f.Name == methodName);
        if (index == -1) throw new InvalidOperationException($"Method '{methodName}' is not in the vtable for struct '{structFqn}'.");
        return index;
    }
}
</file>

<file path="Parser\ExpressionParser.cs">
using System;
using System.Collections.Generic;
using System.Globalization;

namespace CTilde;

internal class ExpressionParser
{
    private readonly Parser _parser;
    private int _stringLabelCounter;

    internal ExpressionParser(Parser parser)
    {
        _parser = parser;
    }

    internal ExpressionNode ParseInitializerListExpression()
    {
        _parser.Eat(TokenType.LeftBrace);
        var values = new List<ExpressionNode>();
        if (_parser.Current.Type != TokenType.RightBrace)
        {
            do { values.Add(ParseExpression()); }
            while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
        }
        _parser.Eat(TokenType.RightBrace);
        return new InitializerListExpressionNode(values);
    }

    internal ExpressionNode ParseExpression() => ParseAssignmentExpression();

    private ExpressionNode ParseAssignmentExpression()
    {
        var left = ParseEqualityExpression();
        if (_parser.Current.Type == TokenType.Assignment)
        {
            _parser.Eat(TokenType.Assignment);
            var right = ParseAssignmentExpression();
            if (left is VariableExpressionNode or MemberAccessExpressionNode or UnaryExpressionNode) return new AssignmentExpressionNode(left, right);
            throw new InvalidOperationException($"Invalid assignment target: {left.GetType().Name}");
        }
        return left;
    }

    private ExpressionNode ParseEqualityExpression()
    {
        var left = ParseRelationalExpression();
        while (_parser.Current.Type is TokenType.DoubleEquals or TokenType.NotEquals)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseRelationalExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseRelationalExpression()
    {
        var left = ParseAdditiveExpression();
        while (_parser.Current.Type is TokenType.LessThan or TokenType.GreaterThan)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseAdditiveExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseAdditiveExpression()
    {
        var left = ParseMultiplicativeExpression();
        while (_parser.Current.Type is TokenType.Plus or TokenType.Minus)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseMultiplicativeExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseMultiplicativeExpression()
    {
        var left = ParseUnaryExpression();
        while (_parser.Current.Type is TokenType.Star or TokenType.Slash)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseUnaryExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseUnaryExpression()
    {
        if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "new")
        {
            return ParseNewExpression();
        }
        if (_parser.Current.Type is TokenType.Minus or TokenType.Plus or TokenType.Star or TokenType.Ampersand)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            return new UnaryExpressionNode(op, ParseUnaryExpression());
        }
        return ParsePostfixExpression();
    }

    private NewExpressionNode ParseNewExpression()
    {
        _parser.Eat(TokenType.Keyword); // new
        var typeToken = _parser.Eat(TokenType.Identifier);

        _parser.Eat(TokenType.LeftParen);
        var arguments = new List<ExpressionNode>();
        if (_parser.Current.Type != TokenType.RightParen)
        {
            do { arguments.Add(ParseExpression()); }
            while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
        }
        _parser.Eat(TokenType.RightParen);

        return new NewExpressionNode(typeToken, arguments);
    }

    private ExpressionNode ParsePostfixExpression()
    {
        var expr = ParsePrimaryExpression();
        while (true)
        {
            if (_parser.Current.Type == TokenType.LeftParen)
            {
                _parser.Eat(TokenType.LeftParen);
                var arguments = new List<ExpressionNode>();
                if (_parser.Current.Type != TokenType.RightParen)
                {
                    do { arguments.Add(ParseExpression()); }
                    while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
                }
                _parser.Eat(TokenType.RightParen);
                expr = new CallExpressionNode(expr, arguments);
            }
            else if (_parser.Current.Type is TokenType.Dot or TokenType.Arrow)
            {
                var op = _parser.Current; _parser.AdvancePosition(1);
                var member = _parser.Eat(TokenType.Identifier);
                expr = new MemberAccessExpressionNode(expr, op, member);
            }
            else if (_parser.Current.Type == TokenType.DoubleColon)
            {
                _parser.Eat(TokenType.DoubleColon);
                var member = _parser.Eat(TokenType.Identifier);
                expr = new QualifiedAccessExpressionNode(expr, member);
            }
            else { break; }
        }
        return expr;
    }

    private ExpressionNode ParsePrimaryExpression()
    {
        if (_parser.Current.Type == TokenType.IntegerLiteral)
        {
            var token = _parser.Eat(TokenType.IntegerLiteral);
            if (int.TryParse(token.Value, out int v)) return new IntegerLiteralNode(v);
            throw new InvalidOperationException($"Could not parse int: {token.Value}");
        }
        if (_parser.Current.Type == TokenType.HexLiteral)
        {
            var token = _parser.Eat(TokenType.HexLiteral);
            var hex = token.Value.StartsWith("0x") ? token.Value.Substring(2) : token.Value;
            if (int.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int v)) return new IntegerLiteralNode(v);
            throw new InvalidOperationException($"Could not parse hex: {token.Value}");
        }
        if (_parser.Current.Type == TokenType.StringLiteral)
        {
            var token = _parser.Eat(TokenType.StringLiteral);
            return new StringLiteralNode(token.Value, $"str{_stringLabelCounter++}");
        }
        if (_parser.Current.Type == TokenType.Identifier) return new VariableExpressionNode(_parser.Eat(TokenType.Identifier));
        if (_parser.Current.Type == TokenType.LeftParen)
        {
            _parser.Eat(TokenType.LeftParen);
            var expr = ParseExpression();
            _parser.Eat(TokenType.RightParen);
            return expr;
        }
        throw new InvalidOperationException($"Unexpected expression token: {_parser.Current.Type}");
    }
}
</file>

<file path="Parser\Parser.cs">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

namespace CTilde;

public class Parser
{
    internal readonly List<Token> _tokens;
    internal int _position;
    internal string? _currentNamespace;
    internal readonly List<ImportDirectiveNode> _imports = new();

    private readonly ExpressionParser _expressionParser;
    private readonly StatementParser _statementParser;

    public Parser(List<Token> tokens)
    {
        _tokens = tokens;
        _position = 0;
        _expressionParser = new ExpressionParser(this);
        _statementParser = new StatementParser(this, _expressionParser);
    }

    internal Token Current => _position < _tokens.Count ? _tokens[_position] : new(TokenType.Unknown, string.Empty);
    internal Token Peek(int offset) => _position + offset < _tokens.Count ? _tokens[_position + offset] : new(TokenType.Unknown, string.Empty);

    internal Token Eat(TokenType expectedType)
    {
        var currentToken = Current;
        if (currentToken.Type == expectedType)
        {
            _position++;
            return currentToken;
        }
        throw new InvalidOperationException($"Expected token {expectedType} but got {currentToken.Type} ('{currentToken.Value}') at position {_position}");
    }

    internal void AdvancePosition(int amount) => _position += amount;

    public List<ImportDirectiveNode> GetImports() => _imports;

    public CompilationUnitNode Parse(string filePath)
    {
        var usings = new List<UsingDirectiveNode>();
        var structs = new List<StructDefinitionNode>();
        var functions = new List<FunctionDeclarationNode>();
        var enums = new List<EnumDefinitionNode>();

        while (Current.Type != TokenType.Unknown)
        {
            if (Current.Type == TokenType.Hash)
            {
                var hashKeyword = Peek(1);
                if (hashKeyword.Type == TokenType.Identifier && hashKeyword.Value == "import")
                {
                    _imports.Add(ParseImportDirective());
                }
                else if (hashKeyword.Type == TokenType.Identifier && hashKeyword.Value == "include")
                {
                    ParseIncludeDirective(); // Handle and skip #include
                }
                else
                {
                    throw new InvalidOperationException($"Unexpected directive after #: '{hashKeyword.Value}'");
                }
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "using")
            {
                usings.Add(ParseUsingDirective());
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "namespace")
            {
                ParseNamespaceDirective();
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "struct")
            {
                structs.Add(ParseStructDefinition());
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "enum")
            {
                enums.Add(ParseEnumDefinition());
            }
            else
            {
                functions.Add(ParseGlobalFunction());
            }
        }

        var unitNode = new CompilationUnitNode(filePath, usings, structs, functions, enums);
        SetParents(unitNode);
        return unitNode;
    }

    private UsingDirectiveNode ParseUsingDirective()
    {
        Eat(TokenType.Keyword); // using
        var firstIdentifier = Eat(TokenType.Identifier);
        string namespaceName;
        string? alias = null;

        if (Current.Type == TokenType.Assignment) // This is 'using alias = namespace;'
        {
            alias = firstIdentifier.Value; // 'rl' in 'using rl = raylib;'
            Eat(TokenType.Assignment);
            namespaceName = Eat(TokenType.Identifier).Value; // 'raylib' in 'using rl = raylib;'
        }
        else // This is 'using namespace;'
        {
            namespaceName = firstIdentifier.Value; // 'raylib' in 'using raylib;'
        }

        Eat(TokenType.Semicolon);
        return new UsingDirectiveNode(namespaceName, alias);
    }

    private void ParseNamespaceDirective()
    {
        Eat(TokenType.Keyword); // namespace
        var name = Eat(TokenType.Identifier);
        Eat(TokenType.Semicolon);
        _currentNamespace = name.Value;
    }

    private ImportDirectiveNode ParseImportDirective()
    {
        Eat(TokenType.Hash);
        Eat(TokenType.Identifier); // import
        var libNameToken = Eat(TokenType.StringLiteral);
        return new ImportDirectiveNode(libNameToken.Value);
    }

    private void ParseIncludeDirective()
    {
        Eat(TokenType.Hash);
        Eat(TokenType.Identifier); // include
        Eat(TokenType.StringLiteral); // "filename"
        // No AST node for include, as it's handled by the preprocessor
    }

    private EnumDefinitionNode ParseEnumDefinition()
    {
        Eat(TokenType.Keyword); // enum
        var enumName = Eat(TokenType.Identifier);
        Eat(TokenType.LeftBrace);

        var members = new List<EnumMemberNode>();
        int currentValue = 0; // Default enum value starts at 0 and increments

        while (Current.Type != TokenType.RightBrace)
        {
            var memberName = Eat(TokenType.Identifier);
            if (Current.Type == TokenType.Assignment)
            {
                Eat(TokenType.Assignment);
                var valueToken = Eat(TokenType.IntegerLiteral);
                if (!int.TryParse(valueToken.Value, out currentValue))
                {
                    throw new InvalidOperationException($"Invalid integer value for enum member '{memberName.Value}': '{valueToken.Value}'");
                }
            }
            members.Add(new EnumMemberNode(memberName, currentValue));
            currentValue++; // Increment for next default value

            if (Current.Type == TokenType.Comma)
            {
                Eat(TokenType.Comma);
            }
            else if (Current.Type != TokenType.RightBrace)
            {
                throw new InvalidOperationException($"Expected ',' or '}}' after enum member '{memberName.Value}'");
            }
        }

        Eat(TokenType.RightBrace);
        Eat(TokenType.Semicolon);
        return new EnumDefinitionNode(enumName.Value, _currentNamespace, members);
    }

    private StructDefinitionNode ParseStructDefinition()
    {
        Eat(TokenType.Keyword); // struct
        var structName = Eat(TokenType.Identifier);

        string? baseStructName = null;
        if (Current.Type == TokenType.Colon)
        {
            Eat(TokenType.Colon);
            baseStructName = Eat(TokenType.Identifier).Value;
        }

        Eat(TokenType.LeftBrace);

        var members = new List<MemberVariableNode>();
        var methods = new List<FunctionDeclarationNode>();
        var constructors = new List<ConstructorDeclarationNode>();
        var destructors = new List<DestructorDeclarationNode>();

        var currentAccess = AccessSpecifier.Private;

        while (Current.Type != TokenType.RightBrace)
        {
            if (Current.Type == TokenType.Keyword && (Current.Value == "public" || Current.Value == "private"))
            {
                currentAccess = (Current.Value == "public") ? AccessSpecifier.Public : AccessSpecifier.Private;
                Eat(TokenType.Keyword);
                Eat(TokenType.Colon);
                continue;
            }

            bool isConst = false;
            bool isVirtual = false;
            bool isOverride = false;

            if (Current.Type == TokenType.Keyword && Current.Value == "const")
            {
                isConst = true;
                Eat(TokenType.Keyword);
            }

            if (Current.Type == TokenType.Keyword && Current.Value == "virtual")
            {
                isVirtual = true;
                Eat(TokenType.Keyword);
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "override")
            {
                isOverride = true;
                Eat(TokenType.Keyword);
            }

            if (isVirtual && isOverride) throw new InvalidOperationException("A method cannot be both 'virtual' and 'override'.");

            if (Current.Type == TokenType.Tilde)
            {
                destructors.Add(ParseDestructor(structName.Value, currentAccess, isVirtual));
                continue;
            }

            if (Current.Type == TokenType.Identifier && Current.Value == structName.Value && Peek(1).Type == TokenType.LeftParen)
            {
                if (isVirtual || isOverride || isConst) throw new InvalidOperationException("Constructors cannot be marked 'virtual', 'override', or 'const'.");
                constructors.Add(ParseConstructor(structName.Value, baseStructName, currentAccess));
                continue;
            }

            var (type, pointerLevel) = ParseType();

            Token name;
            if (Current.Type == TokenType.Keyword && Current.Value == "operator")
            {
                Eat(TokenType.Keyword); // operator
                var opToken = Current;
                _position++;
                name = new Token(TokenType.Identifier, $"operator_{NameMangler.MangleOperator(opToken.Value)}");
            }
            else
            {
                name = Eat(TokenType.Identifier);
            }

            if (Current.Type == TokenType.LeftParen)
            {
                var methodNode = FinishParsingFunction(type, pointerLevel, name.Value, structName.Value, currentAccess, isVirtual, isOverride, _currentNamespace, true);
                methods.Add(methodNode);
            }
            else
            {
                if (isVirtual || isOverride) throw new InvalidOperationException("Only methods can be marked 'virtual' or 'override'.");
                members.Add(new MemberVariableNode(isConst, type, pointerLevel, name, currentAccess));
                Eat(TokenType.Semicolon);
            }
        }

        Eat(TokenType.RightBrace);
        Eat(TokenType.Semicolon);
        return new StructDefinitionNode(structName.Value, baseStructName, _currentNamespace, members, methods, constructors, destructors);
    }

    private ConstructorDeclarationNode ParseConstructor(string ownerStructName, string? baseStructName, AccessSpecifier access)
    {
        Eat(TokenType.Identifier);
        var parameters = ParseParameterList(false);

        BaseInitializerNode? baseInitializer = null;
        if (Current.Type == TokenType.Colon)
        {
            if (baseStructName == null) throw new InvalidOperationException($"Struct '{ownerStructName}' cannot have a base initializer because it does not inherit from another struct.");
            Eat(TokenType.Colon);
            var baseName = Eat(TokenType.Identifier);
            if (baseName.Value != baseStructName) throw new InvalidOperationException($"Base initializer name '{baseName.Value}' does not match the base struct name '{baseStructName}'.");

            Eat(TokenType.LeftParen);
            var arguments = new List<ExpressionNode>();
            if (Current.Type != TokenType.RightParen)
            {
                do { arguments.Add(_expressionParser.ParseExpression()); }
                while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
            }
            Eat(TokenType.RightParen);
            baseInitializer = new BaseInitializerNode(arguments);
        }

        var body = _statementParser.ParseBlockStatement();
        return new ConstructorDeclarationNode(ownerStructName, _currentNamespace, access, parameters, baseInitializer, body);
    }

    private DestructorDeclarationNode ParseDestructor(string ownerStructName, AccessSpecifier access, bool isVirtual)
    {
        Eat(TokenType.Tilde);
        var name = Eat(TokenType.Identifier);
        if (name.Value != ownerStructName) throw new InvalidOperationException($"Destructor name '~{name.Value}' must match struct name '{ownerStructName}'.");

        Eat(TokenType.LeftParen);
        Eat(TokenType.RightParen);

        var body = _statementParser.ParseBlockStatement();
        return new DestructorDeclarationNode(ownerStructName, _currentNamespace, access, isVirtual, body);
    }


    private void SetParents(AstNode node)
    {
        foreach (var property in node.GetType().GetProperties())
        {
            if (property.CanWrite && property.Name == "Parent") continue;
            if (property.GetValue(node) is AstNode child)
            {
                var parentProp = child.GetType().GetProperty("Parent");
                if (parentProp != null && parentProp.CanWrite) parentProp.SetValue(child, node);
                SetParents(child);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children.ToList()) // ToList to avoid mutation issues
                {
                    var parentProp = c.GetType().GetProperty("Parent");
                    if (parentProp != null && parentProp.CanWrite) parentProp.SetValue(c, node);
                    SetParents(c);
                }
            }
        }
    }

    internal (Token type, int pointerLevel) ParseType()
    {
        Token typeToken;
        string? namespaceQualifier = null;

        if (Current.Type == TokenType.Identifier && Peek(1).Type == TokenType.DoubleColon)
        {
            namespaceQualifier = Eat(TokenType.Identifier).Value;
            Eat(TokenType.DoubleColon);
        }

        if (Current.Type == TokenType.Keyword && Current.Value == "struct")
        {
            Eat(TokenType.Keyword); // struct
            typeToken = Eat(TokenType.Identifier);
        }
        else
        {
            typeToken = Current;
            _position++;
        }

        if (typeToken.Type == TokenType.Identifier)
        {
            if (namespaceQualifier != null)
            {
                typeToken = new Token(typeToken.Type, $"{namespaceQualifier}::{typeToken.Value}");
            }
        }

        int pointerLevel = 0;
        while (Current.Type == TokenType.Star)
        {
            Eat(TokenType.Star);
            pointerLevel++;
        }
        return (typeToken, pointerLevel);
    }

    private List<ParameterNode> ParseParameterList(bool addThisPointer)
    {
        Eat(TokenType.LeftParen);
        var parameters = new List<ParameterNode>();
        if (Current.Type != TokenType.RightParen)
        {
            do
            {
                var (paramType, paramPointerLevel) = ParseType();
                var paramName = Eat(TokenType.Identifier);
                parameters.Add(new ParameterNode(paramType, paramPointerLevel, paramName));
            } while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
        }
        Eat(TokenType.RightParen);
        return parameters;
    }

    private FunctionDeclarationNode ParseGlobalFunction()
    {
        var (returnType, returnPointerLevel) = ParseType();
        var identifier = Eat(TokenType.Identifier);
        return FinishParsingFunction(returnType, returnPointerLevel, identifier.Value, null, AccessSpecifier.Public, false, false, _currentNamespace, false);
    }

    private FunctionDeclarationNode FinishParsingFunction(Token returnType, int returnPointerLevel, string name, string? ownerStructName, AccessSpecifier accessLevel, bool isVirtual, bool isOverride, string? namespaceName, bool isMethod)
    {
        var parameters = ParseParameterList(isMethod);

        if (isMethod && ownerStructName != null)
        {
            var thisTypeTokenValue = namespaceName != null ? $"{namespaceName}::{ownerStructName}" : ownerStructName;
            var thisParam = new ParameterNode(new Token(TokenType.Identifier, thisTypeTokenValue), 1, new Token(TokenType.Identifier, "this"));
            parameters.Insert(0, thisParam);
        }

        StatementNode? body = null;
        if (Current.Type == TokenType.LeftBrace)
        {
            body = _statementParser.ParseBlockStatement();
        }
        else
        {
            Eat(TokenType.Semicolon); // For function prototypes
        }

        return new FunctionDeclarationNode(returnType, returnPointerLevel, name, parameters, body, ownerStructName, accessLevel, isVirtual, isOverride, namespaceName);
    }
}
</file>

<file path="Parser\StatementParser.cs">
using System;
using System.Collections.Generic;

namespace CTilde;

internal class StatementParser
{
    private readonly Parser _parser;
    private readonly ExpressionParser _expressionParser;

    internal StatementParser(Parser parser, ExpressionParser expressionParser)
    {
        _parser = parser;
        _expressionParser = expressionParser;
    }

    internal BlockStatementNode ParseBlockStatement()
    {
        _parser.Eat(TokenType.LeftBrace);
        var statements = new List<StatementNode>();
        while (_parser.Current.Type != TokenType.RightBrace) statements.Add(ParseStatement());
        _parser.Eat(TokenType.RightBrace);
        return new BlockStatementNode(statements);
    }

    internal StatementNode ParseStatement()
    {
        if (_parser.Current.Type == TokenType.Keyword)
        {
            switch (_parser.Current.Value)
            {
                case "return": return ParseReturnStatement();
                case "if": return ParseIfStatement();
                case "while": return ParseWhileStatement();
                case "delete": return ParseDeleteStatement();
                case "const":
                case "int":
                case "char":
                case "struct":
                    return ParseDeclarationStatement();
            }
        }

        bool isDeclaration = false;
        if (_parser.Current.Type == TokenType.Identifier || (_parser.Current.Type == TokenType.Keyword && (_parser.Current.Value == "const" || _parser.Current.Value == "int" || _parser.Current.Value == "char" || _parser.Current.Value == "struct")))
        {
            int tempPos = _parser._position;
            try
            {
                if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "const") _parser.AdvancePosition(1);
                _parser.ParseType();
                if (_parser.Current.Type == TokenType.Identifier) isDeclaration = true;
            }
            finally { _parser._position = tempPos; }
        }

        if (isDeclaration) return ParseDeclarationStatement();
        if (_parser.Current.Type == TokenType.LeftBrace) return ParseBlockStatement();

        var expression = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.Semicolon);
        return new ExpressionStatementNode(expression);
    }

    private DeleteStatementNode ParseDeleteStatement()
    {
        _parser.Eat(TokenType.Keyword); // delete
        var expr = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.Semicolon);
        return new DeleteStatementNode(expr);
    }

    private IfStatementNode ParseIfStatement()
    {
        _parser.Eat(TokenType.Keyword);
        _parser.Eat(TokenType.LeftParen);
        var condition = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.RightParen);
        var thenBody = ParseStatement();
        StatementNode? elseBody = null;
        if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "else")
        {
            _parser.Eat(TokenType.Keyword);
            elseBody = ParseStatement();
        }
        return new IfStatementNode(condition, thenBody, elseBody);
    }

    private StatementNode ParseDeclarationStatement()
    {
        bool isConst = false;
        if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "const")
        {
            isConst = true;
            _parser.Eat(TokenType.Keyword);
        }

        var (typeToken, pointerLevel) = _parser.ParseType();
        var identifier = _parser.Eat(TokenType.Identifier);

        ExpressionNode? initializer = null;
        List<ExpressionNode>? ctorArgs = null;

        if (_parser.Current.Type == TokenType.Assignment)
        {
            _parser.Eat(TokenType.Assignment);
            if (_parser.Current.Type == TokenType.LeftBrace) initializer = _expressionParser.ParseInitializerListExpression();
            else initializer = _expressionParser.ParseExpression();
        }
        else if (_parser.Current.Type == TokenType.LeftParen)
        {
            _parser.Eat(TokenType.LeftParen);
            ctorArgs = new List<ExpressionNode>();
            if (_parser.Current.Type != TokenType.RightParen)
            {
                do { ctorArgs.Add(_expressionParser.ParseExpression()); }
                while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
            }
            _parser.Eat(TokenType.RightParen);
        }
        else if (isConst)
        {
            throw new InvalidOperationException($"Constant variable '{identifier.Value}' must be initialized.");
        }
        _parser.Eat(TokenType.Semicolon);
        return new DeclarationStatementNode(isConst, typeToken, pointerLevel, identifier, initializer, ctorArgs);
    }

    private WhileStatementNode ParseWhileStatement()
    {
        _parser.Eat(TokenType.Keyword);
        _parser.Eat(TokenType.LeftParen);
        var condition = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.RightParen);
        var body = ParseStatement();
        return new WhileStatementNode(condition, body);
    }

    private ReturnStatementNode ParseReturnStatement()
    {
        _parser.Eat(TokenType.Keyword);
        ExpressionNode? expression = null;
        if (_parser.Current.Type != TokenType.Semicolon) expression = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.Semicolon);
        return new ReturnStatementNode(expression);
    }
}
</file>

<file path="Tokenizer\Tokenizer.cs">
using System.Collections.Generic;
using System.Text;

namespace CTilde;

public enum TokenType
{
    Keyword,
    Identifier,
    IntegerLiteral,
    HexLiteral,
    StringLiteral,
    Semicolon,
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Comma,
    Dot,
    Hash,
    Assignment,
    Unknown,
    Plus,
    Minus,
    Star,
    Slash,
    DoubleEquals,
    NotEquals,
    LessThan,
    GreaterThan,
    Ampersand,
    Arrow,
    Colon,
    DoubleColon,
    Enum,
    Tilde
}

public record Token(TokenType Type, string Value);

public class Tokenizer
{
    private static readonly HashSet<string> Keywords =
    [
        "int",
        "void",
        "return",
        "while",
        "if",
        "else",
        "struct",
        "char",
        "public",
        "private",
        "namespace",
        "using",
        "const",
        "enum",
        "virtual",
        "override",
        "new",
        "delete",
        "operator" // NEW
    ];

    public static List<Token> Tokenize(string input)
    {
        List<Token> tokens = [];
        int i = 0;

        while (i < input.Length)
        {
            char c = input[i];

            if (char.IsWhiteSpace(c)) { i++; continue; }
            if (c == '/' && i + 1 < input.Length && input[i + 1] == '/') { while (i < input.Length && input[i] != '\n') i++; continue; }
            if (c == '"')
            {
                i++;
                var sb = new StringBuilder();
                while (i < input.Length && input[i] != '"')
                {
                    char current = input[i];
                    if (current == '\\' && i + 1 < input.Length)
                    {
                        i++;
                        switch (input[i])
                        {
                            case 'n': sb.Append('\n'); break;
                            case 't': sb.Append('\t'); break;
                            case '\\': sb.Append('\\'); break;
                            case '"': sb.Append('"'); break;
                            default: sb.Append('\\'); sb.Append(input[i]); break;
                        }
                    }
                    else sb.Append(current);
                    i++;
                }
                if (i < input.Length) i++;
                tokens.Add(new Token(TokenType.StringLiteral, sb.ToString()));
                continue;
            }

            switch (c)
            {
                case '~': tokens.Add(new(TokenType.Tilde, "~")); i++; continue;
                case '#': tokens.Add(new(TokenType.Hash, "#")); i++; continue;
                case '.': tokens.Add(new(TokenType.Dot, ".")); i++; continue;
                case ':':
                    if (i + 1 < input.Length && input[i + 1] == ':') { tokens.Add(new(TokenType.DoubleColon, "::")); i += 2; }
                    else { tokens.Add(new(TokenType.Colon, ":")); i++; }
                    continue;
                case '(': tokens.Add(new(TokenType.LeftParen, "(")); i++; continue;
                case ')': tokens.Add(new(TokenType.RightParen, ")")); i++; continue;
                case '{': tokens.Add(new(TokenType.LeftBrace, "{")); i++; continue;
                case '}': tokens.Add(new(TokenType.RightBrace, "}")); i++; continue;
                case ';': tokens.Add(new(TokenType.Semicolon, ";")); i++; continue;
                case ',': tokens.Add(new(TokenType.Comma, ",")); i++; continue;
                case '+': tokens.Add(new(TokenType.Plus, "+")); i++; continue;
                case '-':
                    if (i + 1 < input.Length && input[i + 1] == '>') { tokens.Add(new(TokenType.Arrow, "->")); i += 2; }
                    else { tokens.Add(new(TokenType.Minus, "-")); i++; }
                    continue;
                case '*': tokens.Add(new(TokenType.Star, "*")); i++; continue;
                case '/': tokens.Add(new(TokenType.Slash, "/")); i++; continue;
                case '&': tokens.Add(new(TokenType.Ampersand, "&")); i++; continue;
                case '<': tokens.Add(new(TokenType.LessThan, "<")); i++; continue;
                case '>': tokens.Add(new(TokenType.GreaterThan, ">")); i++; continue;
                case '=':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.DoubleEquals, "==")); i += 2; }
                    else { tokens.Add(new(TokenType.Assignment, "=")); i++; }
                    continue;
                case '!':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.NotEquals, "!=")); i += 2; }
                    else { tokens.Add(new(TokenType.Unknown, c.ToString())); i++; }
                    continue;
            }

            if (c == '0' && i + 1 < input.Length && (input[i + 1] == 'x' || input[i + 1] == 'X'))
            {
                int start = i;
                i += 2;
                while (i < input.Length && "0123456789abcdefABCDEF".Contains(input[i])) i++;
                tokens.Add(new Token(TokenType.HexLiteral, input.Substring(start, i - start)));
                continue;
            }
            if (char.IsDigit(c))
            {
                int start = i;
                while (i < input.Length && char.IsDigit(input[i])) i++;
                tokens.Add(new(TokenType.IntegerLiteral, input.Substring(start, i - start)));
                continue;
            }
            if (char.IsLetter(c) || c == '_')
            {
                int start = i;
                while (i < input.Length && (char.IsLetterOrDigit(input[i]) || input[i] == '_')) i++;
                string value = input.Substring(start, i - start);
                tokens.Add(new(Keywords.Contains(value) ? TokenType.Keyword : TokenType.Identifier, value));
                continue;
            }
            tokens.Add(new(TokenType.Unknown, c.ToString()));
            i++;
        }
        tokens.Add(new(TokenType.Unknown, string.Empty));
        return tokens;
    }
}
</file>

<file path="main.c">
#import "raylib.dll"
#import "msvcrt.dll"
#include "raylib.c"
#include "string.c"
#include "position.c"
#include "text_object.c"

using rl = raylib;
using game;
using std;

int main() 
{
    const int screenWidth = 800;
    const int screenHeight = 600;

    rl::Color rayWhite = {245, 245, 245, 255};
    rl::Color maroon = {190, 33, 55, 255};
    //rl::Color maroon(190, 33, 55, 255);

    rl::InitWindow(screenWidth, screenHeight, "Operator Overloading!");
    rl::SetTargetFPS(60);

    string hello = "Hello ";
    string world = "World!";
    string message = hello + &world; 
    
    TextObject myText(150, 275, "GO FUCK YOURSELF", 40, maroon);

    while (rl::WindowShouldClose() == 0) 
    {
        rl::BeginDrawing();
        rl::ClearBackground(rayWhite);
        myText.draw();
        rl::EndDrawing();
    }
    
    rl::CloseWindow();
    
    return 0; // All string objects (hello, world, message) are automatically destroyed here.
}
</file>

<file path="merged.c">
#import "raylib.dll"
namespace raylib;

struct Color 
{
    char r;
    char g;
    char b;
    char a;
};

void InitWindow(int width, int height, int title);
int WindowShouldClose();
void BeginDrawing();
void EndDrawing();
void ClearBackground(Color color);
void DrawText(int text, int posX, int posY, int fontSize, Color color);
void CloseWindow();

using raylib;

struct TextObject 
{
private:
    int x;

public:
    int y;
    int text;
    int fontSize;
    Color color;

    void init(int startX, int startY, int newText, int fSize, Color newColor) 
    {
        x = startX;
        y = startY;
        text = newText;
        fontSize = fSize;
        color = newColor;
    }

    void draw() 
    {
        DrawText(text, x, y, fontSize, color);
    }
    
    void move_right() 
    {
        x = x + 1;
    }
};


using raylib;

int main() 
{
    int screenWidth = 800;
    int screenHeight = 600;

    Color rayWhite = {245, 245, 245, 255};
    Color maroon = {190, 33, 55, 255};

    TextObject myText;
    // Initialize the object using its public method.
    // Direct access like `myText.x = 140;` would fail because x is private.
    myText.init(140, 275, "Encapsulation!", 20, maroon);

    InitWindow(screenWidth, screenHeight, "CTilde with Access Specifiers!");

    while (WindowShouldClose() == 0) 
    {
        BeginDrawing();
        ClearBackground(rayWhite);
        
        myText.move_right();
        myText.draw();
        
        EndDrawing();
    }

    CloseWindow();
    
    return 0;
}
</file>

<file path="position.c">
namespace game;

struct Position
{
public:
    int x;
    int y;

    Position(int startX, int startY)
    {
        x = startX;
        y = startY;
    }

    virtual ~Position()
    {
        // Base destructor
    }

    virtual void move_left(int deltaTime)
    {
        if (raylib::IsKeyDown(raylib::KeyboardKey::KEY_A))
        {
            x = x - (100 * deltaTime / 1000); // Default implementation
        }
    }
};
</file>

<file path="raylib.c">
namespace raylib;

struct Color 
{
    char r;
    char g;
    char b;
    char a;

    //Color(char r, char g, char b, char a) 
    //{
    //    this.r = r;
    //    this.g = g;
    //    this.b = b;
    //    this.a = a;
    //}
};

enum KeyboardKey 
{
    KEY_D = 68,
    KEY_A = 65,
    KEY_W = 87,
    KEY_S = 83,
    KEY_LEFT = 263,
    KEY_RIGHT = 262,
    KEY_UP = 265,
    KEY_DOWN = 264
};

void InitWindow(int width, int height, char* title);
void SetTargetFPS(int fps);
int WindowShouldClose();
void BeginDrawing();
void EndDrawing();
void ClearBackground(Color color);
void DrawText(char* text, int posX, int posY, int fontSize, Color color);
void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color); // NEW
void CloseWindow();
int GetFPS();
int IsKeyDown(int key);
</file>

<file path="string.c">
// Forward-declare C standard library functions we will import.
// These now use the correct char* type.
int strlen(char* str);
void strcpy(char* dest, char* src);
void memcpy(char* dest, char* src, int count);
int malloc(int size);
void free(int ptr);

namespace std;

struct string 
{
private:
    int m_length;
    char* m_data; // This is now correctly a char*

public:
    // Constructor from a string literal
    string(char* literal) 
    {
        m_length = strlen(literal);
        m_data = malloc(m_length + 1);
        strcpy(m_data, literal);
    }
    
    // Copy constructor (takes a pointer to the other string)
    string(string* other)
    {
        m_length = other->length();
        m_data = malloc(m_length + 1);
        strcpy(m_data, other->c_str());
    }

    // Destructor to free the allocated memory
    ~string() 
    {
        free(m_data);
    }
    
    // Concatenation operator
    string operator+(string* other)
    {
        int new_len = m_length + other->length();
        char* new_buffer = malloc(new_len + 1);
        
        memcpy(new_buffer, m_data, m_length);
        memcpy(new_buffer + m_length, other->c_str(), other->length());
        *(new_buffer + new_len) = 0; // BUG FIX: Null-terminate the new buffer
        
        // Create a new string object from our temporary buffer
        string result(new_buffer);
        
        // The temporary buffer is no longer needed, as the result string made its own copy
        free(new_buffer);
        
        return result;
    }

    char* c_str() 
    {
        return m_data;
    }

    int length() 
    {
        return m_length;
    }
};
</file>

<file path="text_object.c">
using raylib;
using game;
using std;

struct TextObject : Position
{
private:
    int speed; 
    string* m_text;

public:
    int fontSize;
    Color color;

    TextObject(int startX, int startY, char* literal, int fSize, Color newColor)
        : Position(startX, startY)
    {
        m_text = new string(literal);
        fontSize = fSize;
        color = newColor;
        speed = 100; 
    }

    ~TextObject()
    {
        delete m_text; 
    }

    void draw() 
    {
        DrawText(m_text->c_str(), x, y, fontSize, color);
    }
    
    void move_right(int deltaTime) 
    {
        if (IsKeyDown(raylib::KeyboardKey::KEY_D))
        {
            x = x + (speed * deltaTime / 1000);
        }
    }

    override void move_left(int deltaTime)
    {
        if (IsKeyDown(raylib::KeyboardKey::KEY_A))
        {
             x = x - (speed * deltaTime / 500);
        }
    }
};
</file>

