<file path="Ast.cs">
using System.Collections.Generic;

namespace CTilde;

// Base classes
public abstract record AstNode;
public abstract record StatementNode : AstNode;
public abstract record ExpressionNode : AstNode;

// Program structure
public record ProgramNode(FunctionDeclarationNode Function) : AstNode;
public record FunctionDeclarationNode(string Name, StatementNode Body) : AstNode;

// Statements
public record BlockStatementNode(List<StatementNode> Statements) : StatementNode;
public record ReturnStatementNode(ExpressionNode Expression) : StatementNode;
public record WhileStatementNode(ExpressionNode Condition, StatementNode Body) : StatementNode;
public record IfStatementNode(ExpressionNode Condition, StatementNode ThenBody, StatementNode? ElseBody) : StatementNode;
public record DeclarationStatementNode(Token Identifier, ExpressionNode? Initializer) : StatementNode;
public record ExpressionStatementNode(ExpressionNode Expression) : StatementNode;


// Expressions
public record IntegerLiteralNode(int Value) : ExpressionNode;
public record AssignmentExpressionNode(Token Identifier, ExpressionNode Value) : ExpressionNode;
public record VariableExpressionNode(Token Identifier) : ExpressionNode;
public record CallExpressionNode(Token Callee, ExpressionNode Argument) : ExpressionNode;
public record BinaryExpressionNode(ExpressionNode Left, Token Operator, ExpressionNode Right) : ExpressionNode;
</file>

<file path="Generator.cs">
using System;
using System.Collections.Generic;
using System.Text;

namespace CTilde;

public class Generator
{
    private readonly ProgramNode _program;
    private readonly StringBuilder _sb = new();
    private int _labelCounter;

    // Rudimentary symbol table for a function's scope
    private Dictionary<string, int> _variables = new();
    private int _stackOffset;

    public Generator(ProgramNode program)
    {
        _program = program;
    }

    public string Generate()
    {
        _sb.AppendLine("format PE console");
        _sb.AppendLine("entry start");
        _sb.AppendLine();
        _sb.AppendLine("include 'win32a.inc'");
        _sb.AppendLine();
        _sb.AppendLine("section '.data' data readable writeable");
        _sb.AppendLine("    format_int db '%d', 10, 0 ; Format string for printing an integer with a newline");
        _sb.AppendLine();
        _sb.AppendLine("section '.text' code readable executable");
        _sb.AppendLine();
        _sb.AppendLine("start:");
        _sb.AppendLine("    call main");
        _sb.AppendLine("    mov ebx, eax"); // EAX holds the return value from main
        _sb.AppendLine("    push ebx");
        _sb.AppendLine("    call [ExitProcess]");
        _sb.AppendLine();

        GenerateFunction(_program.Function);

        _sb.AppendLine();
        _sb.AppendLine("section '.idata' import data readable");
        _sb.AppendLine();
        _sb.AppendLine("    library kernel32,'kernel32.dll', msvcrt,'msvcrt.dll'");
        _sb.AppendLine();
        _sb.AppendLine("    import kernel32, ExitProcess,'ExitProcess'");
        _sb.AppendLine("    import msvcrt, printf,'printf'");

        return _sb.ToString();
    }

    private void AppendAsm(string instruction, string? comment = null)
    {
        const int commentColumn = 36;
        string indentedInstruction = $"    {instruction}";

        if (string.IsNullOrEmpty(comment))
        {
            _sb.AppendLine(indentedInstruction);
        }
        else
        {
            _sb.AppendLine(indentedInstruction.PadRight(commentColumn - 1) + $"; {comment}");
        }
    }

    private void GenerateFunction(FunctionDeclarationNode function)
    {
        _variables = new Dictionary<string, int>();
        _stackOffset = 0;

        _sb.AppendLine($"{function.Name}:");
        AppendAsm("push ebp");
        AppendAsm("mov ebp, esp");
        _sb.AppendLine();

        GenerateStatement(function.Body);
    }

    private void GenerateStatement(StatementNode statement)
    {
        switch (statement)
        {
            case ReturnStatementNode ret:
                GenerateReturn(ret);
                break;
            case BlockStatementNode block:
                foreach (var stmt in block.Statements)
                {
                    GenerateStatement(stmt);
                }
                break;
            case WhileStatementNode whileStmt:
                GenerateWhile(whileStmt);
                break;
            case IfStatementNode ifStmt:
                GenerateIf(ifStmt);
                break;
            case DeclarationStatementNode decl:
                GenerateDeclaration(decl);
                break;
            case ExpressionStatementNode exprStmt:
                GenerateExpression(exprStmt.Expression);
                _sb.AppendLine("    ; Expression statement result is discarded");
                break;
            default:
                throw new NotImplementedException($"Unsupported statement type: {statement.GetType().Name}");
        }
    }

    private void GenerateDeclaration(DeclarationStatementNode decl)
    {
        if (_variables.ContainsKey(decl.Identifier.Value))
        {
            throw new InvalidOperationException($"Variable '{decl.Identifier.Value}' is already defined.");
        }

        _stackOffset -= 4; // 4 bytes for an int
        _variables[decl.Identifier.Value] = _stackOffset;
        AppendAsm("sub esp, 4", "Allocate space for variable " + decl.Identifier.Value);

        if (decl.Initializer != null)
        {
            GenerateExpression(decl.Initializer);
            AppendAsm($"mov [ebp + {_stackOffset}], eax");
        }
    }

    private void GenerateWhile(WhileStatementNode whileStmt)
    {
        int labelIndex = _labelCounter++;
        string startLabel = $"_while_start_{labelIndex}";
        string endLabel = $"_while_end_{labelIndex}";

        _sb.AppendLine($"{startLabel}:");

        GenerateExpression(whileStmt.Condition);
        AppendAsm("cmp eax, 0");
        AppendAsm($"je {endLabel}");

        GenerateStatement(whileStmt.Body);

        AppendAsm($"jmp {startLabel}");

        _sb.AppendLine($"{endLabel}:");
    }

    private void GenerateIf(IfStatementNode ifStmt)
    {
        int labelIndex = _labelCounter++;
        string elseLabel = $"_if_else_{labelIndex}";
        string endLabel = $"_if_end_{labelIndex}";

        GenerateExpression(ifStmt.Condition);
        AppendAsm("cmp eax, 0");

        if (ifStmt.ElseBody != null)
        {
            AppendAsm($"je {elseLabel}");
        }
        else
        {
            AppendAsm($"je {endLabel}");
        }

        GenerateStatement(ifStmt.ThenBody);

        if (ifStmt.ElseBody != null)
        {
            AppendAsm($"jmp {endLabel}");
            _sb.AppendLine($"{elseLabel}:");
            GenerateStatement(ifStmt.ElseBody);
        }

        _sb.AppendLine($"{endLabel}:");
    }

    private void GenerateReturn(ReturnStatementNode ret)
    {
        GenerateExpression(ret.Expression);
        AppendAsm("mov esp, ebp");
        AppendAsm("pop ebp");
        AppendAsm("ret");
    }

    private void GenerateExpression(ExpressionNode expression)
    {
        switch (expression)
        {
            case IntegerLiteralNode literal:
                AppendAsm($"mov eax, {literal.Value}");
                break;
            case VariableExpressionNode varExpr:
                if (!_variables.TryGetValue(varExpr.Identifier.Value, out var offset))
                {
                    throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'");
                }
                AppendAsm($"mov eax, [ebp + {offset}]", $"Load variable {varExpr.Identifier.Value}");
                break;
            case AssignmentExpressionNode assignExpr:
                if (!_variables.TryGetValue(assignExpr.Identifier.Value, out var assignOffset))
                {
                    throw new InvalidOperationException($"Undeclared variable '{assignExpr.Identifier.Value}' for assignment.");
                }
                GenerateExpression(assignExpr.Value);
                AppendAsm($"mov [ebp + {assignOffset}], eax", $"Assign to variable {assignExpr.Identifier.Value}");
                break;
            case BinaryExpressionNode binExpr:
                GenerateBinaryExpression(binExpr);
                break;
            case CallExpressionNode callExpr:
                if (callExpr.Callee.Value != "print")
                {
                    throw new InvalidOperationException($"Undefined function call: '{callExpr.Callee.Value}'");
                }
                // The 'print' intrinsic
                GenerateExpression(callExpr.Argument);
                AppendAsm("push eax", "Push argument for printf");
                AppendAsm("push format_int", "Push format string");
                AppendAsm("call [printf]");
                AppendAsm("add esp, 8", "Clean up stack for printf");
                AppendAsm("mov eax, 0", "A print expression evaluates to 0");
                break;
            default:
                throw new NotImplementedException($"Unsupported expression type: {expression.GetType().Name}");
        }
    }

    private void GenerateBinaryExpression(BinaryExpressionNode binExpr)
    {
        // Generate right operand first, push to stack
        GenerateExpression(binExpr.Right);
        AppendAsm("push eax");

        // Generate left operand, result is in EAX
        GenerateExpression(binExpr.Left);

        // Pop right operand into ECX
        AppendAsm("pop ecx");

        switch (binExpr.Operator.Type)
        {
            case TokenType.Plus:
                AppendAsm("add eax, ecx", "eax = eax + ecx");
                break;
            case TokenType.Minus:
                AppendAsm("sub eax, ecx", "eax = eax - ecx");
                break;
            case TokenType.Star:
                AppendAsm("imul eax, ecx", "eax = eax * ecx");
                break;
            case TokenType.Slash:
                AppendAsm("cdq", "Sign-extend EAX into EDX:EAX");
                AppendAsm("idiv ecx", "eax = edx:eax / ecx");
                break;
            case TokenType.DoubleEquals:
                AppendAsm("cmp eax, ecx");
                AppendAsm("sete al", "Set AL if equal");
                AppendAsm("movzx eax, al", "Zero-extend AL to EAX");
                break;
            case TokenType.NotEquals:
                AppendAsm("cmp eax, ecx");
                AppendAsm("setne al", "Set AL if not equal");
                AppendAsm("movzx eax, al", "Zero-extend AL to EAX");
                break;
            case TokenType.LessThan:
                AppendAsm("cmp eax, ecx");
                AppendAsm("setl al", "Set AL if less");
                AppendAsm("movzx eax, al", "Zero-extend AL to EAX");
                break;
            case TokenType.GreaterThan:
                AppendAsm("cmp eax, ecx");
                AppendAsm("setg al", "Set AL if greater");
                AppendAsm("movzx eax, al", "Zero-extend AL to EAX");
                break;
            default:
                throw new NotImplementedException($"Unsupported binary operator: {binExpr.Operator.Type}");
        }
    }
}
</file>

<file path="Parser.cs">
using System;
using System.Collections.Generic;

namespace CTilde;

public class Parser
{
    private readonly List<Token> _tokens;
    private int _position;

    public Parser(List<Token> tokens)
    {
        _tokens = tokens;
        _position = 0;
    }

    private Token Current => _position < _tokens.Count ? _tokens[_position] : new(TokenType.Unknown, string.Empty);
    private Token Peek(int offset) => _position + offset < _tokens.Count ? _tokens[_position + offset] : new(TokenType.Unknown, string.Empty);


    private Token Eat(TokenType expectedType)
    {
        var currentToken = Current;
        if (currentToken.Type == expectedType)
        {
            _position++;
            return currentToken;
        }
        throw new InvalidOperationException($"Expected token {expectedType} but got {currentToken.Type}");
    }

    public ProgramNode Parse()
    {
        var function = ParseFunction();
        return new ProgramNode(function);
    }

    private FunctionDeclarationNode ParseFunction()
    {
        Eat(TokenType.Keyword); // "int"
        var identifier = Eat(TokenType.Identifier); // "main"
        Eat(TokenType.LeftParen);
        Eat(TokenType.RightParen);

        var body = ParseBlockStatement();

        return new FunctionDeclarationNode(identifier.Value, body);
    }

    private BlockStatementNode ParseBlockStatement()
    {
        Eat(TokenType.LeftBrace);
        var statements = new List<StatementNode>();
        while (Current.Type != TokenType.RightBrace)
        {
            statements.Add(ParseStatement());
        }
        Eat(TokenType.RightBrace);
        return new BlockStatementNode(statements);
    }

    private StatementNode ParseStatement()
    {
        if (Current.Type == TokenType.Keyword)
        {
            switch (Current.Value)
            {
                case "return":
                    return ParseReturnStatement();
                case "if":
                    return ParseIfStatement();
                case "while":
                    return ParseWhileStatement();
                case "int":
                    return ParseDeclarationStatement();
                default:
                    // An 'else' on its own, or other future keywords, are syntax errors here.
                    throw new InvalidOperationException($"Unexpected keyword '{Current.Value}' at the beginning of a statement.");
            }
        }

        if (Current.Type == TokenType.LeftBrace)
        {
            return ParseBlockStatement();
        }

        // Otherwise, it must be an expression statement (e.g. assignment, call)
        var expression = ParseExpression();
        Eat(TokenType.Semicolon);
        return new ExpressionStatementNode(expression);
    }

    private IfStatementNode ParseIfStatement()
    {
        Eat(TokenType.Keyword); // "if"
        Eat(TokenType.LeftParen);
        var condition = ParseExpression();
        Eat(TokenType.RightParen);

        var thenBody = ParseStatement();
        StatementNode? elseBody = null;

        if (Current.Type == TokenType.Keyword && Current.Value == "else")
        {
            Eat(TokenType.Keyword); // "else"
            elseBody = ParseStatement();
        }

        return new IfStatementNode(condition, thenBody, elseBody);
    }

    private StatementNode ParseDeclarationStatement()
    {
        Eat(TokenType.Keyword); // "int"
        var identifier = Eat(TokenType.Identifier);
        ExpressionNode? initializer = null;

        if (Current.Type == TokenType.Assignment)
        {
            Eat(TokenType.Assignment); // "="
            initializer = ParseExpression();
        }

        Eat(TokenType.Semicolon);
        return new DeclarationStatementNode(identifier, initializer);
    }

    private WhileStatementNode ParseWhileStatement()
    {
        Eat(TokenType.Keyword); // "while"
        Eat(TokenType.LeftParen);
        var condition = ParseExpression();
        Eat(TokenType.RightParen);
        var body = ParseStatement();
        return new WhileStatementNode(condition, body);
    }

    private ReturnStatementNode ParseReturnStatement()
    {
        Eat(TokenType.Keyword); // "return"
        var expression = ParseExpression();
        Eat(TokenType.Semicolon);
        return new ReturnStatementNode(expression);
    }

    private ExpressionNode ParseExpression()
    {
        return ParseAssignmentExpression();
    }

    private ExpressionNode ParseAssignmentExpression()
    {
        var left = ParseEqualityExpression();

        if (Current.Type == TokenType.Assignment)
        {
            Eat(TokenType.Assignment);
            var right = ParseAssignmentExpression(); // Right-associative

            if (left is VariableExpressionNode varNode)
            {
                return new AssignmentExpressionNode(varNode.Identifier, right);
            }

            throw new InvalidOperationException("Invalid assignment target.");
        }

        return left;
    }

    private ExpressionNode ParseEqualityExpression()
    {
        var left = ParseRelationalExpression();
        while (Current.Type is TokenType.DoubleEquals or TokenType.NotEquals)
        {
            var op = Current;
            _position++;
            var right = ParseRelationalExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseRelationalExpression()
    {
        var left = ParseAdditiveExpression();
        while (Current.Type is TokenType.LessThan or TokenType.GreaterThan)
        {
            var op = Current;
            _position++;
            var right = ParseAdditiveExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseAdditiveExpression()
    {
        var left = ParseMultiplicativeExpression();
        while (Current.Type is TokenType.Plus or TokenType.Minus)
        {
            var op = Current;
            _position++;
            var right = ParseMultiplicativeExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseMultiplicativeExpression()
    {
        var left = ParseCallExpression();
        while (Current.Type is TokenType.Star or TokenType.Slash)
        {
            var op = Current;
            _position++;
            var right = ParseCallExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseCallExpression()
    {
        // A call expression is a primary expression (like an identifier)
        // possibly followed by parentheses.
        var expr = ParsePrimaryExpression();

        if (Current.Type == TokenType.LeftParen)
        {
            // If we see a '(', it must be a function call.
            // The thing being called must have been a variable.
            if (expr is VariableExpressionNode varNode)
            {
                Eat(TokenType.LeftParen);
                // For now, only one argument is supported.
                var argument = ParseExpression();
                Eat(TokenType.RightParen);
                return new CallExpressionNode(varNode.Identifier, argument);
            }
            throw new InvalidOperationException("Expression is not callable.");
        }

        return expr;
    }

    private ExpressionNode ParsePrimaryExpression()
    {
        if (Current.Type == TokenType.IntegerLiteral)
        {
            var token = Eat(TokenType.IntegerLiteral);
            if (int.TryParse(token.Value, out int value))
            {
                return new IntegerLiteralNode(value);
            }
            throw new InvalidOperationException($"Could not parse integer literal: {token.Value}");
        }

        if (Current.Type == TokenType.Identifier)
        {
            var token = Eat(TokenType.Identifier);
            return new VariableExpressionNode(token);
        }

        if (Current.Type == TokenType.LeftParen)
        {
            Eat(TokenType.LeftParen);
            var expr = ParseExpression();
            Eat(TokenType.RightParen);
            return expr;
        }

        throw new InvalidOperationException($"Unexpected expression token: {Current.Type}");
    }
}
</file>

<file path="Program.cs">
using System;
using System.IO;

namespace CTilde;

public class Program
{
    public static void Main(string[] args)
    {
        string code = File.ReadAllText("Output/main.c");

        // 1. Tokenize
        var tokens = Tokenizer.Tokenize(code);

        // 2. Parse
        var parser = new Parser(tokens);
        var ast = parser.Parse();

        // 3. Generate
        var generator = new Generator(ast);
        string asmCode = generator.Generate();

        // 4. Output
        File.WriteAllText("Output/output.asm", asmCode);
        Console.WriteLine("Compilation successful. Assembly code written to output.asm");
    }
}
</file>

<file path="Tokenizer.cs">
using System.Collections.Generic;

namespace CTilde;

public enum TokenType
{
    Keyword,
    Identifier,
    IntegerLiteral,
    Semicolon,
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Assignment,
    Unknown,
    Plus,
    Minus,
    Star,
    Slash,
    DoubleEquals,
    NotEquals,
    LessThan,
    GreaterThan
}

public record Token(TokenType Type, string Value);

public class Tokenizer
{
    private static readonly HashSet<string> Keywords =
    [
        "int",
        "return",
        "while",
        "if",
        "else"
    ];

    public static List<Token> Tokenize(string input)
    {
        List<Token> tokens = [];
        int i = 0;

        while (i < input.Length)
        {
            char c = input[i];

            if (char.IsWhiteSpace(c))
            {
                i++;
                continue;
            }

            // Handle single-line comments
            if (c == '/' && i + 1 < input.Length && input[i + 1] == '/')
            {
                while (i < input.Length && input[i] != '\n')
                {
                    i++;
                }
                continue;
            }

            switch (c)
            {
                case '(':
                    tokens.Add(new(TokenType.LeftParen, "("));
                    i++;
                    continue;
                case ')':
                    tokens.Add(new(TokenType.RightParen, ")"));
                    i++;
                    continue;
                case '{':
                    tokens.Add(new(TokenType.LeftBrace, "{"));
                    i++;
                    continue;
                case '}':
                    tokens.Add(new(TokenType.RightBrace, "}"));
                    i++;
                    continue;
                case ';':
                    tokens.Add(new(TokenType.Semicolon, ";"));
                    i++;
                    continue;
                case '+':
                    tokens.Add(new(TokenType.Plus, "+"));
                    i++;
                    continue;
                case '-':
                    tokens.Add(new(TokenType.Minus, "-"));
                    i++;
                    continue;
                case '*':
                    tokens.Add(new(TokenType.Star, "*"));
                    i++;
                    continue;
                case '/':
                    tokens.Add(new(TokenType.Slash, "/"));
                    i++;
                    continue;
                case '<':
                    tokens.Add(new(TokenType.LessThan, "<"));
                    i++;
                    continue;
                case '>':
                    tokens.Add(new(TokenType.GreaterThan, ">"));
                    i++;
                    continue;
                case '=':
                    if (i + 1 < input.Length && input[i + 1] == '=')
                    {
                        tokens.Add(new(TokenType.DoubleEquals, "=="));
                        i += 2;
                    }
                    else
                    {
                        tokens.Add(new(TokenType.Assignment, "="));
                        i++;
                    }
                    continue;
                case '!':
                    if (i + 1 < input.Length && input[i + 1] == '=')
                    {
                        tokens.Add(new(TokenType.NotEquals, "!="));
                        i += 2;
                    }
                    else
                    {
                        tokens.Add(new(TokenType.Unknown, c.ToString()));
                        i++;
                    }
                    continue;
            }

            if (char.IsLetter(c))
            {
                int start = i;

                while (i < input.Length && char.IsLetterOrDigit(input[i]))
                {
                    i++;
                }

                string value = input[start..i];

                TokenType type = Keywords.Contains(value)
                    ? TokenType.Keyword
                    : TokenType.Identifier;

                tokens.Add(new(type, value));
                continue;
            }

            if (char.IsDigit(c))
            {
                int start = i;

                while (i < input.Length && char.IsDigit(input[i]))
                {
                    i++;
                }

                string value = input[start..i];
                tokens.Add(new(TokenType.IntegerLiteral, value));
                continue;
            }

            tokens.Add(new(TokenType.Unknown, c.ToString()));
            i++;
        }

        return tokens;
    }
}
</file>

<file path="main.c">
int main() {
    // A simple test for if-else statements
    int a = 5;
    int b = 10;
    int result = 0;

    // Test 1: Simple if
    if (a < b) {
        print(1); // Should print 1
    }

    // Test 2: if-else
    if (a > b) {
        print(999); // Should not print
    } else {
        print(2); // Should print 2
    }

    // Test 3: Chained conditions modifying a variable
    if (a == 5) {
        result = 100;
    } else {
        result = 200;
    }

    if (b != 10) {
        result = result + 1;
    } else {
        result = result + 5;
    }

    print(result); // Should print 105

    while (1) { }

    return result; // Should return 105
}
</file>

