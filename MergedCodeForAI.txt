<file path="Ast.cs">
using System.Collections.Generic;

namespace CTilde;

public enum AccessSpecifier { Public, Private }

// Base classes
public abstract record AstNode
{
    public AstNode? Parent { get; set; }
}
public abstract record StatementNode : AstNode;
public abstract record ExpressionNode : AstNode;

// Program structure
public record ImportDirectiveNode(string LibraryName) : AstNode;
public record MemberVariableNode(Token Type, int PointerLevel, Token Name, AccessSpecifier AccessLevel) : AstNode;
public record StructDefinitionNode(string Name, List<MemberVariableNode> Members) : AstNode;
public record ProgramNode(List<ImportDirectiveNode> Imports, List<StructDefinitionNode> Structs, List<FunctionDeclarationNode> Functions) : AstNode;
public record ParameterNode(Token Type, int PointerLevel, Token Name) : AstNode;
public record FunctionDeclarationNode(Token ReturnType, int ReturnPointerLevel, string Name, List<ParameterNode> Parameters, StatementNode? Body, string? OwnerStructName, AccessSpecifier AccessLevel) : AstNode;

// Statements
public record BlockStatementNode(List<StatementNode> Statements) : StatementNode;
public record ReturnStatementNode(ExpressionNode? Expression) : StatementNode;
public record WhileStatementNode(ExpressionNode Condition, StatementNode Body) : StatementNode;
public record IfStatementNode(ExpressionNode Condition, StatementNode ThenBody, StatementNode? ElseBody) : StatementNode;
public record DeclarationStatementNode(Token Type, int PointerLevel, Token Identifier, ExpressionNode? Initializer) : StatementNode;
public record ExpressionStatementNode(ExpressionNode Expression) : StatementNode;


// Expressions
public record InitializerListExpressionNode(List<ExpressionNode> Values) : ExpressionNode;
public record IntegerLiteralNode(int Value) : ExpressionNode;
public record StringLiteralNode(string Value, string Label) : ExpressionNode;
public record UnaryExpressionNode(Token Operator, ExpressionNode Right) : ExpressionNode;
public record AssignmentExpressionNode(ExpressionNode Left, ExpressionNode Right) : ExpressionNode;
public record VariableExpressionNode(Token Identifier) : ExpressionNode;
public record CallExpressionNode(ExpressionNode Callee, List<ExpressionNode> Arguments) : ExpressionNode;
public record BinaryExpressionNode(ExpressionNode Left, Token Operator, ExpressionNode Right) : ExpressionNode;
public record MemberAccessExpressionNode(ExpressionNode Left, Token Operator, Token Member) : ExpressionNode;
</file>

<file path="Parser.cs">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

namespace CTilde;

public class Parser
{
    private readonly List<Token> _tokens;
    private int _position;
    private int _stringLabelCounter;

    public Parser(List<Token> tokens)
    {
        _tokens = tokens;
        _position = 0;
    }

    private Token Current => _position < _tokens.Count ? _tokens[_position] : new(TokenType.Unknown, string.Empty);
    private Token Peek(int offset) => _position + offset < _tokens.Count ? _tokens[_position + offset] : new(TokenType.Unknown, string.Empty);

    private Token Eat(TokenType expectedType)
    {
        var currentToken = Current;
        if (currentToken.Type == expectedType)
        {
            _position++;
            return currentToken;
        }
        throw new InvalidOperationException($"Expected token {expectedType} but got {currentToken.Type} ('{currentToken.Value}') at position {_position}");
    }

    public ProgramNode Parse()
    {
        var imports = new List<ImportDirectiveNode>();
        var structs = new List<StructDefinitionNode>();
        var functions = new List<FunctionDeclarationNode>();

        while (Current.Type != TokenType.Unknown)
        {
            if (Current.Type == TokenType.Hash)
            {
                imports.Add(ParseImportDirective());
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "struct")
            {
                structs.Add(ParseStructDefinition(functions));
            }
            else
            {
                functions.Add(ParseGlobalFunction());
            }
        }

        var programNode = new ProgramNode(imports, structs, functions);
        SetParents(programNode);
        return programNode;
    }

    private ImportDirectiveNode ParseImportDirective()
    {
        Eat(TokenType.Hash);
        var keyword = Eat(TokenType.Identifier);
        if (keyword.Value != "import") throw new InvalidOperationException($"Expected 'import' after '#' but got '{keyword.Value}'");
        var libNameToken = Eat(TokenType.StringLiteral);
        return new ImportDirectiveNode(libNameToken.Value);
    }

    private StructDefinitionNode ParseStructDefinition(List<FunctionDeclarationNode> programFunctions)
    {
        Eat(TokenType.Keyword); // struct
        var structName = Eat(TokenType.Identifier);
        Eat(TokenType.LeftBrace);

        var members = new List<MemberVariableNode>();
        var currentAccess = AccessSpecifier.Private; // Default for struct is private

        while (Current.Type != TokenType.RightBrace)
        {
            if (Current.Type == TokenType.Keyword && (Current.Value == "public" || Current.Value == "private"))
            {
                currentAccess = (Current.Value == "public") ? AccessSpecifier.Public : AccessSpecifier.Private;
                Eat(TokenType.Keyword);
                Eat(TokenType.Colon);
                continue;
            }

            var (type, pointerLevel) = ParseType();
            var name = Eat(TokenType.Identifier);

            if (Current.Type == TokenType.LeftParen)
            {
                // This is a method definition.
                var methodNode = FinishParsingFunction(type, pointerLevel, name.Value, structName.Value, currentAccess);
                programFunctions.Add(methodNode);
            }
            else
            {
                // This is a member variable.
                members.Add(new MemberVariableNode(type, pointerLevel, name, currentAccess));
                Eat(TokenType.Semicolon);
            }
        }

        Eat(TokenType.RightBrace);
        Eat(TokenType.Semicolon);
        return new StructDefinitionNode(structName.Value, members);
    }

    private void SetParents(AstNode node)
    {
        foreach (var property in node.GetType().GetProperties())
        {
            if (property.CanWrite && property.Name == "Parent") continue;
            if (property.GetValue(node) is AstNode child)
            {
                var parentProp = child.GetType().GetProperty("Parent");
                if (parentProp != null && parentProp.CanWrite) parentProp.SetValue(child, node);
                SetParents(child);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children.ToList()) // ToList to avoid mutation issues
                {
                    var parentProp = c.GetType().GetProperty("Parent");
                    if (parentProp != null && parentProp.CanWrite) parentProp.SetValue(c, node);
                    SetParents(c);
                }
            }
        }
    }

    private (Token type, int pointerLevel) ParseType()
    {
        Token typeToken;
        if (Current.Type == TokenType.Keyword && Current.Value == "struct")
        {
            Eat(TokenType.Keyword); // struct
            typeToken = Eat(TokenType.Identifier);
        }
        else
        {
            // A type is a keyword (int, void, char) or an identifier (another struct name)
            typeToken = Current;
            _position++;
        }

        int pointerLevel = 0;
        while (Current.Type == TokenType.Star)
        {
            Eat(TokenType.Star);
            pointerLevel++;
        }
        return (typeToken, pointerLevel);
    }

    private FunctionDeclarationNode ParseGlobalFunction()
    {
        var (returnType, returnPointerLevel) = ParseType();
        var identifier = Eat(TokenType.Identifier);
        // Global functions are implicitly public
        return FinishParsingFunction(returnType, returnPointerLevel, identifier.Value, null, AccessSpecifier.Public);
    }

    private FunctionDeclarationNode FinishParsingFunction(Token returnType, int returnPointerLevel, string name, string? ownerStructName, AccessSpecifier accessLevel)
    {
        Eat(TokenType.LeftParen);

        var parameters = new List<ParameterNode>();
        if (Current.Type != TokenType.RightParen)
        {
            do
            {
                var (paramType, paramPointerLevel) = ParseType();
                var paramName = Eat(TokenType.Identifier);
                parameters.Add(new ParameterNode(paramType, paramPointerLevel, paramName));
            } while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
        }

        Eat(TokenType.RightParen);

        // If this is a method, prepend the implicit 'this' pointer to the parameter list.
        if (ownerStructName != null)
        {
            var thisParam = new ParameterNode(new Token(TokenType.Identifier, ownerStructName), 1, new Token(TokenType.Identifier, "this"));
            parameters.Insert(0, thisParam);
        }

        StatementNode? body = null;
        if (Current.Type == TokenType.LeftBrace)
        {
            body = ParseBlockStatement();
        }
        else
        {
            Eat(TokenType.Semicolon); // For function prototypes
        }

        return new FunctionDeclarationNode(returnType, returnPointerLevel, name, parameters, body, ownerStructName, accessLevel);
    }

    private BlockStatementNode ParseBlockStatement()
    {
        Eat(TokenType.LeftBrace);
        var statements = new List<StatementNode>();
        while (Current.Type != TokenType.RightBrace) statements.Add(ParseStatement());
        Eat(TokenType.RightBrace);
        return new BlockStatementNode(statements);
    }

    private StatementNode ParseStatement()
    {
        if (Current.Type == TokenType.Keyword)
        {
            switch (Current.Value)
            {
                case "return": return ParseReturnStatement();
                case "if": return ParseIfStatement();
                case "while": return ParseWhileStatement();
                case "int":
                case "char":
                case "struct":
                    return ParseDeclarationStatement();
            }
        }

        // `TypeName varName;` is a declaration.
        if (Current.Type == TokenType.Identifier && (Peek(1).Type == TokenType.Identifier || Peek(1).Type == TokenType.Star))
        {
            return ParseDeclarationStatement();
        }

        if (Current.Type == TokenType.LeftBrace) return ParseBlockStatement();

        var expression = ParseExpression();
        Eat(TokenType.Semicolon);
        return new ExpressionStatementNode(expression);
    }

    private IfStatementNode ParseIfStatement()
    {
        Eat(TokenType.Keyword);
        Eat(TokenType.LeftParen);
        var condition = ParseExpression();
        Eat(TokenType.RightParen);
        var thenBody = ParseStatement();
        StatementNode? elseBody = null;
        if (Current.Type == TokenType.Keyword && Current.Value == "else")
        {
            Eat(TokenType.Keyword);
            elseBody = ParseStatement();
        }
        return new IfStatementNode(condition, thenBody, elseBody);
    }

    private StatementNode ParseDeclarationStatement()
    {
        var (typeToken, pointerLevel) = ParseType();
        var identifier = Eat(TokenType.Identifier);
        ExpressionNode? initializer = null;
        if (Current.Type == TokenType.Assignment)
        {
            Eat(TokenType.Assignment);
            if (Current.Type == TokenType.LeftBrace)
            {
                initializer = ParseInitializerListExpression();
            }
            else
            {
                initializer = ParseExpression();
            }
        }
        Eat(TokenType.Semicolon);
        return new DeclarationStatementNode(typeToken, pointerLevel, identifier, initializer);
    }

    private ExpressionNode ParseInitializerListExpression()
    {
        Eat(TokenType.LeftBrace);
        var values = new List<ExpressionNode>();
        if (Current.Type != TokenType.RightBrace)
        {
            do
            {
                values.Add(ParseExpression());
            } while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
        }
        Eat(TokenType.RightBrace);
        return new InitializerListExpressionNode(values);
    }

    private WhileStatementNode ParseWhileStatement()
    {
        Eat(TokenType.Keyword);
        Eat(TokenType.LeftParen);
        var condition = ParseExpression();
        Eat(TokenType.RightParen);
        var body = ParseStatement();
        return new WhileStatementNode(condition, body);
    }

    private ReturnStatementNode ParseReturnStatement()
    {
        Eat(TokenType.Keyword);
        ExpressionNode? expression = null;
        if (Current.Type != TokenType.Semicolon) expression = ParseExpression();
        Eat(TokenType.Semicolon);
        return new ReturnStatementNode(expression);
    }

    private ExpressionNode ParseExpression() => ParseAssignmentExpression();

    private ExpressionNode ParseAssignmentExpression()
    {
        var left = ParseEqualityExpression();
        if (Current.Type == TokenType.Assignment)
        {
            Eat(TokenType.Assignment);
            var right = ParseAssignmentExpression();
            if (left is VariableExpressionNode or MemberAccessExpressionNode or UnaryExpressionNode) return new AssignmentExpressionNode(left, right);
            throw new InvalidOperationException($"Invalid assignment target: {left.GetType().Name}");
        }
        return left;
    }

    private ExpressionNode ParseEqualityExpression()
    {
        var left = ParseRelationalExpression();
        while (Current.Type is TokenType.DoubleEquals or TokenType.NotEquals)
        {
            var op = Current; _position++;
            var right = ParseRelationalExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseRelationalExpression()
    {
        var left = ParseAdditiveExpression();
        while (Current.Type is TokenType.LessThan or TokenType.GreaterThan)
        {
            var op = Current; _position++;
            var right = ParseAdditiveExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseAdditiveExpression()
    {
        var left = ParseMultiplicativeExpression();
        while (Current.Type is TokenType.Plus or TokenType.Minus)
        {
            var op = Current; _position++;
            var right = ParseMultiplicativeExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseMultiplicativeExpression()
    {
        var left = ParseUnaryExpression();
        while (Current.Type is TokenType.Star or TokenType.Slash)
        {
            var op = Current; _position++;
            var right = ParseUnaryExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseUnaryExpression()
    {
        if (Current.Type is TokenType.Minus or TokenType.Plus or TokenType.Star or TokenType.Ampersand)
        {
            var op = Current; _position++;
            return new UnaryExpressionNode(op, ParseUnaryExpression());
        }
        return ParsePostfixExpression();
    }

    private ExpressionNode ParsePostfixExpression()
    {
        var expr = ParsePrimaryExpression();

        while (true)
        {
            if (Current.Type == TokenType.LeftParen) // Call
            {
                Eat(TokenType.LeftParen);
                var arguments = new List<ExpressionNode>();
                if (Current.Type != TokenType.RightParen)
                {
                    do { arguments.Add(ParseExpression()); }
                    while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
                }
                Eat(TokenType.RightParen);
                expr = new CallExpressionNode(expr, arguments);
            }
            else if (Current.Type is TokenType.Dot or TokenType.Arrow) // Member access
            {
                var op = Current;
                _position++;
                var member = Eat(TokenType.Identifier);
                expr = new MemberAccessExpressionNode(expr, op, member);
            }
            else
            {
                break;
            }
        }

        return expr;
    }

    private ExpressionNode ParsePrimaryExpression()
    {
        if (Current.Type == TokenType.IntegerLiteral)
        {
            var token = Eat(TokenType.IntegerLiteral);
            if (int.TryParse(token.Value, out int v)) return new IntegerLiteralNode(v);
            throw new InvalidOperationException($"Could not parse int: {token.Value}");
        }
        if (Current.Type == TokenType.HexLiteral)
        {
            var token = Eat(TokenType.HexLiteral);
            var hex = token.Value.StartsWith("0x") ? token.Value.Substring(2) : token.Value;
            if (int.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int v)) return new IntegerLiteralNode(v);
            throw new InvalidOperationException($"Could not parse hex: {token.Value}");
        }
        if (Current.Type == TokenType.StringLiteral)
        {
            var token = Eat(TokenType.StringLiteral);
            return new StringLiteralNode(token.Value, $"str{_stringLabelCounter++}");
        }
        if (Current.Type == TokenType.Identifier) return new VariableExpressionNode(Eat(TokenType.Identifier));
        if (Current.Type == TokenType.LeftParen)
        {
            Eat(TokenType.LeftParen);
            var expr = ParseExpression();
            Eat(TokenType.RightParen);
            return expr;
        }
        throw new InvalidOperationException($"Unexpected expression token: {Current.Type}");
    }
}
</file>

<file path="Program.cs">
using System;
using System.IO;

namespace CTilde;

public class Program
{
    public static void Main(string[] args)
    {
        string code = File.ReadAllText("Output/main.c");

        // 1. Tokenize
        var tokens = Tokenizer.Tokenize(code);

        // 2. Parse
        var parser = new Parser(tokens);
        var ast = parser.Parse();

        // 3. Generate
        var generator = new CodeGenerator(ast);
        string asmCode = generator.Generate();

        // 4. Output
        File.WriteAllText("Output/output.asm", asmCode);
        Console.WriteLine("Compilation successful. Assembly code written to output.asm");
    }
}
</file>

<file path="Tokenizer.cs">
using System.Collections.Generic;
using System.Text;

namespace CTilde;

public enum TokenType
{
    Keyword,
    Identifier,
    IntegerLiteral,
    HexLiteral,
    StringLiteral,
    Semicolon,
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Comma,
    Dot,
    Hash,
    Assignment,
    Unknown,
    Plus,
    Minus,
    Star,
    Slash,
    DoubleEquals,
    NotEquals,
    LessThan,
    GreaterThan,
    Ampersand,
    Arrow,
    Colon
}

public record Token(TokenType Type, string Value);

public class Tokenizer
{
    private static readonly HashSet<string> Keywords =
    [
        "int",
        "void",
        "return",
        "while",
        "if",
        "else",
        "struct",
        "char",
        "public",
        "private"
    ];

    public static List<Token> Tokenize(string input)
    {
        List<Token> tokens = [];
        int i = 0;

        while (i < input.Length)
        {
            char c = input[i];

            if (char.IsWhiteSpace(c)) { i++; continue; }
            if (c == '/' && i + 1 < input.Length && input[i + 1] == '/') { while (i < input.Length && input[i] != '\n') i++; continue; }
            if (c == '"')
            {
                i++;
                var sb = new StringBuilder();
                while (i < input.Length && input[i] != '"')
                {
                    char current = input[i];
                    if (current == '\\' && i + 1 < input.Length)
                    {
                        i++;
                        switch (input[i])
                        {
                            case 'n': sb.Append('\n'); break;
                            case 't': sb.Append('\t'); break;
                            case '\\': sb.Append('\\'); break;
                            case '"': sb.Append('"'); break;
                            default: sb.Append('\\'); sb.Append(input[i]); break;
                        }
                    }
                    else sb.Append(current);
                    i++;
                }
                if (i < input.Length) i++;
                tokens.Add(new Token(TokenType.StringLiteral, sb.ToString()));
                continue;
            }

            switch (c)
            {
                case '#': tokens.Add(new(TokenType.Hash, "#")); i++; continue;
                case '.': tokens.Add(new(TokenType.Dot, ".")); i++; continue;
                case ':': tokens.Add(new(TokenType.Colon, ":")); i++; continue;
                case '(': tokens.Add(new(TokenType.LeftParen, "(")); i++; continue;
                case ')': tokens.Add(new(TokenType.RightParen, ")")); i++; continue;
                case '{': tokens.Add(new(TokenType.LeftBrace, "{")); i++; continue;
                case '}': tokens.Add(new(TokenType.RightBrace, "}")); i++; continue;
                case ';': tokens.Add(new(TokenType.Semicolon, ";")); i++; continue;
                case ',': tokens.Add(new(TokenType.Comma, ",")); i++; continue;
                case '+': tokens.Add(new(TokenType.Plus, "+")); i++; continue;
                case '-':
                    if (i + 1 < input.Length && input[i + 1] == '>') { tokens.Add(new(TokenType.Arrow, "->")); i += 2; }
                    else { tokens.Add(new(TokenType.Minus, "-")); i++; }
                    continue;
                case '*': tokens.Add(new(TokenType.Star, "*")); i++; continue;
                case '/': tokens.Add(new(TokenType.Slash, "/")); i++; continue;
                case '&': tokens.Add(new(TokenType.Ampersand, "&")); i++; continue;
                case '<': tokens.Add(new(TokenType.LessThan, "<")); i++; continue;
                case '>': tokens.Add(new(TokenType.GreaterThan, ">")); i++; continue;
                case '=':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.DoubleEquals, "==")); i += 2; }
                    else { tokens.Add(new(TokenType.Assignment, "=")); i++; }
                    continue;
                case '!':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.NotEquals, "!=")); i += 2; }
                    else { tokens.Add(new(TokenType.Unknown, c.ToString())); i++; }
                    continue;
            }

            if (c == '0' && i + 1 < input.Length && (input[i + 1] == 'x' || input[i + 1] == 'X'))
            {
                int start = i;
                i += 2;
                while (i < input.Length && "0123456789abcdefABCDEF".Contains(input[i])) i++;
                tokens.Add(new Token(TokenType.HexLiteral, input.Substring(start, i - start)));
                continue;
            }
            if (char.IsDigit(c))
            {
                int start = i;
                while (i < input.Length && char.IsDigit(input[i])) i++;
                tokens.Add(new(TokenType.IntegerLiteral, input.Substring(start, i - start)));
                continue;
            }
            if (char.IsLetter(c) || c == '_')
            {
                int start = i;
                while (i < input.Length && (char.IsLetterOrDigit(input[i]) || input[i] == '_')) i++;
                string value = input.Substring(start, i - start);
                tokens.Add(new(Keywords.Contains(value) ? TokenType.Keyword : TokenType.Identifier, value));
                continue;
            }
            tokens.Add(new(TokenType.Unknown, c.ToString()));
            i++;
        }
        tokens.Add(new(TokenType.Unknown, string.Empty));
        return tokens;
    }
}
</file>

<file path="Generator\AssemblyBuilder.cs">
using System.Text;

namespace CTilde;

public class AssemblyBuilder
{
    private readonly StringBuilder _sb = new();

    public void AppendDirective(string directive)
    {
        _sb.AppendLine(directive);
    }

    public void AppendLabel(string label)
    {
        _sb.AppendLine($"{label}:");
    }

    public void AppendInstruction(string? instruction, string? comment = null)
    {
        var line = instruction == null ? "" : $"    {instruction}";
        _sb.AppendLine(line.PadRight(35) + (comment == null ? "" : $"; {comment}"));
    }

    public void AppendData(string label, string value)
    {
        _sb.AppendLine($"    {label} db {value}");
    }

    public void AppendBlankLine()
    {
        _sb.AppendLine();
    }

    public override string ToString()
    {
        return _sb.ToString();
    }
}
</file>

<file path="Generator\CodeGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class CodeGenerator
{
    internal ProgramNode Program { get; }
    internal TypeManager TypeManager { get; }
    internal AssemblyBuilder Builder { get; } = new();

    private int _labelIdCounter;
    private readonly Dictionary<string, string> _stringLiterals = new();
    internal HashSet<string> ExternalFunctions { get; } = new();

    private readonly StatementGenerator _statementGenerator;
    internal ExpressionGenerator ExpressionGenerator { get; }

    internal SymbolTable CurrentSymbols { get; set; } = null!;
    internal string? CurrentMethodOwnerStruct { get; set; }

    public CodeGenerator(ProgramNode program)
    {
        Program = program;
        TypeManager = new TypeManager(program);

        ExpressionGenerator = new ExpressionGenerator(this);
        _statementGenerator = new StatementGenerator(this);
    }

    public string Generate()
    {
        FindAllStringLiterals(Program);
        foreach (var f in Program.Functions.Where(f => f.Body == null))
        {
            ExternalFunctions.Add(f.Name);
        }

        var fasmWriter = new FasmWriter();
        fasmWriter.WritePreamble(Builder);
        fasmWriter.WriteDataSection(Builder, _stringLiterals);
        fasmWriter.WriteTextSectionHeader(Builder);
        fasmWriter.WriteEntryPoint(Builder);

        foreach (var function in Program.Functions.Where(f => f.Body != null))
        {
            GenerateFunction(function);
            Builder.AppendBlankLine();
        }

        fasmWriter.WriteImportDataSection(Builder, Program, ExternalFunctions);

        return Builder.ToString();
    }

    internal int GetNextLabelId() => _labelIdCounter++;

    private void FindAllStringLiterals(AstNode node)
    {
        if (node is StringLiteralNode str && !_stringLiterals.ContainsValue(str.Value))
        {
            _stringLiterals.Add(str.Label, str.Value);
        }

        foreach (var property in node.GetType().GetProperties())
        {
            if (property.Name == "Parent") continue;

            if (property.GetValue(node) is AstNode child)
            {
                FindAllStringLiterals(child);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children)
                {
                    FindAllStringLiterals(c);
                }
            }
        }
    }

    private void GenerateFunction(FunctionDeclarationNode function)
    {
        CurrentMethodOwnerStruct = function.OwnerStructName;
        CurrentSymbols = new SymbolTable(function, TypeManager);

        string mangledName = function.OwnerStructName != null
            ? $"_{function.OwnerStructName}_{function.Name}"
            : $"_{function.Name}";

        Builder.AppendLabel(mangledName);
        Builder.AppendInstruction("push ebp");
        Builder.AppendInstruction("mov ebp, esp");
        Builder.AppendInstruction("push ebx", "Preserve non-volatile registers");
        Builder.AppendInstruction("push esi");
        Builder.AppendInstruction("push edi");
        Builder.AppendBlankLine();

        int totalLocalSize = CurrentSymbols.TotalLocalSize;
        if (totalLocalSize > 0)
        {
            Builder.AppendInstruction($"sub esp, {totalLocalSize}", "Allocate space for all local variables");
        }

        if (function.Body != null)
        {
            _statementGenerator.GenerateStatement(function.Body);
        }

        Builder.AppendBlankLine();
        Builder.AppendInstruction(null, "Implicit return cleanup");
        GenerateFunctionEpilogue();
    }

    internal void GenerateFunctionEpilogue()
    {
        Builder.AppendInstruction("pop edi");
        Builder.AppendInstruction("pop esi");
        Builder.AppendInstruction("pop ebx");
        Builder.AppendInstruction("mov esp, ebp");
        Builder.AppendInstruction("pop ebp");
        Builder.AppendInstruction("ret");
    }
}
</file>

<file path="Generator\ExpressionGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class ExpressionGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeManager TypeManager => _context.TypeManager;
    private ProgramNode Program => _context.Program;
    private SymbolTable CurrentSymbols => _context.CurrentSymbols;
    private string? CurrentMethodOwnerStruct => _context.CurrentMethodOwnerStruct;
    private HashSet<string> ExternalFunctions => _context.ExternalFunctions;

    public ExpressionGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public void GenerateLValueAddress(ExpressionNode expression)
    {
        switch (expression)
        {
            case VariableExpressionNode varExpr:
                {
                    if (CurrentSymbols.TryGetSymbol(varExpr.Identifier.Value, out var offset, out _))
                    {
                        string sign = offset > 0 ? "+" : "";
                        Builder.AppendInstruction($"lea eax, [ebp {sign} {offset}]", $"Get address of var/param {varExpr.Identifier.Value}");
                    }
                    else if (CurrentMethodOwnerStruct != null)
                    {
                        try
                        {
                            var (memberOffset, _) = TypeManager.GetMemberInfo(CurrentMethodOwnerStruct, varExpr.Identifier.Value);
                            CurrentSymbols.TryGetSymbol("this", out var thisOffset, out _);
                            Builder.AppendInstruction($"mov eax, [ebp + {thisOffset}]", "Get `this` pointer value");
                            if (memberOffset > 0)
                            {
                                Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for implicit this->{varExpr.Identifier.Value}");
                            }
                        }
                        catch (InvalidOperationException)
                        {
                            throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'");
                        }
                    }
                    else
                    {
                        throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'");
                    }
                    break;
                }
            case MemberAccessExpressionNode memberAccess:
                {
                    var leftType = TypeManager.GetExpressionType(memberAccess.Left, CurrentSymbols, CurrentMethodOwnerStruct);
                    string baseStructType = leftType.EndsWith("*") ? leftType.Substring(0, leftType.Length - 1) : leftType;

                    var structDef = Program.Structs.First(s => s.Name == baseStructType);
                    var memberVar = structDef.Members.FirstOrDefault(m => m.Name.Value == memberAccess.Member.Value);
                    if (memberVar == null) throw new InvalidOperationException($"Struct '{baseStructType}' has no member '{memberAccess.Member.Value}'");

                    if (memberVar.AccessLevel == AccessSpecifier.Private && CurrentMethodOwnerStruct != baseStructType)
                    {
                        throw new InvalidOperationException($"Cannot access private member '{baseStructType}::{memberAccess.Member.Value}' from context '{CurrentMethodOwnerStruct ?? "global"}'.");
                    }

                    if (memberAccess.Operator.Type == TokenType.Dot)
                    {
                        GenerateLValueAddress(memberAccess.Left);
                    }
                    else
                    {
                        GenerateExpression(memberAccess.Left);
                    }

                    var (memberOffset, _) = TypeManager.GetMemberInfo(baseStructType, memberAccess.Member.Value);
                    if (memberOffset > 0)
                    {
                        Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for member {memberAccess.Operator.Value}{memberAccess.Member.Value}");
                    }
                    break;
                }
            case UnaryExpressionNode u when u.Operator.Type == TokenType.Star:
                GenerateExpression(u.Right);
                break;
            default: throw new InvalidOperationException($"Expression '{expression.GetType().Name}' is not a valid L-value.");
        }
    }

    public void GenerateExpression(ExpressionNode expression)
    {
        switch (expression)
        {
            case IntegerLiteralNode literal: Builder.AppendInstruction($"mov eax, {literal.Value}"); break;
            case StringLiteralNode str: Builder.AppendInstruction($"mov eax, {str.Label}"); break;
            case VariableExpressionNode varExpr:
                CurrentSymbols.TryGetSymbol(varExpr.Identifier.Value, out int offset, out _);
                if (offset > 0)
                {
                    var exprType = TypeManager.GetExpressionType(varExpr, CurrentSymbols, CurrentMethodOwnerStruct);
                    if (TypeManager.IsStruct(exprType))
                    {
                        Builder.AppendInstruction($"lea eax, [ebp + {offset}]");
                    }
                    else
                    {
                        if (TypeManager.GetSizeOfType(exprType) == 1) Builder.AppendInstruction($"movzx eax, byte [ebp + {offset}]");
                        else Builder.AppendInstruction($"mov eax, [ebp + {offset}]");
                    }
                }
                else
                {
                    GenerateLValueAddress(varExpr);
                    var type = TypeManager.GetExpressionType(varExpr, CurrentSymbols, CurrentMethodOwnerStruct);
                    if (TypeManager.GetSizeOfType(type) == 1) Builder.AppendInstruction("movzx eax, byte [eax]");
                    else Builder.AppendInstruction("mov eax, [eax]");
                }
                break;
            case UnaryExpressionNode u:
                if (u.Operator.Type == TokenType.Ampersand) GenerateLValueAddress(u.Right);
                else
                {
                    GenerateExpression(u.Right);
                    if (u.Operator.Type == TokenType.Minus) Builder.AppendInstruction("neg eax");
                    else if (u.Operator.Type == TokenType.Star)
                    {
                        var type = TypeManager.GetExpressionType(u, CurrentSymbols, CurrentMethodOwnerStruct);
                        if (TypeManager.GetSizeOfType(type) == 1) Builder.AppendInstruction("movzx eax, byte [eax]");
                        else Builder.AppendInstruction("mov eax, [eax]");
                    }
                }
                break;
            case MemberAccessExpressionNode m:
                GenerateLValueAddress(m);
                var memberType = TypeManager.GetExpressionType(m, CurrentSymbols, CurrentMethodOwnerStruct);
                if (TypeManager.GetSizeOfType(memberType) == 1) Builder.AppendInstruction("movzx eax, byte [eax]");
                else Builder.AppendInstruction("mov eax, [eax]");
                break;
            case AssignmentExpressionNode assign:
                {
                    var lValueType = TypeManager.GetExpressionType(assign.Left, CurrentSymbols, CurrentMethodOwnerStruct);
                    var isStructAssign = TypeManager.IsStruct(lValueType);

                    if (isStructAssign)
                    {
                        GenerateLValueAddress(assign.Left);
                        Builder.AppendInstruction("push eax");
                        GenerateExpression(assign.Right);
                        Builder.AppendInstruction("pop edi");
                        Builder.AppendInstruction("mov esi, eax");

                        int size = TypeManager.GetSizeOfType(lValueType);
                        Builder.AppendInstruction($"mov ecx, {size / 4}");
                        Builder.AppendInstruction("rep movsd");
                        if (size % 4 > 0)
                        {
                            Builder.AppendInstruction($"mov ecx, {size % 4}");
                            Builder.AppendInstruction("rep movsb");
                        }
                    }
                    else
                    {
                        GenerateLValueAddress(assign.Left);
                        Builder.AppendInstruction("push eax");
                        GenerateExpression(assign.Right);
                        Builder.AppendInstruction("pop ecx");
                        if (TypeManager.GetSizeOfType(lValueType) == 1) Builder.AppendInstruction("mov [ecx], al");
                        else Builder.AppendInstruction("mov [ecx], eax");
                    }
                    break;
                }
            case BinaryExpressionNode binExpr: GenerateBinaryExpression(binExpr); break;
            case CallExpressionNode callExpr: GenerateCallExpression(callExpr); break;
            default: throw new NotImplementedException($"Expr: {expression.GetType().Name}");
        }
    }

    private void GenerateCallExpression(CallExpressionNode callExpr)
    {
        int totalArgSize = 0;
        string calleeTarget;

        foreach (var arg in callExpr.Arguments.AsEnumerable().Reverse())
        {
            var argType = TypeManager.GetExpressionType(arg, CurrentSymbols, CurrentMethodOwnerStruct);
            var isStruct = TypeManager.IsStruct(argType);

            if (isStruct)
            {
                int argSize = TypeManager.GetSizeOfType(argType);
                GenerateLValueAddress(arg);
                for (int offset = argSize - 4; offset >= 0; offset -= 4)
                {
                    Builder.AppendInstruction($"push dword [eax + {offset}]");
                }
                totalArgSize += argSize;
            }
            else
            {
                GenerateExpression(arg);
                Builder.AppendInstruction("push eax");
                totalArgSize += 4;
            }
        }

        if (callExpr.Callee is MemberAccessExpressionNode memberAccess)
        {
            var leftType = TypeManager.GetExpressionType(memberAccess.Left, CurrentSymbols, CurrentMethodOwnerStruct);
            var baseStructType = leftType.TrimEnd('*');
            var method = Program.Functions.First(f => f.OwnerStructName == baseStructType && f.Name == memberAccess.Member.Value);

            if (method.AccessLevel == AccessSpecifier.Private && CurrentMethodOwnerStruct != baseStructType)
                throw new InvalidOperationException($"Cannot access private method '{baseStructType}::{memberAccess.Member.Value}'.");

            GenerateLValueAddress(memberAccess.Left);
            Builder.AppendInstruction("push eax", "Push 'this' pointer");
            totalArgSize += 4;
            calleeTarget = $"_{baseStructType}_{memberAccess.Member.Value}";
        }
        else if (callExpr.Callee is VariableExpressionNode varNode)
        {
            string calleeName = varNode.Identifier.Value;
            calleeTarget = ExternalFunctions.Contains(calleeName) ? $"[{calleeName}]" : $"_{calleeName}";
        }
        else throw new NotSupportedException($"Unsupported callee type for call: {callExpr.Callee.GetType().Name}");

        Builder.AppendInstruction($"call {calleeTarget}");

        if (totalArgSize > 0) Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up args");
    }

    private void GenerateBinaryExpression(BinaryExpressionNode binExpr)
    {
        GenerateExpression(binExpr.Right);
        Builder.AppendInstruction("push eax");
        GenerateExpression(binExpr.Left);
        Builder.AppendInstruction("pop ecx");

        switch (binExpr.Operator.Type)
        {
            case TokenType.Plus: Builder.AppendInstruction("add eax, ecx"); break;
            case TokenType.Minus: Builder.AppendInstruction("sub eax, ecx"); break;
            case TokenType.Star: Builder.AppendInstruction("imul eax, ecx"); break;
            case TokenType.Slash: Builder.AppendInstruction("cdq"); Builder.AppendInstruction("idiv ecx"); break;
            case TokenType.DoubleEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("sete al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.NotEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setne al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.LessThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setl al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.GreaterThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setg al"); Builder.AppendInstruction("movzx eax, al"); break;
            default: throw new NotImplementedException($"Op: {binExpr.Operator.Type}");
        }
    }
}
</file>

<file path="Generator\FasmWriter.cs">
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CTilde;

public class FasmWriter
{
    public void WritePreamble(AssemblyBuilder builder)
    {
        builder.AppendDirective("format PE GUI 4.0");
        builder.AppendDirective("entry start");
        builder.AppendBlankLine();
        builder.AppendDirective("include 'win32a.inc'");
        builder.AppendBlankLine();
    }

    public void WriteDataSection(AssemblyBuilder builder, Dictionary<string, string> stringLiterals)
    {
        builder.AppendDirective("section '.data' data readable writeable");
        foreach (var (label, value) in stringLiterals)
        {
            builder.AppendData(label, FormatStringForFasm(value));
        }
        builder.AppendBlankLine();
    }

    public void WriteTextSectionHeader(AssemblyBuilder builder)
    {
        builder.AppendDirective("section '.text' code readable executable");
        builder.AppendBlankLine();
    }

    public void WriteEntryPoint(AssemblyBuilder builder)
    {
        builder.AppendLabel("start");
        builder.AppendInstruction("call _main");
        builder.AppendInstruction("mov ebx, eax");
        builder.AppendInstruction("push ebx");
        builder.AppendInstruction("call [ExitProcess]");
        builder.AppendBlankLine();
    }

    public void WriteImportDataSection(AssemblyBuilder builder, ProgramNode program, IEnumerable<string> externalFunctions)
    {
        builder.AppendDirective("section '.idata' import data readable");
        builder.AppendBlankLine();

        var libraries = new Dictionary<string, List<string>>
        {
            { "kernel32.dll", new List<string> { "ExitProcess" } },
            { "msvcrt.dll", new List<string> { "printf" } }
        };

        foreach (var import in program.Imports)
        {
            if (!libraries.ContainsKey(import.LibraryName)) libraries[import.LibraryName] = new List<string>();
        }

        foreach (var funcName in externalFunctions)
        {
            bool found = false;
            foreach (var import in program.Imports)
            {
                if (import.LibraryName != "kernel32.dll" && import.LibraryName != "msvcrt.dll")
                {
                    libraries[import.LibraryName].Add(funcName);
                    found = true;
                    break;
                }
            }
            if (!found && funcName != "printf")
            {
                if (!libraries.ContainsKey("user32.dll")) libraries["user32.dll"] = new List<string>();
                if (!libraries["user32.dll"].Contains(funcName)) libraries["user32.dll"].Add(funcName);
            }
        }

        var libDefs = libraries.Keys.Select(lib => $"{lib.Split('.')[0]},'{lib}'");
        builder.AppendDirective($"    library {string.Join(", ", libDefs)}");
        builder.AppendBlankLine();

        foreach (var (libName, functions) in libraries)
        {
            if (functions.Count > 0)
            {
                var libAlias = libName.Split('.')[0];
                var importDefs = functions.Distinct().Select(f => $"{f},'{f}'");
                builder.AppendDirective($"    import {libAlias}, {string.Join(", ", importDefs)}");
            }
        }
    }

    private string FormatStringForFasm(string value)
    {
        var parts = new List<string>();
        var currentString = new StringBuilder();

        foreach (char c in value)
        {
            if (c is '\n' or '\t' or '\r' or '\'' or '"')
            {
                if (currentString.Length > 0)
                {
                    parts.Add($"'{currentString}'");
                    currentString.Clear();
                }
                parts.Add(((byte)c).ToString());
            }
            else currentString.Append(c);
        }

        if (currentString.Length > 0) parts.Add($"'{currentString}'");
        parts.Add("0");
        return string.Join(", ", parts);
    }
}
</file>

<file path="Generator\StatementGenerator.cs">
using System;
using System.Linq;

namespace CTilde;

public class StatementGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeManager TypeManager => _context.TypeManager;
    private ProgramNode Program => _context.Program;
    private SymbolTable CurrentSymbols => _context.CurrentSymbols;
    private ExpressionGenerator ExpressionGenerator => _context.ExpressionGenerator;

    public StatementGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public void GenerateStatement(StatementNode statement)
    {
        switch (statement)
        {
            case ReturnStatementNode ret: GenerateReturn(ret); break;
            case BlockStatementNode block: foreach (var s in block.Statements) GenerateStatement(s); break;
            case WhileStatementNode w: GenerateWhile(w); break;
            case IfStatementNode i: GenerateIf(i); break;
            case DeclarationStatementNode decl:
                if (decl.Initializer != null)
                {
                    if (decl.Initializer is InitializerListExpressionNode initList)
                    {
                        string typeName = TypeManager.GetTypeName(decl.Type, decl.PointerLevel);
                        if (!TypeManager.IsStruct(typeName))
                            throw new InvalidOperationException($"Initializer list can only be used for struct types, not '{typeName}'.");

                        var structDef = Program.Structs.First(s => s.Name == typeName);

                        if (initList.Values.Count > structDef.Members.Count)
                            throw new InvalidOperationException($"Too many values in initializer list for struct '{structDef.Name}'.");

                        CurrentSymbols.TryGetSymbol(decl.Identifier.Value, out var structBaseOffset, out _);
                        int currentMemberOffset = 0;

                        for (int j = 0; j < initList.Values.Count; j++)
                        {
                            var member = structDef.Members[j];
                            var valueExpr = initList.Values[j];

                            var memberTypeName = TypeManager.GetTypeName(member.Type, member.PointerLevel);
                            var memberSize = TypeManager.GetSizeOfType(memberTypeName);
                            var totalOffset = structBaseOffset + currentMemberOffset;

                            ExpressionGenerator.GenerateExpression(valueExpr);
                            if (memberSize == 1) Builder.AppendInstruction($"mov byte [ebp + {totalOffset}], al", $"Init member {member.Name.Value}");
                            else Builder.AppendInstruction($"mov dword [ebp + {totalOffset}], eax", $"Init member {member.Name.Value}");

                            currentMemberOffset += memberSize;
                        }
                    }
                    else
                    {
                        var left = new VariableExpressionNode(decl.Identifier);
                        var assignment = new AssignmentExpressionNode(left, decl.Initializer);
                        ExpressionGenerator.GenerateExpression(assignment);
                    }
                }
                break;
            case ExpressionStatementNode exprStmt: ExpressionGenerator.GenerateExpression(exprStmt.Expression); break;
            default: throw new NotImplementedException($"Stmt: {statement.GetType().Name}");
        }
    }

    private void GenerateReturn(ReturnStatementNode ret)
    {
        if (ret.Expression != null) ExpressionGenerator.GenerateExpression(ret.Expression);
        _context.GenerateFunctionEpilogue();
    }

    private void GenerateWhile(WhileStatementNode w)
    {
        int i = _context.GetNextLabelId();
        Builder.AppendLabel($"_while_start_{i}");
        ExpressionGenerator.GenerateExpression(w.Condition);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction($"je _while_end_{i}");
        GenerateStatement(w.Body);
        Builder.AppendInstruction($"jmp _while_start_{i}");
        Builder.AppendLabel($"_while_end_{i}");
    }

    private void GenerateIf(IfStatementNode i)
    {
        int idx = _context.GetNextLabelId();
        ExpressionGenerator.GenerateExpression(i.Condition);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction(i.ElseBody != null ? $"je _if_else_{idx}" : $"je _if_end_{idx}");
        GenerateStatement(i.ThenBody);
        if (i.ElseBody != null)
        {
            Builder.AppendInstruction($"jmp _if_end_{idx}");
            Builder.AppendLabel($"_if_else_{idx}");
            GenerateStatement(i.ElseBody);
        }
        Builder.AppendLabel($"_if_end_{idx}");
    }
}
</file>

<file path="Generator\SymbolTable.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class SymbolTable
{
    private readonly Dictionary<string, (int Offset, string Type)> _symbols = new();

    public int TotalLocalSize { get; }

    public SymbolTable(FunctionDeclarationNode function, TypeManager typeManager)
    {
        // Pre-calculate space for all local variables
        TotalLocalSize = 0;
        if (function.Body is BlockStatementNode bodyBlock)
        {
            TotalLocalSize = bodyBlock.Statements
                .OfType<DeclarationStatementNode>()
                .Sum(d => typeManager.GetSizeOfType(typeManager.GetTypeName(d.Type, d.PointerLevel)));
        }

        // Map parameter offsets (positive on stack frame)
        int currentParamOffset = 8;
        foreach (var param in function.Parameters)
        {
            var typeName = typeManager.GetTypeName(param.Type, param.PointerLevel);
            _symbols[param.Name.Value] = (currentParamOffset, typeName);
            // Arguments on the stack are at least 4 bytes aligned.
            currentParamOffset += Math.Max(4, typeManager.GetSizeOfType(typeName));
        }

        // Map local variable offsets (negative on stack frame)
        int currentLocalOffset = 0;
        if (function.Body is BlockStatementNode block)
        {
            foreach (var stmt in block.Statements.OfType<DeclarationStatementNode>())
            {
                var typeName = typeManager.GetTypeName(stmt.Type, stmt.PointerLevel);
                int size = typeManager.GetSizeOfType(typeName);
                currentLocalOffset -= size;
                _symbols[stmt.Identifier.Value] = (currentLocalOffset, typeName);
            }
        }
    }

    public bool TryGetSymbol(string name, out int offset, out string type)
    {
        if (_symbols.TryGetValue(name, out var symbol))
        {
            offset = symbol.Offset;
            type = symbol.Type;
            return true;
        }

        offset = 0;
        type = string.Empty;
        return false;
    }
}
</file>

<file path="Generator\TypeManager.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CTilde;

public class TypeManager
{
    private readonly ProgramNode _program;
    private readonly Dictionary<string, StructDefinitionNode> _structs;

    public TypeManager(ProgramNode program)
    {
        _program = program;
        _structs = program.Structs.ToDictionary(s => s.Name);
    }

    public string GetTypeName(Token type, int pointerLevel)
    {
        var sb = new StringBuilder(type.Value);
        for (int i = 0; i < pointerLevel; i++) sb.Append('*');
        return sb.ToString();
    }

    public int GetSizeOfType(string typeName)
    {
        if (typeName.EndsWith("*")) return 4; // Pointers are 4 bytes
        if (typeName == "int") return 4;
        if (typeName == "char") return 1;

        if (_structs.TryGetValue(typeName, out var structDef))
        {
            return structDef.Members.Sum(m => GetSizeOfType(GetTypeName(m.Type, m.PointerLevel)));
        }

        throw new InvalidOperationException($"Unknown type '{typeName}' for size calculation.");
    }

    public bool IsStruct(string typeName) => _structs.ContainsKey(typeName.TrimEnd('*'));

    public (int offset, string type) GetMemberInfo(string structName, string memberName)
    {
        if (!_structs.TryGetValue(structName, out var structDef))
            throw new InvalidOperationException($"Undefined struct '{structName}'");

        int offset = 0;
        foreach (var member in structDef.Members)
        {
            if (member.Name.Value == memberName)
            {
                return (offset, GetTypeName(member.Type, member.PointerLevel));
            }
            offset += GetSizeOfType(GetTypeName(member.Type, member.PointerLevel));
        }
        throw new InvalidOperationException($"Struct '{structName}' has no member '{memberName}'");
    }

    public string GetExpressionType(ExpressionNode expr, SymbolTable symbols, string? currentMethodOwnerStruct)
    {
        switch (expr)
        {
            case IntegerLiteralNode: return "int";
            case StringLiteralNode: return "char*";
            case VariableExpressionNode v:
                if (symbols.TryGetSymbol(v.Identifier.Value, out _, out var type))
                {
                    return type;
                }
                if (currentMethodOwnerStruct != null)
                {
                    try
                    {
                        var (_, memberType) = GetMemberInfo(currentMethodOwnerStruct, v.Identifier.Value);
                        return memberType;
                    }
                    catch (InvalidOperationException) { /* Fall through */ }
                }
                throw new InvalidOperationException($"Cannot determine type for undefined variable '{v.Identifier.Value}'.");

            case AssignmentExpressionNode a: return GetExpressionType(a.Left, symbols, currentMethodOwnerStruct);

            case MemberAccessExpressionNode m:
                {
                    var leftType = GetExpressionType(m.Left, symbols, currentMethodOwnerStruct);
                    string baseStructType = leftType.TrimEnd('*');
                    var (_, memberType) = GetMemberInfo(baseStructType, m.Member.Value);
                    return memberType;
                }

            case UnaryExpressionNode u when u.Operator.Type == TokenType.Ampersand:
                return GetExpressionType(u.Right, symbols, currentMethodOwnerStruct) + "*";

            case UnaryExpressionNode u when u.Operator.Type == TokenType.Star:
                {
                    var operandType = GetExpressionType(u.Right, symbols, currentMethodOwnerStruct);
                    if (!operandType.EndsWith("*")) throw new InvalidOperationException($"Cannot dereference non-pointer type '{operandType}'.");
                    return operandType.Substring(0, operandType.Length - 1);
                }

            case CallExpressionNode call:
                {
                    string funcName;
                    string? ownerName = null;
                    if (call.Callee is VariableExpressionNode v)
                    {
                        funcName = v.Identifier.Value;
                    }
                    else if (call.Callee is MemberAccessExpressionNode m)
                    {
                        funcName = m.Member.Value;
                        ownerName = GetExpressionType(m.Left, symbols, currentMethodOwnerStruct).TrimEnd('*');
                    }
                    else throw new InvalidOperationException("Cannot determine return type of complex call expression.");

                    var func = _program.Functions.FirstOrDefault(f => f.Name == funcName && f.OwnerStructName == ownerName);
                    if (func == null) throw new InvalidOperationException($"Function '{funcName}' not found.");

                    return GetTypeName(func.ReturnType, func.ReturnPointerLevel);
                }

            case BinaryExpressionNode: return "int"; // Simple for now

            default: throw new NotImplementedException($"GetExpressionType not implemented for {expr.GetType().Name}");
        }
    }
}
</file>

<file path="main.c">
#import "raylib.dll"

int main() 
{
    int screenWidth = 800;
    int screenHeight = 600;

    Color rayWhite = {245, 245, 245, 255};
    Color maroon = {190, 33, 55, 255};

    TextObject myText;
    // Initialize the object using its public method.
    // Direct access like `myText.x = 140;` would fail because x is private.
    myText.init(140, 275, "Encapsulation!", 20, maroon);

    InitWindow(screenWidth, screenHeight, "CTilde with Access Specifiers!");

    while (WindowShouldClose() == 0) 
    {
        BeginDrawing();
        ClearBackground(rayWhite);
        
        myText.move_right();
        myText.draw();
        
        EndDrawing();
    }

    CloseWindow();
    
    return 0;
}
</file>

<file path="raylib.c">
struct Color 
{
    char r;
    char g;
    char b;
    char a;
};

void InitWindow(int width, int height, int title);
int WindowShouldClose();
void BeginDrawing();
void EndDrawing();
void ClearBackground(Color color);
void DrawText(int text, int posX, int posY, int fontSize, Color color);
void CloseWindow();
</file>

<file path="text_object.c">
struct TextObject 
{
private:
    int x;

public:
    int y;
    int text;
    int fontSize;
    Color color;

    void init(int startX, int startY, int newText, int fSize, Color newColor) 
    {
        x = startX;
        y = startY;
        text = newText;
        fontSize = fSize;
        color = newColor;
    }

    void draw() 
    {
        DrawText(text, x, y, fontSize, color);
    }
    
    void move_right() 
    {
        x = x + 1;
    }
};
</file>

