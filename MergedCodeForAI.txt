<file path="Compiler.cs">
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using CTilde.Diagnostics;

namespace CTilde;

public class Compiler
{
    public void Compile(string entryFilePath)
    {
        // 1. Discover all source files from #includes
        var preprocessor = new Preprocessor();
        var allFiles = preprocessor.DiscoverDependencies(entryFilePath);

        // 2. Parse each file into a CompilationUnit
        var compilationUnits = new List<CompilationUnitNode>();
        var allImports = new List<ImportDirectiveNode>();
        var allDiagnostics = new List<Diagnostic>();
        var sourceFileCache = new Dictionary<string, string[]>();

        foreach (var file in allFiles)
        {
            var code = File.ReadAllText(file);
            sourceFileCache[file] = code.Split('\n');

            var tokens = Tokenizer.Tokenize(code);
            var parser = new Parser(tokens);
            var unit = parser.Parse(file);

            allDiagnostics.AddRange(parser.Diagnostics);

            var importsInFile = parser.GetImports();
            allImports.AddRange(importsInFile);

            compilationUnits.Add(unit);
        }

        var programNode = new ProgramNode(allImports.DistinctBy(i => i.LibraryName).ToList(), compilationUnits);

        // 3. Create analysis services ONCE
        var typeRepository = new TypeRepository(programNode);
        var monomorphizer = new Monomorphizer(typeRepository);
        var typeResolver = new TypeResolver(typeRepository, monomorphizer);
        monomorphizer.SetResolver(typeResolver); // Break circular dependency
        var vtableManager = new VTableManager(typeRepository, typeResolver);
        var memoryLayoutManager = new MemoryLayoutManager(typeRepository, typeResolver, vtableManager);
        var functionResolver = new FunctionResolver(typeRepository, typeResolver, programNode);
        var semanticAnalyzer = new SemanticAnalyzer(typeRepository, typeResolver, functionResolver, memoryLayoutManager);
        functionResolver.SetSemanticAnalyzer(semanticAnalyzer); // Break circular dependency

        // 4. Perform Semantic Analysis
        var runner = new SemanticAnalyzerRunner(programNode, typeRepository, typeResolver, functionResolver, memoryLayoutManager, semanticAnalyzer);
        runner.Analyze();

        allDiagnostics.AddRange(runner.Diagnostics);

        // --- Print all diagnostics, but only fail on errors ---
        if (allDiagnostics.Any())
        {
            var printer = new DiagnosticPrinter(allDiagnostics, sourceFileCache);
            printer.Print();

            var errorCount = allDiagnostics.Count(d => d.Severity == DiagnosticSeverity.Error);
            if (errorCount > 0)
            {
                Console.WriteLine($"\nCompilation failed with {errorCount} error(s).");
                return;
            }
        }

        // 5. Generate Code
        var generator = new CodeGenerator(programNode, typeRepository, typeResolver, functionResolver, vtableManager, memoryLayoutManager, semanticAnalyzer);
        string asmCode = generator.Generate();

        // 6. Output
        File.WriteAllText("Output/output.asm", asmCode);
        Console.WriteLine("Compilation successful. Assembly code written to output.asm");
    }
}
</file>

<file path="Preprocessor.cs">
namespace CTilde;

public class Preprocessor
{
    public List<string> DiscoverDependencies(string entryFilePath)
    {
        var allFiles = new List<string>();
        var processedFiles = new HashSet<string>();
        var filesToProcess = new Queue<string>();

        filesToProcess.Enqueue(Path.GetFullPath(entryFilePath));

        while (filesToProcess.Count > 0)
        {
            var currentFile = filesToProcess.Dequeue();
            if (!File.Exists(currentFile) || processedFiles.Contains(currentFile))
            {
                continue;
            }

            processedFiles.Add(currentFile);
            allFiles.Add(currentFile);

            string directory = Path.GetDirectoryName(currentFile) ?? "";

            foreach (var line in File.ReadLines(currentFile))
            {
                var trimmedLine = line.Trim();
                if (trimmedLine.StartsWith("#include"))
                {
                    var startIndex = trimmedLine.IndexOf('"');
                    var endIndex = trimmedLine.LastIndexOf('"');
                    if (startIndex != -1 && endIndex > startIndex)
                    {
                        var includeFileName = trimmedLine.Substring(startIndex + 1, endIndex - startIndex - 1);
                        var fullIncludePath = Path.GetFullPath(Path.Combine(directory, includeFileName));
                        filesToProcess.Enqueue(fullIncludePath);
                    }
                }
            }
        }

        // The order matters for parsing: dependencies should come first.
        // We reverse because the entry point was added first.
        allFiles.Reverse();
        return allFiles;
    }
}
</file>

<file path="Program.cs">
using System;

namespace CTilde;

public class Program
{
    public static void Main(string[] args)
    {
        var compiler = new Compiler();
        compiler.Compile("Output/main.c");
    }
}
</file>

<file path="Analysis\AnalysisContext.cs">
namespace CTilde;

public record AnalysisContext(
    SymbolTable Symbols,
    CompilationUnitNode CompilationUnit,
    FunctionDeclarationNode CurrentFunction
);
</file>

<file path="Analysis\AstCloner.cs">
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

/// <summary>
/// A visitor that performs a deep clone of an AST subtree.
/// It can replace TypeNodes on the fly based on a provided dictionary.
/// </summary>
public class AstCloner
{
    private readonly Dictionary<string, TypeNode> _replacements;

    public AstCloner(Dictionary<string, TypeNode> replacements)
    {
        _replacements = replacements;
    }

    public T Clone<T>(T? node) where T : AstNode
    {
        if (node == null) return null!;
        return (T)Visit((dynamic)node);
    }

    private AstNode Visit(AstNode node) => node; // Fallback for unknown nodes

    private TypeNode Visit(TypeNode node)
    {
        // This is the core substitution logic
        if (node is SimpleTypeNode stn && _replacements.TryGetValue(stn.TypeToken.Value, out var replacement))
        {
            return Clone(replacement); // Clone the replacement to ensure the new tree is fully independent
        }

        // Standard cloning for other TypeNodes
        return node switch
        {
            SimpleTypeNode s => new SimpleTypeNode(s.TypeToken),
            PointerTypeNode p => new PointerTypeNode(Visit(p.BaseType)),
            GenericInstantiationTypeNode g => new GenericInstantiationTypeNode(g.BaseType, g.TypeArguments.Select(Visit).ToList()),
            _ => throw new System.NotImplementedException($"Clone not implemented for TypeNode: {node.GetType().Name}")
        };
    }

    // --- Expression Nodes ---
    private ExpressionNode Visit(ExpressionNode node)
    {
        return node switch
        {
            InitializerListExpressionNode il => new InitializerListExpressionNode(il.OpeningBrace, il.Values.Select(Clone).ToList()),
            IntegerLiteralNode i => i, // Immutable
            StringLiteralNode s => s, // Immutable
            UnaryExpressionNode u => new UnaryExpressionNode(u.Operator, Clone(u.Right)),
            AssignmentExpressionNode a => new AssignmentExpressionNode(Clone(a.Left), Clone(a.Right)),
            VariableExpressionNode v => new VariableExpressionNode(v.Identifier),
            CallExpressionNode c => new CallExpressionNode(Clone(c.Callee), c.Arguments.Select(Clone).ToList()),
            BinaryExpressionNode b => new BinaryExpressionNode(Clone(b.Left), b.Operator, Clone(b.Right)),
            MemberAccessExpressionNode ma => new MemberAccessExpressionNode(Clone(ma.Left), ma.Operator, ma.Member),
            QualifiedAccessExpressionNode qa => new QualifiedAccessExpressionNode(Clone(qa.Left), qa.Member),
            NewExpressionNode n => new NewExpressionNode(Visit(n.Type), n.Arguments.Select(Clone).ToList()),
            SizeofExpressionNode s => new SizeofExpressionNode(s.SizeofToken, Visit(s.Type)),
            _ => throw new System.NotImplementedException($"Clone not implemented for ExpressionNode: {node.GetType().Name}")
        };
    }

    // --- Statement Nodes ---
    private StatementNode Visit(StatementNode node)
    {
        return node switch
        {
            BlockStatementNode b => new BlockStatementNode(b.Statements.Select(Clone).ToList()),
            ReturnStatementNode r => new ReturnStatementNode(Clone(r.Expression)),
            WhileStatementNode w => new WhileStatementNode(Clone(w.Condition), Clone(w.Body)),
            IfStatementNode i => new IfStatementNode(Clone(i.Condition), Clone(i.ThenBody), Clone(i.ElseBody)),
            DeclarationStatementNode d => new DeclarationStatementNode(d.IsConst, Visit(d.Type), d.Identifier, Clone(d.Initializer), d.ConstructorArguments?.Select(Clone).ToList()),
            ExpressionStatementNode e => new ExpressionStatementNode(Clone(e.Expression)),
            DeleteStatementNode del => new DeleteStatementNode(Clone(del.Expression)),
            _ => throw new System.NotImplementedException($"Clone not implemented for StatementNode: {node.GetType().Name}")
        };
    }

    // --- Top Level & Definitions ---
    public StructDefinitionNode Visit(StructDefinitionNode node)
    {
        return new StructDefinitionNode(
            node.Name,
            node.GenericParameters, // These are kept for now and cleared in the Monomorphizer
            node.BaseStructName,
            node.Namespace,
            node.Members.Select(Clone).ToList(),
            node.Methods.Select(Clone).ToList(),
            node.Constructors.Select(Clone).ToList(),
            node.Destructors.Select(Clone).ToList()
        );
    }

    private MemberVariableNode Visit(MemberVariableNode node) => new(node.IsConst, Visit(node.Type), node.Name, node.AccessLevel);
    private ParameterNode Visit(ParameterNode node) => new(Visit(node.Type), node.Name);
    private BaseInitializerNode Visit(BaseInitializerNode node) => new(node.Arguments.Select(Clone).ToList());

    private FunctionDeclarationNode Visit(FunctionDeclarationNode node)
    {
        return new FunctionDeclarationNode(
            Visit(node.ReturnType),
            node.Name,
            node.Parameters.Select(Clone).ToList(),
            Clone(node.Body),
            node.OwnerStructName,
            node.AccessLevel,
            node.IsVirtual,
            node.IsOverride,
            node.Namespace
        );
    }

    private ConstructorDeclarationNode Visit(ConstructorDeclarationNode node)
    {
        return new ConstructorDeclarationNode(
            node.OwnerStructName,
            node.Namespace,
            node.AccessLevel,
            node.Parameters.Select(Clone).ToList(),
            Clone(node.Initializer),
            Clone(node.Body)
        );
    }

    private DestructorDeclarationNode Visit(DestructorDeclarationNode node)
    {
        return new DestructorDeclarationNode(
            node.OwnerStructName,
            node.Namespace,
            node.AccessLevel,
            node.IsVirtual,
            Clone(node.Body)
        );
    }
}
</file>

<file path="Analysis\FunctionResolver.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class FunctionResolver
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;
    private readonly ProgramNode _program; // For accessing all functions
    private SemanticAnalyzer _semanticAnalyzer = null!;

    public FunctionResolver(TypeRepository typeRepository, TypeResolver typeResolver, ProgramNode program)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
        _program = program;
    }

    public void SetSemanticAnalyzer(SemanticAnalyzer analyzer) => _semanticAnalyzer = analyzer;

    public FunctionDeclarationNode ResolveFunctionCall(ExpressionNode callee, AnalysisContext analysisContext)
    {
        var currentFunction = analysisContext.CurrentFunction;
        var context = analysisContext.CompilationUnit;

        if (callee is MemberAccessExpressionNode ma)
        {
            var ownerTypeFqn = _semanticAnalyzer.AnalyzeExpressionType(ma.Left, analysisContext).TrimEnd('*');
            var method = ResolveMethod(ownerTypeFqn, ma.Member.Value);
            return method ?? throw new InvalidOperationException($"Method '{ma.Member.Value}' not found on type '{ownerTypeFqn}'.");
        }

        if (callee is VariableExpressionNode varNode)
        {
            // If inside a method, first try resolving as an implicit 'this' call.
            if (currentFunction?.OwnerStructName != null)
            {
                var ownerFqn = _typeRepository.GetFullyQualifiedOwnerName(currentFunction);
                if (ownerFqn != null)
                {
                    var method = ResolveMethod(ownerFqn, varNode.Identifier.Value);
                    if (method != null)
                    {
                        return method;
                    }
                }
            }
            // Fallback to global/namespaced function resolution.
            return ResolveFunctionByName(varNode.Identifier.Value, currentFunction?.Namespace, context);
        }

        if (callee is QualifiedAccessExpressionNode qNode)
        {
            string qualifier = TypeResolver.ResolveQualifier(qNode.Left);
            var funcName = qNode.Member.Value;
            string? resolvedNamespace = qualifier;
            var aliased = context.Usings.FirstOrDefault(u => u.Alias == qualifier);
            if (aliased != null) resolvedNamespace = aliased.Namespace;

            var globalFunctions = _program.CompilationUnits.SelectMany(cu => cu.Functions);
            var func = globalFunctions.FirstOrDefault(f => f.OwnerStructName == null && f.Namespace == resolvedNamespace && f.Name == funcName);
            if (func == null) throw new InvalidOperationException($"Function '{resolvedNamespace}::{funcName}' not found.");
            return func;
        }
        throw new NotSupportedException($"Unsupported callee type for resolution: {callee.GetType().Name}");
    }

    private FunctionDeclarationNode ResolveFunctionByName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        var globalFunctions = _program.CompilationUnits.SelectMany(cu => cu.Functions);
        var candidates = globalFunctions.Where(f => f.OwnerStructName == null && f.Name == name)
            .Where(f => f.Namespace == currentNamespace || f.Namespace == null || context.Usings.Any(u => u.Alias == null && u.Namespace == f.Namespace)).ToList();
        if (candidates.Count == 0) throw new InvalidOperationException($"Function '{name}' could not be resolved in the current context.");
        if (candidates.Select(f => f.Namespace).Distinct().Count() > 1) throw new InvalidOperationException($"Function call '{name}' is ambiguous.");
        return candidates.First();
    }

    public FunctionDeclarationNode? ResolveMethod(string ownerFqn, string name)
    {
        var structFqn = ownerFqn;
        while (structFqn != null)
        {
            var structDef = _typeRepository.FindStruct(structFqn);
            if (structDef == null) return null; // Should not happen if ownerFqn is valid

            var method = structDef.Methods.FirstOrDefault(m => m.Name == name);
            if (method != null) return method;

            if (string.IsNullOrEmpty(structDef.BaseStructName)) break;

            var unit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, structDef.BaseStructName, -1, -1));
            structFqn = _typeResolver.ResolveType(baseTypeNode, structDef.Namespace, unit);
        }
        return null;
    }

    public FunctionDeclarationNode? FindMethod(string structFqn, string methodName)
    {
        var structDef = _typeRepository.FindStruct(structFqn);
        return structDef?.Methods.FirstOrDefault(m => m.Name == methodName);
    }

    public ConstructorDeclarationNode? FindConstructor(string structFqn, List<string> argTypeFqns)
    {
        var structDef = _typeRepository.FindStruct(structFqn);
        if (structDef == null) return null;

        var ctorUnit = _typeRepository.GetCompilationUnitForStruct(structFqn);

        foreach (var ctor in structDef.Constructors)
        {
            if (ctor.Parameters.Count != argTypeFqns.Count) continue;

            bool allParamsMatch = true;
            for (int i = 0; i < argTypeFqns.Count; i++)
            {
                var param = ctor.Parameters[i];
                var resolvedParamType = _typeResolver.ResolveType(param.Type, ctor.Namespace, ctorUnit);

                string argumentType = argTypeFqns[i];
                bool isMatch = resolvedParamType == argumentType;

                if (!isMatch && resolvedParamType == "char" && argumentType == "int")
                {
                    isMatch = true;
                }

                // Allow assigning an int (from malloc) to any pointer type
                if (!isMatch && argumentType == "int" && resolvedParamType.EndsWith("*"))
                {
                    isMatch = true;
                }

                if (!isMatch)
                {
                    allParamsMatch = false;
                    break;
                }
            }

            if (allParamsMatch) return ctor;
        }

        return null;
    }

    public DestructorDeclarationNode? FindDestructor(string fqn)
    {
        var structDef = _typeRepository.FindStruct(fqn);
        return structDef?.Destructors.FirstOrDefault();
    }

    public int? GetEnumValue(string enumFQN, string memberName)
    {
        var ed = _typeRepository.FindEnum(enumFQN);
        return ed?.Members.FirstOrDefault(m => m.Name.Value == memberName)?.Value;
    }

    public int? ResolveUnqualifiedEnumMember(string memberName, CompilationUnitNode context, string? currentContextNamespace)
    {
        var namespacesToCheck = new List<string?> { currentContextNamespace }
            .Concat(context.Usings.Where(u => u.Alias == null).Select(u => u.Namespace))
            .Append(null);

        foreach (var ns in namespacesToCheck.Distinct())
        {
            foreach (var enumDef in _typeRepository.GetAllEnums().Where(e => e.Namespace == ns))
            {
                if (enumDef.Members.Any(m => m.Name.Value == memberName))
                {
                    return GetEnumValue(TypeRepository.GetFullyQualifiedName(enumDef), memberName);
                }
            }
        }
        return null;
    }
}
</file>

<file path="Analysis\Monomorphizer.cs">
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CTilde;

public class Monomorphizer
{
    private readonly TypeRepository _typeRepository;
    private TypeResolver _typeResolver = null!; // Set via SetResolver to break circular dependency
    private readonly Dictionary<string, StructDefinitionNode> _instantiationCache = new();

    public Monomorphizer(TypeRepository typeRepository)
    {
        _typeRepository = typeRepository;
    }

    public void SetResolver(TypeResolver resolver)
    {
        _typeResolver = resolver;
    }

    public StructDefinitionNode Instantiate(GenericInstantiationTypeNode typeNode, string? currentNamespace, CompilationUnitNode contextForResolution)
    {
        // 1. Resolve the base generic type (e.g., 'List' -> 'std::List')
        var templateFqn = _typeResolver.ResolveSimpleTypeName(typeNode.BaseType.Value, currentNamespace, contextForResolution);
        var templateStruct = _typeRepository.FindStruct(templateFqn) ?? throw new System.InvalidOperationException($"Generic template '{templateFqn}' not found.");
        var templateUnit = _typeRepository.GetCompilationUnitForStruct(templateFqn);

        // 2. Resolve all type arguments
        var resolvedArgNodes = typeNode.TypeArguments.Select(arg =>
        {
            // Recursively resolve the type argument itself. This supports things like List<List<int>>.
            var argFqn = _typeResolver.ResolveType(arg, currentNamespace, contextForResolution);

            // We need a TypeNode representation of the resolved FQN.
            // This is a bit of a hack, but it works for now.
            var lastPart = argFqn.Split("::").Last();
            var pointerLevel = argFqn.Count(c => c == '*');
            var baseName = lastPart.TrimEnd('*');
            TypeNode resolvedArgNode = new SimpleTypeNode(new Token(TokenType.Identifier, baseName, -1, -1));
            for (int i = 0; i < pointerLevel; i++)
            {
                resolvedArgNode = new PointerTypeNode(resolvedArgNode);
            }
            return resolvedArgNode;

        }).ToList();

        // 3. Generate mangled name and check cache
        var mangledName = NameMangler.MangleGenericInstance(templateFqn, resolvedArgNodes);
        if (_instantiationCache.TryGetValue(mangledName, out var cachedStruct))
        {
            return cachedStruct;
        }

        // 4. Create replacement map for the cloner
        if (templateStruct.GenericParameters.Count != resolvedArgNodes.Count)
        {
            throw new System.InvalidOperationException($"Incorrect number of type arguments for generic type '{templateFqn}'.");
        }
        var replacements = new Dictionary<string, TypeNode>();
        for (int i = 0; i < templateStruct.GenericParameters.Count; i++)
        {
            var paramName = templateStruct.GenericParameters[i].Value;
            var concreteType = resolvedArgNodes[i];
            replacements[paramName] = concreteType;
        }

        // 5. Clone the template's AST, substituting generic parameters
        var cloner = new AstCloner(replacements);
        var clonedStruct = cloner.Clone(templateStruct);

        // 6. Update the cloned struct's name and clear its generic parameters and namespace.
        // The mangled name is now the FQN.
        var concreteStruct = clonedStruct with
        {
            Name = mangledName,
            Namespace = null,
            GenericParameters = new List<Token>()
        };

        // 6a. Update the owner name, namespace, and `this` parameter type on all nested members.
        var updatedMethods = concreteStruct.Methods.Select(m =>
        {
            // The first parameter of a method is always 'this'.
            var thisParam = m.Parameters.First();
            var newThisType = new PointerTypeNode(new SimpleTypeNode(new Token(TokenType.Identifier, mangledName, -1, -1)));
            var newThisParam = thisParam with { Type = newThisType };

            var newParams = new List<ParameterNode> { newThisParam };
            newParams.AddRange(m.Parameters.Skip(1));

            return m with
            {
                OwnerStructName = mangledName,
                Namespace = null,
                Parameters = newParams
            };
        }).ToList();

        var updatedConstructors = concreteStruct.Constructors
            .Select(c => c with { OwnerStructName = mangledName, Namespace = null })
            .ToList();
        var updatedDestructors = concreteStruct.Destructors
            .Select(d => d with { OwnerStructName = mangledName, Namespace = null })
            .ToList();

        concreteStruct = concreteStruct with
        {
            Methods = updatedMethods,
            Constructors = updatedConstructors,
            Destructors = updatedDestructors
        };


        // 7. Register the new struct with the TypeRepository and its compilation unit
        _typeRepository.RegisterInstantiatedStruct(concreteStruct, templateUnit);
        templateUnit.Structs.Add(concreteStruct); // Add to the original unit's list of structs

        // 8. Set parents for the new AST subtree
        var parser = new Parser(new List<Token>()); // Dummy parser for SetParents
        parser.SetParents(concreteStruct, templateUnit);


        // 9. Cache and return
        _instantiationCache[mangledName] = concreteStruct;
        return concreteStruct;
    }
}
</file>

<file path="Analysis\SemanticAnalyzer.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using CTilde.Diagnostics;

namespace CTilde;

public class SemanticAnalyzer
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;
    private readonly FunctionResolver _functionResolver;
    private readonly MemoryLayoutManager _memoryLayoutManager;

    public SemanticAnalyzer(TypeRepository typeRepository, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
        _functionResolver = functionResolver;
        _memoryLayoutManager = memoryLayoutManager;
    }

    // New overload for use during code generation.
    // No new diagnostics are expected at this stage. If any are found, it indicates
    // a compiler bug, so we throw an exception.
    public string AnalyzeExpressionType(ExpressionNode expr, AnalysisContext context)
    {
        var diagnostics = new List<Diagnostic>();
        var type = AnalyzeExpressionType(expr, context, diagnostics);
        if (diagnostics.Any())
        {
            throw new InvalidOperationException($"Internal Compiler Error: Unexpected semantic error during code generation: {diagnostics.First().Message}");
        }
        return type;
    }

    public string AnalyzeExpressionType(ExpressionNode expr, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        try
        {
            return expr switch
            {
                IntegerLiteralNode => "int",
                StringLiteralNode => "char*",
                SizeofExpressionNode => "int",
                VariableExpressionNode v => AnalyzeVariableExpression(v, context, diagnostics),
                AssignmentExpressionNode a => AnalyzeAssignmentExpression(a, context, diagnostics),
                MemberAccessExpressionNode ma => AnalyzeMemberAccessExpression(ma, context, diagnostics),
                UnaryExpressionNode u => AnalyzeUnaryExpression(u, context, diagnostics),
                CallExpressionNode c => AnalyzeCallExpression(c, context, diagnostics),
                QualifiedAccessExpressionNode q => AnalyzeQualifiedAccessExpression(q, context, diagnostics),
                NewExpressionNode n => AnalyzeNewExpression(n, context, diagnostics),
                BinaryExpressionNode bin => AnalyzeBinaryExpression(bin, context, diagnostics),
                InitializerListExpressionNode il => AnalyzeInitializerListExpression(il, context, diagnostics),
                _ => throw new NotImplementedException($"AnalyzeExpressionType not implemented for {expr.GetType().Name}")
            };
        }
        catch (InvalidOperationException ex)
        {
            // The logic below still relies on some exceptions for flow control.
            // We convert them to diagnostics here.
            var token = AstHelper.GetFirstToken(expr);
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, ex.Message, token.Line, token.Column));
            return "unknown"; // Return a sentinel type on error
        }
    }

    private string AnalyzeAssignmentExpression(AssignmentExpressionNode a, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        var leftType = AnalyzeExpressionType(a.Left, context, diagnostics);
        var rightType = AnalyzeExpressionType(a.Right, context, diagnostics);

        // Allow int to pointer conversion (for malloc etc)
        bool isIntToPointerConversion = leftType.EndsWith("*") && rightType == "int";
        // Allow int literal to char conversion
        bool isIntToCharLiteralConversion = leftType == "char" && rightType == "int" && a.Right is IntegerLiteralNode;
        // HACK: Allow assignments to/from a generic type parameter inside a monomorphized method.
        // This happens because the analyzer sometimes resolves a member to `T` and a parameter to `ConcreteType`.
        bool isGenericAssignment = (leftType.Length == 1 && char.IsUpper(leftType[0])) || (rightType.Length == 1 && char.IsUpper(rightType[0]));

        if (rightType != "unknown" && leftType != "unknown" && leftType != rightType && !isIntToPointerConversion && !isIntToCharLiteralConversion && !isGenericAssignment)
        {
            var token = AstHelper.GetFirstToken(a.Right);
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Cannot implicitly convert type '{rightType}' to '{leftType}'.", token.Line, token.Column));
        }

        return leftType; // Type of assignment is type of l-value
    }


    private string AnalyzeInitializerListExpression(InitializerListExpressionNode il, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        // This method is only called if an initializer list is used as a standalone expression,
        // which is illegal. AnalyzeDeclarationStatement handles the valid case directly.
        diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, "Initializer lists can only be used to initialize a variable.", il.OpeningBrace.Line, il.OpeningBrace.Column));
        return "unknown";
    }

    public void AnalyzeDeclarationStatement(DeclarationStatementNode decl, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        string declaredTypeFqn;
        try
        {
            declaredTypeFqn = _typeResolver.ResolveType(decl.Type, context.CurrentFunction.Namespace, context.CompilationUnit);
        }
        catch (InvalidOperationException ex)
        {
            var token = decl.Type.GetFirstToken();
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, ex.Message, token.Line, token.Column));
            declaredTypeFqn = "unknown"; // Sentinel type
        }

        if (declaredTypeFqn == "unknown") return; // Stop analysis if type resolution failed

        if (decl.Initializer is InitializerListExpressionNode il)
        {
            var structDef = _typeRepository.FindStruct(declaredTypeFqn);

            if (structDef == null)
            {
                var token = decl.Type.GetFirstToken();
                diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Type '{declaredTypeFqn}' is not a struct and cannot be initialized with an initializer list.", token.Line, token.Column));
                return;
            }

            var members = _memoryLayoutManager.GetAllMembers(declaredTypeFqn, context.CompilationUnit);
            if (il.Values.Count > members.Count)
            {
                diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Too many elements in initializer list for type '{structDef.Name}'.", il.OpeningBrace.Line, il.OpeningBrace.Column));
                // Continue to check existing members for other errors
            }

            for (int i = 0; i < Math.Min(il.Values.Count, members.Count); i++) // Only iterate up to min to avoid IndexOutOfRangeException on too many values
            {
                var member = members[i];
                var valueExpr = il.Values[i];
                var valueType = AnalyzeExpressionType(valueExpr, context, diagnostics);

                // Allow int literal to char conversion
                bool isIntToCharLiteralConversion =
                    valueType == "int" && member.type == "char" && valueExpr is IntegerLiteralNode;

                if (valueType != "unknown" && member.type != valueType && !isIntToCharLiteralConversion)
                {
                    var token = AstHelper.GetFirstToken(valueExpr);
                    diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Cannot initialize member '{member.name}' (type '{member.type}') with a value of type '{valueType}'.", token.Line, token.Column));
                }
            }
        }
        else if (decl.Initializer != null)
        {
            // Analyze other initializers (e.g., assignment)
            var initializerType = AnalyzeExpressionType(decl.Initializer, context, diagnostics);

            // Allow int literal to char conversion
            bool isIntToCharLiteralConversion = declaredTypeFqn == "char" && initializerType == "int" && decl.Initializer is IntegerLiteralNode;

            // Allow int to pointer conversion (for malloc etc)
            bool isIntToPointerConversion = declaredTypeFqn.EndsWith("*") && initializerType == "int";

            if (initializerType != "unknown" && declaredTypeFqn != initializerType && !isIntToCharLiteralConversion && !isIntToPointerConversion)
            {
                diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Cannot implicitly convert type '{initializerType}' to '{declaredTypeFqn}'.", AstHelper.GetFirstToken(decl.Initializer).Line, AstHelper.GetFirstToken(decl.Initializer).Column));
            }
        }
        else if (decl.ConstructorArguments != null)
        {
            foreach (var arg in decl.ConstructorArguments)
            {
                AnalyzeExpressionType(arg, context, diagnostics);
            }
            // TODO: Add constructor resolution and signature matching check here
        }
    }


    public string AnalyzeFunctionReturnType(FunctionDeclarationNode func, AnalysisContext context)
    {
        return _typeResolver.ResolveType(func.ReturnType, func.Namespace, context.CompilationUnit);
    }

    private string AnalyzeBinaryExpression(BinaryExpressionNode bin, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        var leftTypeFqn = AnalyzeExpressionType(bin.Left, context, diagnostics);
        var rightTypeFqn = AnalyzeExpressionType(bin.Right, context, diagnostics);

        if (leftTypeFqn == "unknown" || rightTypeFqn == "unknown") return "unknown";

        // Handle pointer arithmetic
        if (bin.Operator.Type is TokenType.Plus or TokenType.Minus)
        {
            if (leftTypeFqn.EndsWith("*") && rightTypeFqn == "int")
            {
                return leftTypeFqn; // e.g., char* + int -> char*
            }
            if (leftTypeFqn == "int" && rightTypeFqn.EndsWith("*") && bin.Operator.Type == TokenType.Plus)
            {
                return rightTypeFqn; // e.g., int + char* -> char*
            }
            // Pointer subtraction (ptr - ptr -> int)
            if (leftTypeFqn.EndsWith("*") && rightTypeFqn.EndsWith("*") && bin.Operator.Type == TokenType.Minus)
            {
                // TODO: Check if base types are compatible
                return "int";
            }
        }

        // Handle pointer comparisons
        if (bin.Operator.Type is TokenType.DoubleEquals or TokenType.NotEquals or TokenType.LessThan or TokenType.GreaterThan)
        {
            bool leftIsPtr = leftTypeFqn.EndsWith("*");
            bool rightIsPtr = rightTypeFqn.EndsWith("*");
            bool leftIsInt = leftTypeFqn == "int";
            bool rightIsInt = rightTypeFqn == "int";

            // Allow ptr <=> ptr and ptr <=> int
            if ((leftIsPtr && rightIsPtr) || (leftIsPtr && rightIsInt) || (leftIsInt && rightIsPtr))
            {
                return "int"; // Result of any comparison is an int.
            }
        }

        if (_typeRepository.IsStruct(leftTypeFqn))
        {
            try
            {
                var opName = $"operator_{NameMangler.MangleOperator(bin.Operator.Value)}";
                var overload = _functionResolver.ResolveMethod(leftTypeFqn, opName);

                if (overload != null)
                {
                    return AnalyzeFunctionReturnType(overload, context);
                }
            }
            catch (NotImplementedException)
            {
                // This operator is not overloadable.
            }
            // Error handling for missing operator overload
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Operator '{bin.Operator.Value}' is not defined for type '{leftTypeFqn}'.", bin.Operator.Line, bin.Operator.Column));
            return "unknown"; // Sentinel type
        }

        // For other primitive operations (int + int, comparisons, etc.), the result is always int.
        return "int";
    }

    private string AnalyzeNewExpression(NewExpressionNode n, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        string typeName;
        try
        {
            typeName = _typeResolver.ResolveType(n.Type, context.CurrentFunction.Namespace, context.CompilationUnit);
        }
        catch (InvalidOperationException ex)
        {
            var token = n.Type.GetFirstToken();
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, ex.Message, token.Line, token.Column));
            typeName = "unknown";
        }

        // 'new' can only be used with struct types, not primitives like 'int'
        if (n.Type is SimpleTypeNode stn && stn.TypeToken.Type == TokenType.Keyword)
        {
            var token = n.Type.GetFirstToken();
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"'new' cannot be used with primitive type '{stn.TypeToken.Value}'.", token.Line, token.Column));
            return "unknown";
        }

        // Analyze constructor arguments to mark variables as used and check for other errors.
        foreach (var arg in n.Arguments)
        {
            AnalyzeExpressionType(arg, context, diagnostics);
        }
        // TODO: Add constructor resolution and signature matching check here

        return typeName + "*";
    }

    private string AnalyzeVariableExpression(VariableExpressionNode v, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        // 1. Check local variables and parameters in the symbol table.
        if (context.Symbols.TryGetSymbol(v.Identifier.Value, out _, out var type, out _))
        {
            context.Symbols.MarkAsRead(v.Identifier.Value);
            return type;
        }

        // 2. Try resolving as an unqualified enum member (e.g., `KEY_D`).
        var unqualifiedEnumValue = _functionResolver.ResolveUnqualifiedEnumMember(v.Identifier.Value, context.CompilationUnit, context.CurrentFunction.Namespace);
        if (unqualifiedEnumValue.HasValue)
        {
            return "int";
        }

        // 3. If in a method, try resolving as an implicit `this->member`.
        if (context.CurrentFunction.OwnerStructName != null)
        {
            string ownerStructFqn = _typeRepository.GetFullyQualifiedOwnerName(context.CurrentFunction)!;

            // Walk up the inheritance chain to find the member
            string? currentStructFqn = ownerStructFqn;
            MemberVariableNode? member = null;
            StructDefinitionNode? definingStruct = null;

            while (currentStructFqn != null)
            {
                var structDef = _typeRepository.FindStruct(currentStructFqn);
                if (structDef == null) break;

                member = structDef.Members.FirstOrDefault(m => m.Name.Value == v.Identifier.Value);
                if (member != null)
                {
                    definingStruct = structDef;
                    break;
                }

                if (string.IsNullOrEmpty(structDef.BaseStructName)) break;

                var unit = _typeRepository.GetCompilationUnitForStruct(currentStructFqn);
                var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, structDef.BaseStructName, -1, -1));
                currentStructFqn = _typeResolver.ResolveType(baseTypeNode, structDef.Namespace, unit);
            }

            if (member != null && definingStruct != null)
            {
                context.Symbols.MarkAsRead("this");
                if (member.AccessLevel == AccessSpecifier.Private)
                {
                    if (context.CurrentFunction.OwnerStructName != definingStruct.Name || context.CurrentFunction.Namespace != definingStruct.Namespace)
                    {
                        diagnostics.Add(new Diagnostic(
                            context.CompilationUnit.FilePath,
                            $"Member '{definingStruct.Name}::{member.Name.Value}' is private and cannot be accessed from this context.",
                            v.Identifier.Line,
                            v.Identifier.Column
                        ));
                    }
                }
                var (_, memberTypeResolved) = _memoryLayoutManager.GetMemberInfo(ownerStructFqn, v.Identifier.Value, context.CompilationUnit);
                return memberTypeResolved;
            }
        }

        diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Cannot determine type for undefined variable '{v.Identifier.Value}'.", v.Identifier.Line, v.Identifier.Column));
        return "unknown"; // Sentinel value
    }

    private string AnalyzeMemberAccessExpression(MemberAccessExpressionNode ma, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        var leftType = AnalyzeExpressionType(ma.Left, context, diagnostics);
        if (leftType == "unknown") return "unknown";

        string baseStructType = leftType.TrimEnd('*');

        // Walk up the inheritance chain to find the member
        string? currentStructFqn = baseStructType;
        MemberVariableNode? member = null;
        StructDefinitionNode? definingStruct = null;

        while (currentStructFqn != null)
        {
            var structDef = _typeRepository.FindStruct(currentStructFqn);
            if (structDef == null)
            {
                // This case should be handled by the initial struct check
                diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Type '{baseStructType}' is not a struct and has no members.", AstHelper.GetFirstToken(ma.Left).Line, AstHelper.GetFirstToken(ma.Left).Column));
                return "unknown";
            }

            member = structDef.Members.FirstOrDefault(m => m.Name.Value == ma.Member.Value);
            if (member != null)
            {
                definingStruct = structDef;
                break;
            }

            if (string.IsNullOrEmpty(structDef.BaseStructName)) break;

            var unit = _typeRepository.GetCompilationUnitForStruct(currentStructFqn);
            var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, structDef.BaseStructName, -1, -1));
            currentStructFqn = _typeResolver.ResolveType(baseTypeNode, structDef.Namespace, unit);
        }

        if (member == null || definingStruct == null)
        {
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Struct '{baseStructType}' has no member named '{ma.Member.Value}'.", ma.Member.Line, ma.Member.Column));
            return "unknown";
        }

        // ** ENFORCE ACCESS SPECIFIER **
        if (member.AccessLevel == AccessSpecifier.Private)
        {
            // Access is allowed only if the current function is a method of the struct that DEFINED the member.
            if (context.CurrentFunction.OwnerStructName != definingStruct.Name || context.CurrentFunction.Namespace != definingStruct.Namespace)
            {
                diagnostics.Add(new Diagnostic(
                    context.CompilationUnit.FilePath,
                    $"Member '{definingStruct.Name}::{member.Name.Value}' is private and cannot be accessed from this context.",
                    ma.Member.Line,
                    ma.Member.Column
                ));
            }
        }

        var (_, resolvedMemberType) = _memoryLayoutManager.GetMemberInfo(baseStructType, ma.Member.Value, context.CompilationUnit);
        return resolvedMemberType;
    }

    private string AnalyzeUnaryExpression(UnaryExpressionNode u, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        if (u.Operator.Type == TokenType.Ampersand) // Address-of operator
        {
            var operandType = AnalyzeExpressionType(u.Right, context, diagnostics);
            if (operandType == "unknown") return "unknown";
            return operandType + "*";
        }

        if (u.Operator.Type == TokenType.Star) // Dereference operator
        {
            var operandType = AnalyzeExpressionType(u.Right, context, diagnostics);
            if (operandType == "unknown") return "unknown";
            if (!operandType.EndsWith("*"))
            {
                diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Cannot dereference non-pointer type '{operandType}'.", u.Operator.Line, u.Operator.Column));
                return "unknown";
            }
            return operandType[..^1]; // Remove one level of indirection
        }

        // For other unary operators like negation ('-'), the type does not change.
        return AnalyzeExpressionType(u.Right, context, diagnostics);
    }

    private string AnalyzeCallExpression(CallExpressionNode call, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        FunctionDeclarationNode? func = null;
        string funcNameForDiags;

        try
        {
            func = _functionResolver.ResolveFunctionCall(call.Callee, context);
            funcNameForDiags = func.Name;
        }
        catch (InvalidOperationException ex)
        {
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, ex.Message, AstHelper.GetFirstToken(call.Callee).Line, AstHelper.GetFirstToken(call.Callee).Column));
            return "unknown";
        }

        // ** ENFORCE ACCESS SPECIFIER FOR METHODS **
        if (func.OwnerStructName != null && func.AccessLevel == AccessSpecifier.Private)
        {
            var definingStructFqn = _typeRepository.GetFullyQualifiedOwnerName(func);
            var ownerFqn = _typeRepository.GetFullyQualifiedOwnerName(context.CurrentFunction);

            if (definingStructFqn != ownerFqn)
            {
                diagnostics.Add(new Diagnostic(
                   context.CompilationUnit.FilePath,
                   $"Method '{func.Name}' is private and cannot be accessed from this context.",
                   AstHelper.GetFirstToken(call.Callee).Line,
                   AstHelper.GetFirstToken(call.Callee).Column
               ));
            }
        }

        // ** VALIDATE ARGUMENT COUNT **
        int expectedArgs = func.OwnerStructName != null
            ? func.Parameters.Count - 1 // Don't count implicit 'this'
            : func.Parameters.Count;

        if (call.Arguments.Count != expectedArgs)
        {
            diagnostics.Add(new Diagnostic(
                context.CompilationUnit.FilePath,
                $"Wrong number of arguments for call to '{func.Name}'. Expected {expectedArgs}, but got {call.Arguments.Count}.",
                AstHelper.GetFirstToken(call).Line,
                AstHelper.GetFirstToken(call).Column
            ));
        }


        // Analyze arguments for their types
        foreach (var arg in call.Arguments)
        {
            AnalyzeExpressionType(arg, context, diagnostics);
        }

        // TODO: Validate argument types against function signature

        return AnalyzeFunctionReturnType(func, context);
    }

    private string AnalyzeQualifiedAccessExpression(QualifiedAccessExpressionNode q, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        string qualifier = TypeResolver.ResolveQualifier(q.Left);
        string memberName = q.Member.Value;

        // 1. Try to resolve as an enum member (e.g., raylib::KeyboardKey::KEY_D)
        string? enumTypeFQN = _typeResolver.ResolveEnumTypeName(qualifier, context.CurrentFunction.Namespace, context.CompilationUnit);
        if (enumTypeFQN != null)
        {
            if (_functionResolver.GetEnumValue(enumTypeFQN, memberName).HasValue)
            {
                return "int"; // Enum members are integers.
            }
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Enum '{qualifier}' (resolved to '{enumTypeFQN}') does not contain member '{memberName}'.", q.Member.Line, q.Member.Column));
            return "unknown";
        }

        // 2. Try to resolve as a qualified function (e.g., rl::InitWindow)
        // If it's not an enum, but a qualified *function* name, its type is effectively a function pointer.
        // We resolve it here, but its "type" for now is just void*.
        try
        {
            _functionResolver.ResolveFunctionCall(q, context);
            return "void*"; // Represents a function pointer type
        }
        catch (InvalidOperationException)
        {
            // Not an enum member, not a function. It's an error.
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Qualified access '{qualifier}::{memberName}' cannot be evaluated as a value directly. Only enum members or function calls are supported.", q.Member.Line, q.Member.Column));
            return "unknown";
        }
    }

    public void AnalyzeReturnStatement(ReturnStatementNode ret, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        var funcReturnType = AnalyzeFunctionReturnType(context.CurrentFunction, context);

        if (ret.Expression == null)
        {
            if (funcReturnType != "void")
            {
                var token = AstHelper.GetFirstToken(ret);
                diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Non-void function '{context.CurrentFunction.Name}' must return a value.", token.Line, token.Column));
            }
            return;
        }

        if (funcReturnType == "void")
        {
            var token = AstHelper.GetFirstToken(ret);
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Cannot return a value from void function '{context.CurrentFunction.Name}'.", token.Line, token.Column));
            return;
        }

        var exprType = AnalyzeExpressionType(ret.Expression, context, diagnostics);

        if (exprType != "unknown" && exprType != funcReturnType)
        {
            // Allow int to char conversion
            bool isIntToCharLiteralConversion = funcReturnType == "char" && exprType == "int" && ret.Expression is IntegerLiteralNode;
            // HACK: Allow returning a generic type T where a concrete type is expected (or vice versa)
            bool isGenericReturn = (funcReturnType.Length == 1 && char.IsUpper(funcReturnType[0])) || (exprType.Length == 1 && char.IsUpper(exprType[0]));

            if (!isIntToCharLiteralConversion && !isGenericReturn)
            {
                var token = AstHelper.GetFirstToken(ret.Expression);
                diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"Cannot implicitly convert return type '{exprType}' to '{funcReturnType}'.", token.Line, token.Column));
            }
        }
    }

    public void AnalyzeDeleteStatement(DeleteStatementNode deleteStmt, AnalysisContext context, List<Diagnostic> diagnostics)
    {
        var exprType = AnalyzeExpressionType(deleteStmt.Expression, context, diagnostics);
        if (exprType != "unknown" && !exprType.EndsWith("*"))
        {
            var token = AstHelper.GetFirstToken(deleteStmt.Expression);
            diagnostics.Add(new Diagnostic(context.CompilationUnit.FilePath, $"'delete' operator can only be applied to pointers, not type '{exprType}'.", token.Line, token.Column));
        }
    }
}
</file>

<file path="Analysis\SemanticAnalyzerRunner.cs">
using System.Collections.Generic;
using System.Linq;
using CTilde.Diagnostics;

namespace CTilde;

public class SemanticAnalyzerRunner
{
    private readonly ProgramNode _program;
    private readonly SemanticAnalyzer _analyzer;
    private readonly TypeResolver _typeResolver;
    private readonly FunctionResolver _functionResolver;
    private readonly MemoryLayoutManager _memoryLayoutManager;
    public List<Diagnostic> Diagnostics { get; } = new();

    public SemanticAnalyzerRunner(ProgramNode program, TypeRepository typeRepository, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager, SemanticAnalyzer analyzer)
    {
        _program = program;
        _analyzer = analyzer;
        _typeResolver = typeResolver;
        _functionResolver = functionResolver;
        _memoryLayoutManager = memoryLayoutManager;
    }

    public void Analyze()
    {
        // Iterate over a copy of the compilation units, as monomorphization might add new structs
        // to them, which in turn adds new methods that need analysis.
        // A more sophisticated approach might use a worklist, but this is simpler for now.
        bool changed;
        do
        {
            changed = false;
            var currentStructs = _program.CompilationUnits.SelectMany(cu => cu.Structs).ToList();

            foreach (var unit in _program.CompilationUnits.ToList())
            {
                foreach (var function in unit.Functions.ToList())
                {
                    if (function.Body == null) continue;
                    var symbols = new SymbolTable(function, _typeResolver, _functionResolver, _memoryLayoutManager, unit);
                    var context = new AnalysisContext(symbols, unit, function);
                    WalkStatement(function.Body, context);
                    CheckForUnusedVariables(function, context);
                }

                foreach (var s in unit.Structs.ToList())
                {
                    // If it's a generic template (e.g. struct List<T>), skip analysis.
                    // It will be monomorphized and analyzed on-demand when instantiated.
                    if (s.GenericParameters.Any())
                    {
                        continue;
                    }

                    foreach (var method in s.Methods.ToList())
                    {
                        if (method.Body == null) continue;
                        var symbols = new SymbolTable(method, _typeResolver, _functionResolver, _memoryLayoutManager, unit);
                        var context = new AnalysisContext(symbols, unit, method);
                        WalkStatement(method.Body, context);
                        CheckForUnusedVariables(method, context);
                    }
                    foreach (var ctor in s.Constructors.ToList())
                    {
                        var dummyFunctionForContext = new FunctionDeclarationNode(
                            new SimpleTypeNode(new Token(TokenType.Keyword, "void", -1, -1)), ctor.OwnerStructName,
                            ctor.Parameters, ctor.Body, ctor.OwnerStructName, ctor.AccessLevel,
                            false, false, ctor.Namespace
                        );
                        var symbols = new SymbolTable(ctor, _typeResolver, _functionResolver, _memoryLayoutManager, unit);
                        var context = new AnalysisContext(symbols, unit, dummyFunctionForContext);
                        WalkStatement(ctor.Body, context);
                        CheckForUnusedVariables(dummyFunctionForContext, context);
                    }
                    foreach (var dtor in s.Destructors.ToList())
                    {
                        var dummyFunctionForContext = new FunctionDeclarationNode(
                            new SimpleTypeNode(new Token(TokenType.Keyword, "void", -1, -1)), dtor.OwnerStructName,
                            new List<ParameterNode>(), dtor.Body, dtor.OwnerStructName, dtor.AccessLevel,
                            dtor.IsVirtual, false, dtor.Namespace
                        );
                        var symbols = new SymbolTable(dtor, _typeResolver, _functionResolver, _memoryLayoutManager, unit);
                        var context = new AnalysisContext(symbols, unit, dummyFunctionForContext);
                        WalkStatement(dtor.Body, context);
                        CheckForUnusedVariables(dummyFunctionForContext, context);
                    }
                }
            }

            var newStructs = _program.CompilationUnits.SelectMany(cu => cu.Structs).ToList();
            if (newStructs.Count > currentStructs.Count)
            {
                changed = true;
            }

        } while (changed);
    }

    private void CheckForUnusedVariables(FunctionDeclarationNode function, AnalysisContext context)
    {
        var localDeclarations = new List<DeclarationStatementNode>();
        if (function.Body != null)
        {
            FindAllDeclarations(function.Body, localDeclarations);
        }

        var unreadLocals = context.Symbols.GetUnreadLocals().Select(ul => ul.Name).ToHashSet();
        foreach (var decl in localDeclarations)
        {
            if (unreadLocals.Contains(decl.Identifier.Value))
            {
                Diagnostics.Add(new Diagnostic(
                    context.CompilationUnit.FilePath,
                    $"Unused variable '{decl.Identifier.Value}'.",
                    decl.Identifier.Line,
                    decl.Identifier.Column,
                    DiagnosticSeverity.Warning
                ));
            }
        }
    }

    private void FindAllDeclarations(StatementNode stmt, List<DeclarationStatementNode> declarations)
    {
        switch (stmt)
        {
            case DeclarationStatementNode d:
                declarations.Add(d);
                break;
            case BlockStatementNode b:
                foreach (var s in b.Statements) FindAllDeclarations(s, declarations);
                break;
            case IfStatementNode i:
                FindAllDeclarations(i.ThenBody, declarations);
                if (i.ElseBody != null) FindAllDeclarations(i.ElseBody, declarations);
                break;
            case WhileStatementNode w:
                FindAllDeclarations(w.Body, declarations);
                break;
        }
    }


    private void WalkStatement(StatementNode statement, AnalysisContext context, bool isReachable = true)
    {
        // Check for unreachable code first
        if (!isReachable)
        {
            var token = AstHelper.GetFirstToken(statement);
            // Don't flag closing braces as unreachable
            if (token.Type != TokenType.RightBrace)
            {
                Diagnostics.Add(new Diagnostic(
                    context.CompilationUnit.FilePath,
                    "Unreachable code detected.",
                    token.Line,
                    token.Column,
                    DiagnosticSeverity.Warning
                ));
            }
            return; // Do not process this statement further
        }

        switch (statement)
        {
            case BlockStatementNode block:
                bool blockIsReachable = true;
                foreach (var s in block.Statements)
                {
                    WalkStatement(s, context, blockIsReachable);
                    if (s is ReturnStatementNode) blockIsReachable = false;
                }
                break;
            case ExpressionStatementNode exprStmt:
                _analyzer.AnalyzeExpressionType(exprStmt.Expression, context, Diagnostics);
                break;
            case ReturnStatementNode retStmt:
                _analyzer.AnalyzeReturnStatement(retStmt, context, Diagnostics);
                break;
            case IfStatementNode ifStmt:
                _analyzer.AnalyzeExpressionType(ifStmt.Condition, context, Diagnostics);
                WalkStatement(ifStmt.ThenBody, context);
                if (ifStmt.ElseBody != null) WalkStatement(ifStmt.ElseBody, context);
                break;
            case WhileStatementNode whileStmt:
                _analyzer.AnalyzeExpressionType(whileStmt.Condition, context, Diagnostics);
                WalkStatement(whileStmt.Body, context);
                break;
            case DeclarationStatementNode decl:
                // Special handling for declarations since initializer lists are not standalone expressions.
                _analyzer.AnalyzeDeclarationStatement(decl, context, Diagnostics);
                break;
            case DeleteStatementNode deleteStmt:
                _analyzer.AnalyzeDeleteStatement(deleteStmt, context, Diagnostics);
                break;
        }
    }
}
</file>

<file path="Analysis\TypeResolver.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class TypeResolver
{
    private readonly TypeRepository _typeRepository;
    private readonly Monomorphizer _monomorphizer;

    public TypeResolver(TypeRepository typeRepository, Monomorphizer monomorphizer)
    {
        _typeRepository = typeRepository;
        _monomorphizer = monomorphizer;
    }

    public static string ResolveQualifier(ExpressionNode expr)
    {
        return expr switch
        {
            VariableExpressionNode v => v.Identifier.Value,
            QualifiedAccessExpressionNode q => $"{ResolveQualifier(q.Left)}::{q.Member.Value}",
            _ => throw new InvalidOperationException($"Cannot resolve qualifier from expression of type {expr.GetType().Name}")
        };
    }

    public string ResolveType(TypeNode node, string? currentNamespace, CompilationUnitNode context)
    {
        switch (node)
        {
            case PointerTypeNode ptn:
                return ResolveType(ptn.BaseType, currentNamespace, context) + "*";

            case GenericInstantiationTypeNode gitn:
                var concreteStruct = _monomorphizer.Instantiate(gitn, currentNamespace, context);
                return TypeRepository.GetFullyQualifiedName(concreteStruct);

            case SimpleTypeNode stn:
                return ResolveSimpleTypeName(stn.GetBaseTypeName(), currentNamespace, context);

            default:
                throw new NotImplementedException($"ResolveType not implemented for {node.GetType().Name}");
        }
    }

    public string ResolveSimpleTypeName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        if (name is "int" or "char" or "void")
        {
            return name;
        }

        // Heuristic: if a type name is a single uppercase char, assume it's a generic parameter
        // from an uninstantiated template, which shouldn't be resolved. Return its name directly.
        if (name.Length == 1 && char.IsUpper(name[0]))
        {
            return name;
        }

        if (name.Contains("::"))
        {
            var parts = name.Split("::");
            var nsPart = parts[0];
            var typeName = parts[1];
            var aliased = context.Usings.FirstOrDefault(u => u.Alias == nsPart);
            if (aliased != null)
            {
                var fqn = $"{aliased.Namespace}::{typeName}";
                return _typeRepository.FindStruct(fqn) != null ? fqn : throw new InvalidOperationException($"Type '{name}' with aliased namespace '{nsPart}' not found.");
            }
            return _typeRepository.FindStruct(name) != null ? name : throw new InvalidOperationException($"Type '{name}' not found.");
        }

        var candidates = new List<string>();
        if (currentNamespace != null)
        {
            var fqn = $"{currentNamespace}::{name}";
            if (_typeRepository.FindStruct(fqn) != null) candidates.Add(fqn);
        }
        foreach (var u in context.Usings.Where(u => u.Alias == null))
        {
            string fqn = $"{u.Namespace}::{name}";
            if (_typeRepository.FindStruct(fqn) != null) candidates.Add(fqn);
        }
        if (_typeRepository.FindStruct(name) != null) candidates.Add(name);

        if (candidates.Count == 0) throw new InvalidOperationException($"Type '{name}' could not be resolved in the current context.");
        if (candidates.Distinct().Count() > 1) throw new InvalidOperationException($"Type '{name}' is ambiguous between: {string.Join(", ", candidates.Distinct())}");
        return candidates.First();
    }

    public string? ResolveEnumTypeName(string name, string? currentNamespace, CompilationUnitNode context)
    {
        if (name.Contains("::"))
        {
            var parts = name.Split("::");
            var aliased = context.Usings.FirstOrDefault(u => u.Alias == parts[0]);
            var fqn = aliased != null ? $"{aliased.Namespace}::{parts[1]}" : name;
            return _typeRepository.FindEnum(fqn) != null ? fqn : null;
        }

        var namespacesToCheck = new List<string?> { currentNamespace }
            .Concat(context.Usings.Where(u => u.Alias == null).Select(u => u.Namespace))
            .Append(null);

        foreach (var ns in namespacesToCheck.Distinct())
        {
            var fqn = ns != null ? $"{ns}::{name}" : name;
            if (_typeRepository.FindEnum(fqn) != null) return fqn;
        }

        return null;
    }
}
</file>

<file path="Ast\Ast.cs">
using System.Collections.Generic;

namespace CTilde;

public enum AccessSpecifier { Public, Private }

// Base classes
public abstract record AstNode
{
    public AstNode? Parent { get; set; }

    public IEnumerable<AstNode> Ancestors()
    {
        var current = Parent;
        while (current != null)
        {
            yield return current;
            current = current.Parent;
        }
    }
}
public abstract record StatementNode : AstNode;
public abstract record ExpressionNode : AstNode;

// Program structure
public record ImportDirectiveNode(string LibraryName) : AstNode;
public record UsingDirectiveNode(string Namespace, string? Alias) : AstNode;
public record MemberVariableNode(bool IsConst, TypeNode Type, Token Name, AccessSpecifier AccessLevel) : AstNode;
public record StructDefinitionNode(string Name, List<Token> GenericParameters, string? BaseStructName, string? Namespace, List<MemberVariableNode> Members, List<FunctionDeclarationNode> Methods, List<ConstructorDeclarationNode> Constructors, List<DestructorDeclarationNode> Destructors) : AstNode;
public record ParameterNode(TypeNode Type, Token Name) : AstNode;
public record FunctionDeclarationNode(TypeNode ReturnType, string Name, List<ParameterNode> Parameters, StatementNode? Body, string? OwnerStructName, AccessSpecifier AccessLevel, bool IsVirtual, bool IsOverride, string? Namespace) : AstNode;
public record BaseInitializerNode(List<ExpressionNode> Arguments) : AstNode;
public record ConstructorDeclarationNode(string OwnerStructName, string? Namespace, AccessSpecifier AccessLevel, List<ParameterNode> Parameters, BaseInitializerNode? Initializer, StatementNode Body) : AstNode;
public record DestructorDeclarationNode(string OwnerStructName, string? Namespace, AccessSpecifier AccessLevel, bool IsVirtual, StatementNode Body) : AstNode;
public record EnumDefinitionNode(string Name, string? Namespace, List<EnumMemberNode> Members) : AstNode;
public record EnumMemberNode(Token Name, int Value) : AstNode;

// New top-level structure for compilation units
public record CompilationUnitNode(string FilePath, List<UsingDirectiveNode> Usings, List<StructDefinitionNode> Structs, List<FunctionDeclarationNode> Functions, List<EnumDefinitionNode> Enums) : AstNode;
public record ProgramNode(List<ImportDirectiveNode> Imports, List<CompilationUnitNode> CompilationUnits) : AstNode;


// Statements
public record BlockStatementNode(List<StatementNode> Statements) : StatementNode;
public record ReturnStatementNode(ExpressionNode? Expression) : StatementNode;
public record WhileStatementNode(ExpressionNode Condition, StatementNode Body) : StatementNode;
public record IfStatementNode(ExpressionNode Condition, StatementNode ThenBody, StatementNode? ElseBody) : StatementNode;
public record DeclarationStatementNode(bool IsConst, TypeNode Type, Token Identifier, ExpressionNode? Initializer, List<ExpressionNode>? ConstructorArguments) : StatementNode;
public record ExpressionStatementNode(ExpressionNode Expression) : StatementNode;
public record DeleteStatementNode(ExpressionNode Expression) : StatementNode;


// Expressions
public record InitializerListExpressionNode(Token OpeningBrace, List<ExpressionNode> Values) : ExpressionNode;
public record IntegerLiteralNode(Token Token, int Value) : ExpressionNode;
public record StringLiteralNode(Token Token, string Value, string Label) : ExpressionNode;
public record UnaryExpressionNode(Token Operator, ExpressionNode Right) : ExpressionNode;
public record AssignmentExpressionNode(ExpressionNode Left, ExpressionNode Right) : ExpressionNode;
public record VariableExpressionNode(Token Identifier) : ExpressionNode;
public record CallExpressionNode(ExpressionNode Callee, List<ExpressionNode> Arguments) : ExpressionNode;
public record BinaryExpressionNode(ExpressionNode Left, Token Operator, ExpressionNode Right) : ExpressionNode;
public record MemberAccessExpressionNode(ExpressionNode Left, Token Operator, Token Member) : ExpressionNode;
public record QualifiedAccessExpressionNode(ExpressionNode Left, Token Member) : ExpressionNode;
public record NewExpressionNode(TypeNode Type, List<ExpressionNode> Arguments) : ExpressionNode;
public record SizeofExpressionNode(Token SizeofToken, TypeNode Type) : ExpressionNode;
</file>

<file path="Ast\AstHelper.cs">
using System.Collections;
using System.Linq;

namespace CTilde;

public static class AstHelper
{
    public static Token GetFirstToken(AstNode node)
    {
        return node switch
        {
            IntegerLiteralNode n => n.Token,
            StringLiteralNode n => n.Token,
            VariableExpressionNode n => n.Identifier,
            UnaryExpressionNode n => n.Operator,
            InitializerListExpressionNode n => n.OpeningBrace,
            DeclarationStatementNode n => n.Type.GetFirstToken(),
            NewExpressionNode n => n.Type.GetFirstToken(),
            MemberAccessExpressionNode n => GetFirstToken(n.Left),
            _ => FindFirstTokenByReflection(node)
        };
    }

    private static Token FindFirstTokenByReflection(AstNode node)
    {
        var properties = node.GetType().GetProperties()
            .Where(p => p.Name != "Parent")
            .OrderBy(p => p.MetadataToken);

        foreach (var prop in properties)
        {
            var value = prop.GetValue(node);
            if (value is Token token) return token;
            if (value is AstNode childNode) return GetFirstToken(childNode);
            if (value is IEnumerable children and not string)
            {
                foreach (var child in children)
                {
                    if (child is AstNode innerChildNode) return GetFirstToken(innerChildNode);
                }
            }
        }
        return new Token(TokenType.Unknown, "", -1, -1);
    }
}
</file>

<file path="Ast\TypeNode.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public abstract record TypeNode : AstNode
{
    public abstract Token GetFirstToken();
    public abstract string GetBaseTypeName();
    public abstract int GetPointerLevel();
}

public record SimpleTypeNode(Token TypeToken) : TypeNode
{
    public override string ToString() => TypeToken.Value;
    public override Token GetFirstToken() => TypeToken;
    public override string GetBaseTypeName() => TypeToken.Value;
    public override int GetPointerLevel() => 0;
}

public record PointerTypeNode(TypeNode BaseType) : TypeNode
{
    public override string ToString() => $"{BaseType}*";
    public override Token GetFirstToken() => BaseType.GetFirstToken();
    public override string GetBaseTypeName() => BaseType.GetBaseTypeName();
    public override int GetPointerLevel() => BaseType.GetPointerLevel() + 1;
}

public record GenericInstantiationTypeNode(Token BaseType, List<TypeNode> TypeArguments) : TypeNode
{
    public override string ToString() => $"{BaseType.Value}<{string.Join(", ", TypeArguments.Select(a => a.ToString()))}>";
    public override Token GetFirstToken() => BaseType;
    public override string GetBaseTypeName() => BaseType.Value;
    public override int GetPointerLevel() => 0;
}
</file>

<file path="Diagnostics\Diagnostic.cs">
namespace CTilde.Diagnostics;

public record Diagnostic(string FilePath, string Message, int Line, int Column, DiagnosticSeverity Severity = DiagnosticSeverity.Error);
</file>

<file path="Diagnostics\DiagnosticPrinter.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde.Diagnostics;

public class DiagnosticPrinter
{
    private readonly IReadOnlyList<Diagnostic> _diagnostics;
    private readonly IReadOnlyDictionary<string, string[]> _sourceFiles;

    public DiagnosticPrinter(IReadOnlyList<Diagnostic> diagnostics, IReadOnlyDictionary<string, string[]> sourceFiles)
    {
        _diagnostics = diagnostics;
        _sourceFiles = sourceFiles;
    }

    public void Print()
    {
        foreach (var diagnostic in _diagnostics.OrderBy(d => d.FilePath).ThenBy(d => d.Line).ThenBy(d => d.Column))
        {
            // Fallback for cases where source isn't available or line number is invalid
            if (!_sourceFiles.TryGetValue(diagnostic.FilePath, out var lines) || diagnostic.Line < 1)
            {
                Console.Error.WriteLine($"Error: {diagnostic.FilePath}({diagnostic.Line},{diagnostic.Column}): {diagnostic.Message}");
                continue;
            }

            Console.Error.WriteLine(); // Blank line for separation

            ConsoleColor color;
            string prefix;
            switch (diagnostic.Severity)
            {
                case DiagnosticSeverity.Warning:
                    color = ConsoleColor.Yellow;
                    prefix = "Warning: ";
                    break;
                default: // Error
                    color = ConsoleColor.Red;
                    prefix = "Error: ";
                    break;
            }

            Console.ForegroundColor = color;
            Console.Error.Write(prefix);
            Console.ResetColor();
            Console.Error.WriteLine($"{diagnostic.Message}");

            Console.ForegroundColor = ConsoleColor.DarkGray;
            Console.Error.WriteLine($"  --> {diagnostic.FilePath}:{diagnostic.Line}:{diagnostic.Column}");
            Console.Error.WriteLine($"   |");

            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.Error.Write($"{diagnostic.Line,2} | ");
            Console.ResetColor();

            string line = lines[diagnostic.Line - 1];
            Console.Error.WriteLine(line);

            Console.ForegroundColor = ConsoleColor.DarkGray;
            Console.Error.Write($"   | ");
            Console.ForegroundColor = color;
            Console.Error.WriteLine(new string(' ', diagnostic.Column - 1) + "^");
            Console.ResetColor();
        }
    }
}
</file>

<file path="Diagnostics\DiagnosticSeverity.cs">
namespace CTilde.Diagnostics;

public enum DiagnosticSeverity
{
    Warning,
    Error
}
</file>

<file path="Generator\AssemblyBuilder.cs">
using System.Text;

namespace CTilde;

public class AssemblyBuilder
{
    private readonly StringBuilder _sb = new();

    public void AppendDirective(string directive)
    {
        _sb.AppendLine(directive);
    }

    public void AppendLabel(string label)
    {
        _sb.AppendLine($"{label}:");
    }

    public void AppendInstruction(string? instruction, string? comment = null)
    {
        string line = instruction is null 
            ? "" 
            : $"    {instruction}";

        _sb.AppendLine(line.PadRight(35) + (comment is null ? "" : $"; {comment}"));
    }

    public void AppendData(string label, string value)
    {
        _sb.AppendLine($"    {label} db {value}");
    }

    public void AppendBlankLine()
    {
        _sb.AppendLine();
    }

    public override string ToString()
    {
        return _sb.ToString();
    }
}
</file>

<file path="Generator\CodeGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class CodeGenerator
{
    internal ProgramNode Program { get; }
    internal TypeRepository TypeRepository { get; }
    internal TypeResolver TypeResolver { get; }
    internal FunctionResolver FunctionResolver { get; }
    internal VTableManager VTableManager { get; }
    internal MemoryLayoutManager MemoryLayoutManager { get; }
    internal SemanticAnalyzer SemanticAnalyzer { get; }
    internal AssemblyBuilder Builder { get; } = new();

    private int _labelIdCounter;
    private readonly Dictionary<string, string> _stringLiterals = new();
    internal HashSet<string> ExternalFunctions { get; } = new();

    internal StatementGenerator StatementGenerator { get; }
    internal ExpressionGenerator ExpressionGenerator { get; }
    private readonly DeclarationGenerator _declarationGenerator;

    public CodeGenerator(
        ProgramNode program,
        TypeRepository typeRepository,
        TypeResolver typeResolver,
        FunctionResolver functionResolver,
        VTableManager vtableManager,
        MemoryLayoutManager memoryLayoutManager,
        SemanticAnalyzer semanticAnalyzer)
    {
        Program = program;
        TypeRepository = typeRepository;
        TypeResolver = typeResolver;
        FunctionResolver = functionResolver;
        VTableManager = vtableManager;
        MemoryLayoutManager = memoryLayoutManager;
        SemanticAnalyzer = semanticAnalyzer;

        ExpressionGenerator = new ExpressionGenerator(this);
        StatementGenerator = new StatementGenerator(this);
        _declarationGenerator = new DeclarationGenerator(this);
    }

    public string Generate()
    {
        FindAllStringLiterals(Program);

        foreach (var unit in Program.CompilationUnits)
            foreach (var f in unit.Functions.Where(f => f.Body == null))
            {
                ExternalFunctions.Add(f.Name);
            }

        var fasmWriter = new FasmWriter();
        fasmWriter.WritePreamble(Builder);

        GenerateVTables();
        fasmWriter.WriteDataSection(Builder, _stringLiterals);

        fasmWriter.WriteTextSectionHeader(Builder);
        fasmWriter.WriteEntryPoint(Builder);

        foreach (var unit in Program.CompilationUnits)
        {
            foreach (var function in unit.Functions.Where(f => f.Body != null))
            {
                _declarationGenerator.GenerateFunction(function, unit, null);
                Builder.AppendBlankLine();
            }

            foreach (var s in unit.Structs)
            {
                foreach (var method in s.Methods.Where(m => m.Body != null))
                {
                    _declarationGenerator.GenerateFunction(method, unit, s);
                    Builder.AppendBlankLine();
                }
                foreach (var ctor in s.Constructors)
                {
                    _declarationGenerator.GenerateConstructor(ctor, unit);
                    Builder.AppendBlankLine();
                }
                foreach (var dtor in s.Destructors)
                {
                    _declarationGenerator.GenerateDestructor(dtor, unit);
                    Builder.AppendBlankLine();
                }
            }
        }

        fasmWriter.WriteImportDataSection(Builder, Program, ExternalFunctions);

        return Builder.ToString();
    }

    private void GenerateVTables()
    {
        Builder.AppendDirective("section '.rdata' data readable");
        foreach (var s in Program.CompilationUnits.SelectMany(cu => cu.Structs))
        {
            var structFqn = TypeRepository.GetFullyQualifiedName(s);
            if (VTableManager.HasVTable(structFqn))
            {
                Builder.AppendLabel(NameMangler.GetVTableLabel(structFqn));
                var vtable = VTableManager.GetVTable(structFqn);
                foreach (var entry in vtable)
                {
                    var mangledName = entry switch
                    {
                        FunctionDeclarationNode f => NameMangler.Mangle(f),
                        DestructorDeclarationNode d => NameMangler.Mangle(d),
                        _ => throw new InvalidOperationException("Invalid vtable entry type")
                    };
                    Builder.AppendInstruction($"dd {mangledName}");
                }
                Builder.AppendBlankLine();
            }
        }
    }

    internal int GetNextLabelId() => _labelIdCounter++;

    private void FindAllStringLiterals(AstNode node)
    {
        if (node is StringLiteralNode str && !_stringLiterals.ContainsValue(str.Value))
        {
            _stringLiterals.Add(str.Label, str.Value);
        }

        foreach (var property in node.GetType().GetProperties())
        {
            if (property.Name == "Parent") continue;

            if (property.GetValue(node) is AstNode child)
            {
                FindAllStringLiterals(child);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children) FindAllStringLiterals(c);
            }
        }
    }
}
</file>

<file path="Generator\DeclarationGenerator.cs">
namespace CTilde;

public class DeclarationGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeRepository TypeRepository => _context.TypeRepository;
    private TypeResolver TypeResolver => _context.TypeResolver;
    private FunctionResolver FunctionResolver => _context.FunctionResolver;
    private VTableManager VTableManager => _context.VTableManager;
    private MemoryLayoutManager MemoryLayoutManager => _context.MemoryLayoutManager;
    private SemanticAnalyzer SemanticAnalyzer => _context.SemanticAnalyzer;
    private StatementGenerator StatementGenerator => _context.StatementGenerator;
    private ExpressionGenerator ExpressionGenerator => _context.ExpressionGenerator;

    public DeclarationGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public void GenerateConstructor(ConstructorDeclarationNode ctor, CompilationUnitNode unit)
    {
        var symbols = new SymbolTable(ctor, TypeResolver, FunctionResolver, MemoryLayoutManager, unit);
        // Create a dummy function node to provide context for analysis, preventing NullReferenceException.
        var dummyFunctionForContext = new FunctionDeclarationNode(
            new SimpleTypeNode(new Token(TokenType.Keyword, "void", -1, -1)), ctor.OwnerStructName,
            ctor.Parameters, ctor.Body, ctor.OwnerStructName, ctor.AccessLevel,
            false, false, ctor.Namespace
        );
        var analysisContext = new AnalysisContext(symbols, unit, dummyFunctionForContext);

        Builder.AppendLabel(NameMangler.Mangle(ctor));
        GeneratePrologue(symbols);

        if (ctor.Initializer != null)
        {
            var ownerStruct = TypeRepository.FindStructByUnqualifiedName(ctor.OwnerStructName, ctor.Namespace) ?? throw new InvalidOperationException("Owner struct not found");

            var argTypes = ctor.Initializer.Arguments
                .Select(arg => SemanticAnalyzer.AnalyzeExpressionType(arg, analysisContext))
                .ToList();
            var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, ownerStruct.BaseStructName!, -1, -1));
            var baseFqn = TypeResolver.ResolveType(baseTypeNode, ownerStruct.Namespace, unit);
            var baseCtor = FunctionResolver.FindConstructor(baseFqn, argTypes) ?? throw new InvalidOperationException("Base constructor not found for given argument types.");


            int totalArgSize = 0;
            foreach (var arg in ctor.Initializer.Arguments.AsEnumerable().Reverse())
            {
                totalArgSize += ExpressionGenerator.PushArgument(arg, analysisContext);
            }

            symbols.TryGetSymbol("this", out var thisOffset, out _, out _);
            Builder.AppendInstruction($"mov eax, [ebp + {thisOffset}]", "Get 'this' pointer");
            Builder.AppendInstruction("push eax", "Push 'this' for base ctor");
            totalArgSize += 4;

            Builder.AppendInstruction($"call {NameMangler.Mangle(baseCtor)}");
            Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up base ctor args");
            Builder.AppendBlankLine();
        }

        StatementGenerator.GenerateStatement(ctor.Body, analysisContext);
        GenerateEpilogue(new List<(string, int, string)>());
    }

    public void GenerateDestructor(DestructorDeclarationNode dtor, CompilationUnitNode unit)
    {
        var symbols = new SymbolTable(dtor, TypeResolver, FunctionResolver, MemoryLayoutManager, unit);
        // Create a dummy function node to provide context for analysis.
        var dummyFunctionForContext = new FunctionDeclarationNode(
            new SimpleTypeNode(new Token(TokenType.Keyword, "void", -1, -1)), dtor.OwnerStructName,
            new List<ParameterNode>(), dtor.Body, dtor.OwnerStructName, dtor.AccessLevel,
            dtor.IsVirtual, false, dtor.Namespace
        );
        var context = new AnalysisContext(symbols, unit, dummyFunctionForContext);

        Builder.AppendLabel(NameMangler.Mangle(dtor));
        GeneratePrologue(symbols);
        StatementGenerator.GenerateStatement(dtor.Body, context);
        GenerateEpilogue(new List<(string, int, string)>());
    }

    public void GenerateFunction(FunctionDeclarationNode function, CompilationUnitNode unit, StructDefinitionNode? owner)
    {
        var tempContext = new AnalysisContext(null, unit, function);
        var returnTypeFqn = SemanticAnalyzer.AnalyzeFunctionReturnType(function, tempContext);
        var returnsStructByValue = TypeRepository.IsStruct(returnTypeFqn) && !returnTypeFqn.EndsWith("*");

        var parametersWithRetPtr = new List<ParameterNode>(function.Parameters);
        if (returnsStructByValue)
        {
            var retPtrType = new PointerTypeNode(new SimpleTypeNode(new Token(TokenType.Keyword, "void", -1, -1)));
            var retPtrParam = new ParameterNode(retPtrType, new Token(TokenType.Identifier, "__ret_ptr", -1, -1));
            parametersWithRetPtr.Add(retPtrParam);
        }

        var functionForSymbols = function with { Parameters = parametersWithRetPtr };
        var symbols = new SymbolTable(functionForSymbols, TypeResolver, FunctionResolver, MemoryLayoutManager, unit);

        var context = new AnalysisContext(symbols, unit, function);
        var destructibleLocals = symbols.GetDestructibleLocals(FunctionResolver);

        string mangledName = function.Name == "main" ? "_main" : NameMangler.Mangle(function);

        Builder.AppendLabel(mangledName);
        GeneratePrologue(symbols);

        if (function.Body != null) StatementGenerator.GenerateStatement(function.Body, context);

        GenerateEpilogue(destructibleLocals);
    }

    private void GeneratePrologue(SymbolTable symbols)
    {
        Builder.AppendInstruction("push ebp");
        Builder.AppendInstruction("mov ebp, esp");
        Builder.AppendInstruction("push ebx", "Preserve non-volatile registers");
        Builder.AppendInstruction("push esi");
        Builder.AppendInstruction("push edi");
        Builder.AppendBlankLine();

        int totalLocalSize = symbols.TotalLocalSize;
        if (totalLocalSize > 0)
        {
            Builder.AppendInstruction($"sub esp, {totalLocalSize}", "Allocate space for all local variables");
        }
    }

    private void GenerateEpilogue(List<(string Name, int Offset, string TypeFqn)> destructibleLocals)
    {
        if (destructibleLocals.Any())
        {
            Builder.AppendBlankLine();
            Builder.AppendInstruction(null, "Destructor cleanup");
            foreach (var (name, offset, type) in destructibleLocals.AsEnumerable().Reverse())
            {
                var dtor = FunctionResolver.FindDestructor(type);
                if (dtor != null)
                {
                    Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Get address of '{name}' for dtor");
                    Builder.AppendInstruction("push eax");

                    if (dtor.IsVirtual)
                    {
                        // The destructor is always at index 0 in the vtable if virtual
                        Builder.AppendInstruction("mov eax, [eax]", "Get vtable ptr");
                        Builder.AppendInstruction("mov eax, [eax]", "Get dtor from vtable[0]");
                        Builder.AppendInstruction("call eax");
                    }
                    else
                    {
                        Builder.AppendInstruction($"call {NameMangler.Mangle(dtor)}");
                    }
                    Builder.AppendInstruction("add esp, 4", "Clean up 'this'");
                }
            }
        }

        Builder.AppendBlankLine();
        Builder.AppendInstruction("pop edi");
        Builder.AppendInstruction("pop esi");
        Builder.AppendInstruction("pop ebx");
        Builder.AppendInstruction("mov esp, ebp");
        Builder.AppendInstruction("pop ebp");
        Builder.AppendInstruction("ret");
    }
}
</file>

<file path="Generator\ExpressionGenerator.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class ExpressionGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeRepository TypeRepository => _context.TypeRepository;
    private TypeResolver TypeResolver => _context.TypeResolver;
    private FunctionResolver FunctionResolver => _context.FunctionResolver;
    private VTableManager VTableManager => _context.VTableManager;
    private MemoryLayoutManager MemoryLayoutManager => _context.MemoryLayoutManager;
    private SemanticAnalyzer SemanticAnalyzer => _context.SemanticAnalyzer;
    private HashSet<string> ExternalFunctions => _context.ExternalFunctions;

    public ExpressionGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public int PushArgument(ExpressionNode arg, AnalysisContext context)
    {
        var argType = SemanticAnalyzer.AnalyzeExpressionType(arg, context);
        GenerateExpression(arg, context); // Result is address (for struct) or value (for primitive) in EAX

        if (TypeRepository.IsStruct(argType) && !argType.EndsWith("*"))
        {
            int argSize = MemoryLayoutManager.GetSizeOfType(argType, context.CompilationUnit);
            for (int offset = argSize - 4; offset >= 0; offset -= 4)
            {
                Builder.AppendInstruction($"push dword [eax + {offset}]");
            }
            return argSize;
        }
        else
        {
            Builder.AppendInstruction("push eax");
            return 4;
        }
    }

    public void GenerateLValueAddress(ExpressionNode expression, AnalysisContext context)
    {
        switch (expression)
        {
            case VariableExpressionNode varExpr: GenerateLValueForVariable(varExpr, context); break;
            case MemberAccessExpressionNode memberAccess: GenerateLValueForMemberAccess(memberAccess, context); break;
            case UnaryExpressionNode u when u.Operator.Type == TokenType.Star: GenerateExpression(u.Right, context); break;
            default: throw new InvalidOperationException($"Expression '{expression.GetType().Name}' is not a valid L-value.");
        }
    }

    private void GenerateLValueForVariable(VariableExpressionNode varExpr, AnalysisContext context)
    {
        if (context.Symbols.TryGetSymbol(varExpr.Identifier.Value, out var offset, out _, out _))
        {
            string sign = offset > 0 ? "+" : "";
            Builder.AppendInstruction($"lea eax, [ebp {sign} {offset}]", $"Get address of var/param {varExpr.Identifier.Value}");
            return;
        }

        if (context.CurrentFunction?.OwnerStructName != null)
        {
            try
            {
                string ownerStructFqn = TypeRepository.GetFullyQualifiedOwnerName(context.CurrentFunction)!;

                var (memberOffset, _) = MemoryLayoutManager.GetMemberInfo(ownerStructFqn, varExpr.Identifier.Value, context.CompilationUnit);
                context.Symbols.TryGetSymbol("this", out var thisOffset, out _, out _);
                Builder.AppendInstruction($"mov eax, [ebp + {thisOffset}]", "Get `this` pointer value");
                if (memberOffset > 0) Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for implicit this->{varExpr.Identifier.Value}");
                return;
            }
            catch (InvalidOperationException) { /* Fall through */ }
        }
        throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'.");
    }

    private void GenerateLValueForMemberAccess(MemberAccessExpressionNode memberAccess, AnalysisContext context)
    {
        var leftType = SemanticAnalyzer.AnalyzeExpressionType(memberAccess.Left, context);
        string baseStructType = leftType.TrimEnd('*');
        var (memberOffset, _) = MemoryLayoutManager.GetMemberInfo(baseStructType, memberAccess.Member.Value, context.CompilationUnit);

        if (memberAccess.Operator.Type == TokenType.Dot) GenerateLValueAddress(memberAccess.Left, context);
        else GenerateExpression(memberAccess.Left, context);

        if (memberOffset > 0) Builder.AppendInstruction($"add eax, {memberOffset}", $"Offset for member {memberAccess.Operator.Value}{memberAccess.Member.Value}");
    }

    public void GenerateExpression(ExpressionNode expression, AnalysisContext context)
    {
        switch (expression)
        {
            case IntegerLiteralNode literal: GenerateIntegerLiteral(literal); break;
            case StringLiteralNode str: GenerateStringLiteral(str); break;
            case VariableExpressionNode varExpr: GenerateVariableExpression(varExpr, context); break;
            case UnaryExpressionNode u: GenerateUnaryExpression(u, context); break;
            case MemberAccessExpressionNode m: GenerateMemberAccessExpression(m, context); break;
            case AssignmentExpressionNode assign: GenerateAssignmentExpression(assign, context); break;
            case BinaryExpressionNode binExpr: GenerateBinaryExpression(binExpr, context); break;
            case CallExpressionNode callExpr: GenerateCallExpression(callExpr, context); break;
            case QualifiedAccessExpressionNode qNode: GenerateQualifiedAccessExpression(qNode, context); break;
            case NewExpressionNode n: GenerateNewExpression(n, context); break;
            case SizeofExpressionNode s: GenerateSizeofExpression(s, context); break;
            default: throw new NotImplementedException($"Expr: {expression.GetType().Name}");
        }
    }

    private void GenerateSizeofExpression(SizeofExpressionNode s, AnalysisContext context)
    {
        var typeFqn = TypeResolver.ResolveType(s.Type, context.CurrentFunction.Namespace, context.CompilationUnit);
        var size = MemoryLayoutManager.GetSizeOfType(typeFqn, context.CompilationUnit);
        Builder.AppendInstruction($"mov eax, {size}");
    }

    private void GenerateNewExpression(NewExpressionNode n, AnalysisContext context)
    {
        var typeFqn = TypeResolver.ResolveType(n.Type, context.CurrentFunction.Namespace, context.CompilationUnit);
        var size = MemoryLayoutManager.GetSizeOfType(typeFqn, context.CompilationUnit);

        Builder.AppendInstruction($"push {size}", "Push size for malloc");
        Builder.AppendInstruction("call [malloc]");
        Builder.AppendInstruction("add esp, 4", "Clean up malloc arg");
        Builder.AppendInstruction("mov edi, eax", "Save new'd pointer in edi");

        var argTypes = n.Arguments.Select(arg => SemanticAnalyzer.AnalyzeExpressionType(arg, context)).ToList();
        var ctor = FunctionResolver.FindConstructor(typeFqn, argTypes) ?? throw new InvalidOperationException($"No matching constructor for 'new {typeFqn}'");

        if (VTableManager.HasVTable(typeFqn))
        {
            var vtableLabel = NameMangler.GetVTableLabel(typeFqn);
            Builder.AppendInstruction($"mov dword [edi], {vtableLabel}", "Set vtable pointer on heap object");
        }

        int totalArgSize = 0;
        foreach (var arg in n.Arguments.AsEnumerable().Reverse())
        {
            totalArgSize += PushArgument(arg, context);
        }

        Builder.AppendInstruction("push edi", "Push 'this' pointer for constructor");
        totalArgSize += 4;

        Builder.AppendInstruction($"call {NameMangler.Mangle(ctor)}");
        Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up ctor args");

        Builder.AppendInstruction("mov eax, edi", "Return pointer to new object in eax");
    }

    private void GenerateIntegerLiteral(IntegerLiteralNode literal) => Builder.AppendInstruction($"mov eax, {literal.Value}");
    private void GenerateStringLiteral(StringLiteralNode str) => Builder.AppendInstruction($"mov eax, {str.Label}");

    private void GenerateVariableExpression(VariableExpressionNode varExpr, AnalysisContext context)
    {
        if (context.Symbols.TryGetSymbol(varExpr.Identifier.Value, out int offset, out string type, out _))
        {
            if (TypeRepository.IsStruct(type) && !type.EndsWith("*")) GenerateLValueAddress(varExpr, context);
            else
            {
                string sign = offset > 0 ? "+" : "";
                string instruction = MemoryLayoutManager.GetSizeOfType(type, context.CompilationUnit) == 1 ? "movzx eax, byte" : "mov eax,";
                Builder.AppendInstruction($"{instruction} [ebp {sign} {offset}]", $"Load value of {varExpr.Identifier.Value}");
            }
            return;
        }

        var enumValue = FunctionResolver.ResolveUnqualifiedEnumMember(varExpr.Identifier.Value, context.CompilationUnit, context.CurrentFunction?.Namespace);
        if (enumValue.HasValue)
        {
            Builder.AppendInstruction($"mov eax, {enumValue.Value}", $"Enum member {varExpr.Identifier.Value}");
            return;
        }

        if (context.CurrentFunction?.OwnerStructName != null)
        {
            var thisMemberAccess = new MemberAccessExpressionNode(new VariableExpressionNode(new Token(TokenType.Identifier, "this", -1, -1)), new Token(TokenType.Arrow, "->", -1, -1), varExpr.Identifier) { Parent = varExpr.Parent };
            GenerateMemberAccessExpression(thisMemberAccess, context);
            return;
        }
        throw new InvalidOperationException($"Undefined variable '{varExpr.Identifier.Value}'.");
    }

    private void GenerateUnaryExpression(UnaryExpressionNode u, AnalysisContext context)
    {
        if (u.Operator.Type == TokenType.Ampersand)
        {
            GenerateLValueAddress(u.Right, context);
            return;
        }
        GenerateExpression(u.Right, context);
        switch (u.Operator.Type)
        {
            case TokenType.Minus: Builder.AppendInstruction("neg eax"); break;
            case TokenType.Star:
                var type = SemanticAnalyzer.AnalyzeExpressionType(u, context);
                string instruction = MemoryLayoutManager.GetSizeOfType(type, context.CompilationUnit) == 1 ? "movzx eax, byte [eax]" : "mov eax, [eax]";
                Builder.AppendInstruction(instruction);
                break;
        }
    }

    private void GenerateMemberAccessExpression(MemberAccessExpressionNode m, AnalysisContext context)
    {
        GenerateLValueAddress(m, context);
        var memberType = SemanticAnalyzer.AnalyzeExpressionType(m, context);
        if (TypeRepository.IsStruct(memberType) && !memberType.EndsWith("*")) return;

        string instruction = MemoryLayoutManager.GetSizeOfType(memberType, context.CompilationUnit) == 1 ? "movzx eax, byte [eax]" : "mov eax, [eax]";
        Builder.AppendInstruction(instruction);
    }

    private void GenerateAssignmentExpression(AssignmentExpressionNode assign, AnalysisContext context)
    {
        string lValueType = SemanticAnalyzer.AnalyzeExpressionType(assign.Left, context);
        bool isStructAssign = TypeRepository.IsStruct(lValueType) && !lValueType.EndsWith("*");

        if (isStructAssign)
        {
            GenerateExpression(assign.Right, context);
            Builder.AppendInstruction("push eax", "Push source address");
            GenerateLValueAddress(assign.Left, context);
            Builder.AppendInstruction("mov edi, eax", "Pop destination into EDI");
            Builder.AppendInstruction("pop esi", "Pop source into ESI");
            int size = MemoryLayoutManager.GetSizeOfType(lValueType, context.CompilationUnit);
            Builder.AppendInstruction($"push {size}");
            Builder.AppendInstruction("push esi");
            Builder.AppendInstruction("push edi");
            Builder.AppendInstruction("call [memcpy]");
            Builder.AppendInstruction("add esp, 12");
        }
        else
        {
            GenerateExpression(assign.Right, context);
            Builder.AppendInstruction("push eax", "Push value");
            GenerateLValueAddress(assign.Left, context);
            Builder.AppendInstruction("pop ecx", "Pop value into ECX");
            string instruction = MemoryLayoutManager.GetSizeOfType(lValueType, context.CompilationUnit) == 1 ? "mov [eax], cl" : "mov [eax], ecx";
            Builder.AppendInstruction(instruction, "Assign value");
        }
        if (!isStructAssign) Builder.AppendInstruction("mov eax, ecx");
    }

    private void GenerateCallExpression(CallExpressionNode callExpr, AnalysisContext context)
    {
        int totalArgSize = 0;

        // Phase 1: Resolve the function to be called.
        var func = FunctionResolver.ResolveFunctionCall(callExpr.Callee, context);

        // Phase 2: Handle struct return values (if any).
        var returnType = SemanticAnalyzer.AnalyzeFunctionReturnType(func, context);
        bool returnsStructByValue = TypeRepository.IsStruct(returnType) && !returnType.EndsWith("*");
        if (returnsStructByValue)
        {
            var size = MemoryLayoutManager.GetSizeOfType(returnType, context.CompilationUnit);
            Builder.AppendInstruction($"sub esp, {size}", "Make space for return value");
            Builder.AppendInstruction("push esp", "Push hidden return value pointer");
            totalArgSize += 4;
        }

        // Phase 3: Push all regular arguments.
        foreach (var arg in callExpr.Arguments.AsEnumerable().Reverse())
        {
            totalArgSize += PushArgument(arg, context);
        }

        // Phase 4: Push `this` pointer (if it's a method) and dispatch the call.
        bool isMethodCall = func.OwnerStructName != null;
        if (isMethodCall)
        {
            if (callExpr.Callee is MemberAccessExpressionNode ma)
            {
                // Explicit call (obj.method() or ptr->method())
                if (ma.Operator.Type == TokenType.Arrow) GenerateExpression(ma.Left, context);
                else GenerateLValueAddress(ma.Left, context);
            }
            else
            {
                // Implicit `this` call (method() from within another method)
                context.Symbols.TryGetSymbol("this", out int thisOffset, out _, out _);
                Builder.AppendInstruction($"mov eax, [ebp + {thisOffset}]", "Get implicit 'this' pointer");
            }
            Builder.AppendInstruction("push eax", "Push 'this' pointer");
            totalArgSize += 4;

            // Dispatch (virtual or static)
            if (func.IsVirtual || func.IsOverride)
            {
                var ownerTypeFqn = TypeRepository.GetFullyQualifiedOwnerName(func)!;
                var vtableIndex = VTableManager.GetMethodVTableIndex(ownerTypeFqn, func.Name);
                int thisPtrOnStackOffset = totalArgSize - 4;
                Builder.AppendInstruction($"mov eax, [esp + {thisPtrOnStackOffset}]", "Get 'this' from stack for vcall");
                Builder.AppendInstruction("mov eax, [eax]", "Get vtable pointer from object");
                Builder.AppendInstruction($"mov eax, [eax + {vtableIndex * 4}]", $"Get method address from vtable[{vtableIndex}]");
                Builder.AppendInstruction("call eax");
            }
            else
            {
                Builder.AppendInstruction($"call {NameMangler.Mangle(func)}");
            }
        }
        else
        {
            // Global function dispatch
            string calleeTarget = func.Body == null ? $"[{func.Name}]" : NameMangler.Mangle(func);
            if (func.Body == null) ExternalFunctions.Add(func.Name);
            Builder.AppendInstruction($"call {calleeTarget}");
        }

        // Phase 5: Cleanup stack.
        if (totalArgSize > 0)
        {
            Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up args");
        }

        if (returnsStructByValue)
        {
            Builder.AppendInstruction("lea eax, [esp]", "Get address of hidden return temporary");
        }
    }

    private void GenerateBinaryExpression(BinaryExpressionNode binExpr, AnalysisContext context)
    {
        var leftTypeFqn = SemanticAnalyzer.AnalyzeExpressionType(binExpr.Left, context);
        var rightTypeFqn = SemanticAnalyzer.AnalyzeExpressionType(binExpr.Right, context);

        if (TypeRepository.IsStruct(leftTypeFqn) && !leftTypeFqn.EndsWith("*"))
        {
            // Handle struct operator overloads
            var opName = $"operator_{NameMangler.MangleOperator(binExpr.Operator.Value)}";
            var overload = FunctionResolver.FindMethod(leftTypeFqn.TrimEnd('*'), opName) ?? throw new InvalidOperationException($"Internal compiler error: overload for '{opName}' not found.");

            var returnType = SemanticAnalyzer.AnalyzeFunctionReturnType(overload, context);
            bool returnsStructByValue = TypeRepository.IsStruct(returnType) && !returnType.EndsWith("*");
            int totalArgSize = 0;

            if (returnsStructByValue)
            {
                var size = MemoryLayoutManager.GetSizeOfType(returnType, context.CompilationUnit);
                Builder.AppendInstruction($"sub esp, {size}", "Make space for op+ return value");
                Builder.AppendInstruction("push esp", "Push hidden return value pointer");
                totalArgSize += 4;
            }

            totalArgSize += PushArgument(binExpr.Right, context);

            GenerateLValueAddress(binExpr.Left, context);
            Builder.AppendInstruction("push eax", "Push 'this' pointer");
            totalArgSize += 4;

            Builder.AppendInstruction($"call {NameMangler.Mangle(overload)}");
            Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up op+ args");

            if (returnsStructByValue)
            {
                Builder.AppendInstruction("lea eax, [esp]", "Get address of hidden return temporary");
            }
            return;
        }

        // Standard evaluation: Right then Left
        GenerateExpression(binExpr.Right, context);
        Builder.AppendInstruction("push eax");
        GenerateExpression(binExpr.Left, context);
        Builder.AppendInstruction("pop ecx"); // EAX = Left, ECX = Right

        // Handle pointer arithmetic scaling
        if (binExpr.Operator.Type is TokenType.Plus or TokenType.Minus)
        {
            if (leftTypeFqn.EndsWith("*") && rightTypeFqn == "int")
            {
                var baseType = leftTypeFqn[..^1]; // Remove one level of indirection
                var elementSize = MemoryLayoutManager.GetSizeOfType(baseType, context.CompilationUnit);
                if (elementSize > 1) Builder.AppendInstruction($"imul ecx, {elementSize}");
            }
            else if (leftTypeFqn == "int" && rightTypeFqn.EndsWith("*"))
            {
                var baseType = rightTypeFqn[..^1]; // Remove one level of indirection
                var elementSize = MemoryLayoutManager.GetSizeOfType(baseType, context.CompilationUnit);
                if (elementSize > 1) Builder.AppendInstruction($"imul eax, {elementSize}");
            }
        }

        // Perform Operation
        switch (binExpr.Operator.Type)
        {
            case TokenType.Plus: Builder.AppendInstruction("add eax, ecx"); break;
            case TokenType.Minus: Builder.AppendInstruction("sub eax, ecx"); break;
            case TokenType.Star: Builder.AppendInstruction("imul eax, ecx"); break;
            case TokenType.Slash: Builder.AppendInstruction("cdq"); Builder.AppendInstruction("idiv ecx"); break;
            case TokenType.DoubleEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("sete al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.NotEquals: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setne al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.LessThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setl al"); Builder.AppendInstruction("movzx eax, al"); break;
            case TokenType.GreaterThan: Builder.AppendInstruction("cmp eax, ecx"); Builder.AppendInstruction("setg al"); Builder.AppendInstruction("movzx eax, al"); break;
            default: throw new NotImplementedException($"Op: {binExpr.Operator.Type}");
        }
    }


    private void GenerateQualifiedAccessExpression(QualifiedAccessExpressionNode qNode, AnalysisContext context)
    {
        string potentialEnumTypeName = TypeResolver.ResolveQualifier(qNode.Left);
        string memberName = qNode.Member.Value;
        string? enumTypeFQN = TypeResolver.ResolveEnumTypeName(potentialEnumTypeName, context.CurrentFunction?.Namespace, context.CompilationUnit);
        if (enumTypeFQN != null)
        {
            var enumValue = FunctionResolver.GetEnumValue(enumTypeFQN, memberName);
            if (enumValue.HasValue)
            {
                Builder.AppendInstruction($"mov eax, {enumValue.Value}", $"Enum member {potentialEnumTypeName}::{memberName}");
                return;
            }
        }

        var func = FunctionResolver.ResolveFunctionCall(qNode, context);
        string calleeTarget = func.Body == null ? $"[{func.Name}]" : NameMangler.Mangle(func);
        if (func.Body == null) ExternalFunctions.Add(func.Name);
        Builder.AppendInstruction($"mov eax, {calleeTarget}");
    }
}
</file>

<file path="Generator\FasmWriter.cs">
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CTilde;

public class FasmWriter
{
    public void WritePreamble(AssemblyBuilder builder)
    {
        builder.AppendDirective("format PE GUI 4.0");
        builder.AppendDirective("entry start");
        builder.AppendBlankLine();
        builder.AppendDirective("include 'win32a.inc'");
        builder.AppendBlankLine();
    }

    public void WriteDataSection(AssemblyBuilder builder, Dictionary<string, string> stringLiterals)
    {
        builder.AppendDirective("section '.data' data readable writeable");
        foreach (var (label, value) in stringLiterals)
        {
            builder.AppendData(label, FormatStringForFasm(value));
        }
        builder.AppendBlankLine();
    }

    public void WriteTextSectionHeader(AssemblyBuilder builder)
    {
        builder.AppendDirective("section '.text' code readable executable");
        builder.AppendBlankLine();
    }

    public void WriteEntryPoint(AssemblyBuilder builder)
    {
        builder.AppendLabel("start");
        builder.AppendInstruction("call _main");
        builder.AppendInstruction("mov ebx, eax");
        builder.AppendInstruction("push ebx");
        builder.AppendInstruction("call [ExitProcess]");
        builder.AppendBlankLine();
    }

    public void WriteImportDataSection(AssemblyBuilder builder, ProgramNode program, IEnumerable<string> externalFunctions)
    {
        builder.AppendDirective("section '.idata' import data readable");
        builder.AppendBlankLine();

        var libraries = new Dictionary<string, HashSet<string>>
        {
            { "kernel32.dll", new HashSet<string> { "ExitProcess" } },
            { "msvcrt.dll", new HashSet<string> { "printf", "malloc", "free", "strlen", "strcpy", "memcpy" } }
        };

        // Register all libraries from #import directives
        foreach (var import in program.Imports)
        {
            if (!libraries.ContainsKey(import.LibraryName))
            {
                libraries[import.LibraryName] = new HashSet<string>();
            }
        }

        // Get all functions that are already assigned to a default library
        var claimedFunctions = new HashSet<string>(libraries.SelectMany(kvp => kvp.Value));

        // Distribute all other external functions among the imported libraries
        foreach (var funcName in externalFunctions.Except(claimedFunctions))
        {
            // Assign the function to the first non-standard DLL found in the #import list.
            var ownerLib = program.Imports
                .Select(i => i.LibraryName)
                .FirstOrDefault(lib => lib != "kernel32.dll" && lib != "msvcrt.dll");

            if (ownerLib != null)
            {
                libraries[ownerLib].Add(funcName);
            }
            else // Fallback for functions if only standard libs are imported (e.g. user32 functions)
            {
                if (!libraries.ContainsKey("user32.dll")) libraries["user32.dll"] = new HashSet<string>();
                libraries["user32.dll"].Add(funcName);
            }
        }

        // Filter out libraries that have no functions to import
        var finalLibraries = libraries
            .Where(kvp => kvp.Value.Any())
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToList());

        if (!finalLibraries.Any()) return;

        var libDefs = finalLibraries.Keys.OrderBy(k => k).Select(lib => $"{lib.Split('.')[0]},'{lib}'");
        builder.AppendDirective($"    library {string.Join(", ", libDefs)}");
        builder.AppendBlankLine();

        foreach (var (libName, functions) in finalLibraries.OrderBy(kvp => kvp.Key))
        {
            var libAlias = libName.Split('.')[0];
            functions.Sort();
            var importDefs = functions.Select(f => $"{f},'{f}'");
            builder.AppendDirective($"    import {libAlias}, {string.Join(", ", importDefs)}");
        }
    }

    private string FormatStringForFasm(string value)
    {
        var parts = new List<string>();
        var currentString = new StringBuilder();

        foreach (char c in value)
        {
            if (c is '\n' or '\t' or '\r' or '\'' or '"')
            {
                if (currentString.Length > 0)
                {
                    parts.Add($"'{currentString}'");
                    currentString.Clear();
                }
                parts.Add(((byte)c).ToString());
            }
            else currentString.Append(c);
        }

        if (currentString.Length > 0) parts.Add($"'{currentString}'");
        parts.Add("0");
        return string.Join(", ", parts);
    }
}
</file>

<file path="Generator\MemoryLayoutManager.cs">
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class MemoryLayoutManager
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;
    private readonly VTableManager _vtableManager;

    public MemoryLayoutManager(TypeRepository typeRepository, TypeResolver typeResolver, VTableManager vtableManager)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
        _vtableManager = vtableManager;
    }

    public int GetSizeOfType(string typeNameFqn, CompilationUnitNode context)
    {
        if (typeNameFqn.EndsWith("*")) return 4;
        if (typeNameFqn == "int") return 4;
        if (typeNameFqn == "char") return 1;
        if (typeNameFqn == "void") return 0; // Void has no size

        // Heuristic: If it's a single uppercase letter, assume it's a generic type parameter.
        // In the current implementation, generic types are treated like pointers/references.
        if (typeNameFqn.Length == 1 && char.IsUpper(typeNameFqn[0]))
        {
            return 4; // Treat as a pointer size.
        }

        // If it's not a primitive, try to find it as a struct
        if (_typeRepository.FindStruct(typeNameFqn) is { } structDef)
        {
            int size = 0;
            var structUnit = _typeRepository.GetCompilationUnitForStruct(typeNameFqn);
            if (structDef.BaseStructName != null)
            {
                var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, structDef.BaseStructName, -1, -1));
                string baseFqn = _typeResolver.ResolveType(baseTypeNode, structDef.Namespace, structUnit);

                // The baseUnit might be different if the base struct is in another file/namespace
                var baseUnit = _typeRepository.GetCompilationUnitForStruct(baseFqn);
                size += GetSizeOfType(baseFqn, baseUnit);
            }
            else if (_vtableManager.HasVTable(typeNameFqn))
            {
                size += 4; // vtable pointer
            }

            foreach (var member in structDef.Members)
            {
                var resolvedMemberType = _typeResolver.ResolveType(member.Type, structDef.Namespace, structUnit);

                var memberUnit = _typeRepository.IsStruct(resolvedMemberType)
                    ? _typeRepository.GetCompilationUnitForStruct(resolvedMemberType.TrimEnd('*'))
                    : structUnit; // If not a struct, use the owner struct's unit for context
                size += GetSizeOfType(resolvedMemberType, memberUnit);
            }
            return size;
        }
        throw new System.InvalidOperationException($"Unknown type '{typeNameFqn}' for size calculation.");
    }

    public (int offset, string type) GetMemberInfo(string structName, string memberName, CompilationUnitNode context)
    {
        var member = GetAllMembers(structName, context).FirstOrDefault(m => m.name == memberName);
        if (member == default) throw new System.InvalidOperationException($"Struct '{structName}' has no member '{memberName}'");
        return (member.offset, member.type);
    }

    public List<(string name, string type, int offset, bool isConst)> GetAllMembers(string structFqn, CompilationUnitNode context)
    {
        if (_typeRepository.FindStruct(structFqn) is not { } structDef) throw new System.InvalidOperationException($"Struct '{structFqn}' not found.");

        var allMembers = new List<(string, string, int, bool)>();
        int currentOffset = 0;

        if (structDef.BaseStructName != null)
        {
            var structUnit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, structDef.BaseStructName, -1, -1));
            string baseFqn = _typeResolver.ResolveType(baseTypeNode, structDef.Namespace, structUnit);
            var baseUnit = _typeRepository.GetCompilationUnitForStruct(baseFqn);
            allMembers.AddRange(GetAllMembers(baseFqn, baseUnit));
            currentOffset = GetSizeOfType(baseFqn, baseUnit);
        }
        else if (_vtableManager.HasVTable(structFqn))
        {
            currentOffset = 4; // vtable pointer
        }

        foreach (var mem in structDef.Members)
        {
            var ownUnit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            string resolvedMemberType = _typeResolver.ResolveType(mem.Type, structDef.Namespace, ownUnit);

            allMembers.Add((mem.Name.Value, resolvedMemberType, currentOffset, mem.IsConst));

            var memberUnit = _typeRepository.IsStruct(resolvedMemberType)
                ? _typeRepository.GetCompilationUnitForStruct(resolvedMemberType.TrimEnd('*'))
                : ownUnit; // If not a struct, use the owner struct's unit for context
            currentOffset += GetSizeOfType(resolvedMemberType, memberUnit);
        }
        return allMembers;
    }
}
</file>

<file path="Generator\NameMangler.cs">
using System.Linq;
using System.Text;

namespace CTilde;

public static class NameMangler
{
    public static string Mangle(FunctionDeclarationNode f)
    {
        var ownerName = f.OwnerStructName;
        // If the owner is a mangled generic name already, don't re-mangle it.
        if (ownerName != null && ownerName.Contains("__"))
        {
            return $"_{ownerName}_{f.Name}";
        }
        return MangleName(f.Namespace, f.OwnerStructName, f.Name);
    }

    private static string MangleType(TypeNode type)
    {
        if (type is PointerTypeNode ptn)
        {
            return "p" + MangleType(ptn.BaseType);
        }

        if (type is SimpleTypeNode stn)
        {
            var typeToken = stn.TypeToken;
            if (typeToken.Type == TokenType.Keyword)
            {
                return typeToken.Value[0].ToString();
            }
            else // Identifier, could be qualified
            {
                var cleanName = typeToken.Value.Replace("::", "_");
                return $"{cleanName.Length}{cleanName}";
            }
        }

        if (type is GenericInstantiationTypeNode gitn)
        {
            var sb = new StringBuilder();
            sb.Append(MangleType(new SimpleTypeNode(gitn.BaseType)));
            foreach (var arg in gitn.TypeArguments)
            {
                sb.Append(MangleType(arg));
            }
            return sb.ToString();
        }

        // TODO: Mangle generic types properly
        return "T";
    }

    public static string MangleGenericInstance(string templateFqn, List<TypeNode> concreteTypeNodes)
    {
        var sb = new StringBuilder();
        sb.Append(templateFqn.Replace("::", "__"));
        foreach (var typeNode in concreteTypeNodes)
        {
            sb.Append('_');
            sb.Append(MangleType(typeNode));
        }
        return sb.ToString();
    }


    public static string Mangle(ConstructorDeclarationNode c)
    {
        var paramSignature = string.Concat(c.Parameters.Select(p => MangleType(p.Type)));
        var ownerName = c.OwnerStructName;
        if (ownerName.Contains("__"))
        {
            return $"_{ownerName}_ctor_{paramSignature}";
        }
        return MangleName(c.Namespace, c.OwnerStructName, $"{c.OwnerStructName}_ctor_{paramSignature}");
    }

    public static string Mangle(DestructorDeclarationNode d)
    {
        var ownerName = d.OwnerStructName;
        if (ownerName.Contains("__"))
        {
            return $"_{ownerName}_dtor";
        }
        return MangleName(d.Namespace, d.OwnerStructName, $"{d.OwnerStructName}_dtor");
    }

    public static string GetVTableLabel(string structFqn)
    {
        return $"_vtable_{structFqn.Replace("::", "_").Replace("<", "_").Replace(">", "").Replace("*", "p")}";
    }

    public static string MangleOperator(string op)
    {
        return op switch
        {
            "+" => "plus",
            _ => throw new System.NotImplementedException($"Operator mangling for '{op}' is not implemented.")
        };
    }

    private static string MangleName(string? ns, string? owner, string name)
    {
        var parts = new List<string?> { ns, owner, name }
            .Where(p => !string.IsNullOrEmpty(p))
            .Select(p => p!.Replace("::", "_"));

        return $"_{string.Join("_", parts)}";
    }
}
</file>

<file path="Generator\StatementGenerator.cs">
using System;
using System.Linq;

namespace CTilde;

public class StatementGenerator
{
    private readonly CodeGenerator _context;
    private AssemblyBuilder Builder => _context.Builder;
    private TypeRepository TypeRepository => _context.TypeRepository;
    private FunctionResolver FunctionResolver => _context.FunctionResolver;
    private MemoryLayoutManager MemoryLayoutManager => _context.MemoryLayoutManager;
    private ExpressionGenerator ExpressionGenerator => _context.ExpressionGenerator;

    public StatementGenerator(CodeGenerator context)
    {
        _context = context;
    }

    public void GenerateStatement(StatementNode statement, AnalysisContext context)
    {
        switch (statement)
        {
            case ReturnStatementNode ret: GenerateReturn(ret, context); break;
            case BlockStatementNode block: foreach (var s in block.Statements) GenerateStatement(s, context); break;
            case WhileStatementNode w: GenerateWhile(w, context); break;
            case IfStatementNode i: GenerateIf(i, context); break;
            case DeleteStatementNode d: GenerateDelete(d, context); break;
            case DeclarationStatementNode decl:
                GenerateDeclaration(decl, context);
                break;
            case ExpressionStatementNode exprStmt:
                ExpressionGenerator.GenerateExpression(exprStmt.Expression, context);
                // Check if the expression statement was a function call that returned a temporary struct
                var exprType = _context.SemanticAnalyzer.AnalyzeExpressionType(exprStmt.Expression, context);
                if (_context.TypeRepository.IsStruct(exprType) && !exprType.EndsWith("*"))
                {
                    if (exprStmt.Expression is CallExpressionNode or BinaryExpressionNode)
                    {
                        // The temporary is on the stack but its value is unused. We must destroy it.
                        var tempDtor = FunctionResolver.FindDestructor(exprType);
                        if (tempDtor != null)
                        {
                            Builder.AppendInstruction(null, "Destroying temporary from expression statement");
                            Builder.AppendInstruction("lea eax, [esp]"); // Address of temporary is at ESP
                            Builder.AppendInstruction("push eax"); // Push 'this'
                            if (tempDtor.IsVirtual)
                            {
                                Builder.AppendInstruction("mov eax, [eax]", "Get vtable ptr");
                                Builder.AppendInstruction("mov eax, [eax]", "Get dtor from vtable[0]");
                                Builder.AppendInstruction("call eax");
                            }
                            else
                            {
                                Builder.AppendInstruction($"call {NameMangler.Mangle(tempDtor)}");
                            }
                            Builder.AppendInstruction("add esp, 4"); // Clean up 'this'
                        }
                        var size = MemoryLayoutManager.GetSizeOfType(exprType, context.CompilationUnit);
                        Builder.AppendInstruction($"add esp, {size}", "Clean up temporary return object from stack");
                    }
                }
                break;
            default: throw new NotImplementedException($"Stmt: {statement.GetType().Name}");
        }
    }

    private void GenerateDelete(DeleteStatementNode deleteNode, AnalysisContext context)
    {
        ExpressionGenerator.GenerateExpression(deleteNode.Expression, context);
        Builder.AppendInstruction("mov edi, eax", "Save pointer to be deleted in edi");

        var pointerType = _context.SemanticAnalyzer.AnalyzeExpressionType(deleteNode.Expression, context);
        var objectType = pointerType.TrimEnd('*');

        // If the object's type has a vtable, its destructor MUST be called virtually.
        // Otherwise, call it directly if it exists.
        if (_context.VTableManager.HasVTable(objectType))
        {
            Builder.AppendInstruction("push edi", "Push 'this' pointer for virtual dtor call");
            Builder.AppendInstruction("mov eax, [edi]", "Get vtable pointer from object");
            Builder.AppendInstruction("mov eax, [eax]", "Get destructor from vtable[0]");
            Builder.AppendInstruction("call eax");
            Builder.AppendInstruction("add esp, 4", "Clean up 'this' from dtor call");
        }
        else
        {
            var dtor = FunctionResolver.FindDestructor(objectType);
            if (dtor != null)
            {
                Builder.AppendInstruction("push edi", "Push 'this' pointer for non-virtual dtor call");
                Builder.AppendInstruction($"call {NameMangler.Mangle(dtor)}");
                Builder.AppendInstruction("add esp, 4", "Clean up 'this' from dtor call");
            }
        }

        Builder.AppendInstruction("push edi", "Push pointer for free()");
        Builder.AppendInstruction("call [free]");
        Builder.AppendInstruction("add esp, 4", "Clean up pointer from free() call");
    }

    private void GenerateDeclaration(DeclarationStatementNode decl, AnalysisContext context)
    {
        var variableName = decl.Identifier.Value;
        var varTypeFqn = context.Symbols.GetSymbolType(variableName);
        context.Symbols.TryGetSymbol(variableName, out var offset, out _, out _);

        if (TypeRepository.IsStruct(varTypeFqn))
        {
            if (_context.VTableManager.HasVTable(varTypeFqn))
            {
                var vtableLabel = NameMangler.GetVTableLabel(varTypeFqn);
                Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Get address of object '{variableName}'");
                Builder.AppendInstruction($"mov dword [eax], {vtableLabel}", "Set vtable pointer");
            }

            if (decl.ConstructorArguments != null) // e.g. string s("hello");
            {
                var argTypes = decl.ConstructorArguments
                    .Select(arg => _context.SemanticAnalyzer.AnalyzeExpressionType(arg, context))
                    .ToList();
                var ctor = FunctionResolver.FindConstructor(varTypeFqn, argTypes) ?? throw new InvalidOperationException($"No constructor found for '{varTypeFqn}' matching signature.");

                int totalArgSize = 0;
                foreach (var arg in decl.ConstructorArguments.AsEnumerable().Reverse())
                {
                    totalArgSize += ExpressionGenerator.PushArgument(arg, context);
                }

                Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Push 'this' for constructor");
                Builder.AppendInstruction("push eax");
                totalArgSize += 4;

                Builder.AppendInstruction($"call {NameMangler.Mangle(ctor)}");
                Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up ctor args");
            }
            else if (decl.Initializer != null)
            {
                if (decl.Initializer is InitializerListExpressionNode initList) // e.g. MyStruct s = {1, 2};
                {
                    var allMembers = MemoryLayoutManager.GetAllMembers(varTypeFqn, context.CompilationUnit);
                    if (initList.Values.Count > allMembers.Count) throw new InvalidOperationException($"Too many values in initializer list for struct '{varTypeFqn}'.");

                    for (int j = 0; j < initList.Values.Count; j++)
                    {
                        var (memberName, memberType, memberOffset, _) = allMembers[j];
                        var valueExpr = initList.Values[j];
                        var memberSize = MemoryLayoutManager.GetSizeOfType(memberType, context.CompilationUnit);
                        var totalOffset = offset + memberOffset;

                        ExpressionGenerator.GenerateExpression(valueExpr, context);
                        if (memberSize == 1) Builder.AppendInstruction($"mov byte [ebp + {totalOffset}], al", $"Init member {memberName}");
                        else Builder.AppendInstruction($"mov dword [ebp + {totalOffset}], eax", $"Init member {memberName}");
                    }
                }
                else // Covers implicit constructor calls AND pointer initialization
                {
                    string initializerType = _context.SemanticAnalyzer.AnalyzeExpressionType(decl.Initializer, context);

                    if (varTypeFqn.EndsWith("*"))
                    {
                        // Pointer initialization, not a constructor call.
                        ExpressionGenerator.GenerateExpression(decl.Initializer, context);
                        Builder.AppendInstruction($"mov dword [ebp + {offset}], eax", $"Initialize pointer {variableName}");
                    }
                    else
                    {
                        // Implicit constructor call for a value-type struct.
                        var ctor = FunctionResolver.FindConstructor(varTypeFqn, new List<string> { initializerType });

                        bool takeAddressOfInitializer = false;
                        if (ctor == null && TypeRepository.IsStruct(initializerType))
                        {
                            // Try to find a copy constructor that takes a pointer, e.g. string(string*)
                            ctor = FunctionResolver.FindConstructor(varTypeFqn, new List<string> { initializerType + "*" });
                            if (ctor != null)
                            {
                                takeAddressOfInitializer = true;
                            }
                        }

                        if (ctor == null)
                        {
                            throw new InvalidOperationException($"No constructor found for '{varTypeFqn}' that takes an argument of type '{initializerType}'.");
                        }

                        int totalArgSize;
                        if (takeAddressOfInitializer)
                        {
                            ExpressionGenerator.GenerateExpression(decl.Initializer, context);
                            Builder.AppendInstruction("push eax", "Push pointer to initializer object for copy ctor");
                            totalArgSize = 4;
                        }
                        else
                        {
                            totalArgSize = ExpressionGenerator.PushArgument(decl.Initializer, context);
                        }

                        Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Push 'this' for constructor");
                        Builder.AppendInstruction("push eax");
                        totalArgSize += 4;

                        Builder.AppendInstruction($"call {NameMangler.Mangle(ctor)}");
                        Builder.AppendInstruction($"add esp, {totalArgSize}", "Clean up ctor args");

                        if (decl.Initializer is CallExpressionNode or BinaryExpressionNode &&
                            _context.TypeRepository.IsStruct(initializerType) && !initializerType.EndsWith("*"))
                        {
                            var tempDtor = FunctionResolver.FindDestructor(initializerType);
                            if (tempDtor != null)
                            {
                                Builder.AppendInstruction(null, "Destroying temporary from initialization");
                                Builder.AppendInstruction("lea eax, [esp]");
                                Builder.AppendInstruction("push eax");
                                if (tempDtor.IsVirtual)
                                {
                                    Builder.AppendInstruction("mov eax, [eax]");
                                    Builder.AppendInstruction("mov eax, [eax]");
                                    Builder.AppendInstruction("call eax");
                                }
                                else
                                {
                                    Builder.AppendInstruction($"call {NameMangler.Mangle(tempDtor)}");
                                }
                                Builder.AppendInstruction("add esp, 4");
                            }
                            var size = MemoryLayoutManager.GetSizeOfType(initializerType, context.CompilationUnit);
                            Builder.AppendInstruction($"add esp, {size}", "Clean up temporary return object from stack");
                        }
                    }
                }
            }
            else // Default constructor call, e.g. List textObjects;
            {
                var ctor = FunctionResolver.FindConstructor(varTypeFqn, new List<string>());
                if (ctor != null)
                {
                    Builder.AppendInstruction(null, $"Calling default constructor for {variableName}");
                    Builder.AppendInstruction($"lea eax, [ebp + {offset}]", $"Push 'this' for constructor");
                    Builder.AppendInstruction("push eax");
                    Builder.AppendInstruction($"call {NameMangler.Mangle(ctor)}");
                    Builder.AppendInstruction("add esp, 4", "Clean up ctor args");
                }
            }
        }
        else if (decl.Initializer != null) // Primitive types
        {
            ExpressionGenerator.GenerateExpression(decl.Initializer, context);
            if (MemoryLayoutManager.GetSizeOfType(varTypeFqn, context.CompilationUnit) == 1)
                Builder.AppendInstruction($"mov byte [ebp + {offset}], al", $"Initialize {variableName}");
            else
                Builder.AppendInstruction($"mov dword [ebp + {offset}], eax", $"Initialize {variableName}");
        }
    }

    private void GenerateReturn(ReturnStatementNode ret, AnalysisContext context)
    {
        var returnTypeFqn = _context.SemanticAnalyzer.AnalyzeFunctionReturnType(context.CurrentFunction, context);
        if (TypeRepository.IsStruct(returnTypeFqn) && !returnTypeFqn.EndsWith("*"))
        {
            if (ret.Expression == null) throw new InvalidOperationException("Must return a value from a function with a struct return type.");

            // Get the address of the local object being returned (e.g. &result)
            ExpressionGenerator.GenerateExpression(ret.Expression, context);
            Builder.AppendInstruction("mov esi, eax", "Source address for return value");

            // Get the hidden pointer to the destination (passed by the caller)
            context.Symbols.TryGetSymbol("__ret_ptr", out var retPtrOffset, out _, out _);
            Builder.AppendInstruction($"mov edi, [ebp + {retPtrOffset}]", "Destination address for return value");

            // Find a copy constructor, e.g. string(string*)
            var copyCtor = FunctionResolver.FindConstructor(returnTypeFqn, new List<string> { returnTypeFqn + "*" });

            if (copyCtor != null)
            {
                Builder.AppendInstruction(null, "Calling copy constructor for return value");
                Builder.AppendInstruction("push esi", "Push source pointer argument");
                Builder.AppendInstruction("push edi", "Push destination pointer as 'this'");
                Builder.AppendInstruction($"call {NameMangler.Mangle(copyCtor)}");
                Builder.AppendInstruction("add esp, 8", "Clean up copy ctor args");
            }
            else
            {
                // Fallback to memcpy for POD structs without a copy constructor
                var size = MemoryLayoutManager.GetSizeOfType(returnTypeFqn, context.CompilationUnit);
                Builder.AppendInstruction($"push {size}");
                Builder.AppendInstruction("push esi");
                Builder.AppendInstruction("push edi");
                Builder.AppendInstruction("call [memcpy]");
                Builder.AppendInstruction("add esp, 12");
            }
        }
        else
        {
            // Handle return for primitive types
            if (ret.Expression != null) ExpressionGenerator.GenerateExpression(ret.Expression, context);
        }

        // The actual `ret` instruction is in the epilogue to ensure destructors are called.
    }

    private void GenerateWhile(WhileStatementNode w, AnalysisContext context)
    {
        int i = _context.GetNextLabelId();
        Builder.AppendLabel($"_while_start_{i}");
        ExpressionGenerator.GenerateExpression(w.Condition, context);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction($"je _while_end_{i}");
        GenerateStatement(w.Body, context);
        Builder.AppendInstruction($"jmp _while_start_{i}");
        Builder.AppendLabel($"_while_end_{i}");
    }

    private void GenerateIf(IfStatementNode i, AnalysisContext context)
    {
        int idx = _context.GetNextLabelId();
        ExpressionGenerator.GenerateExpression(i.Condition, context);
        Builder.AppendInstruction("cmp eax, 0");
        Builder.AppendInstruction(i.ElseBody != null ? $"je _if_else_{idx}" : $"je _if_end_{idx}");
        GenerateStatement(i.ThenBody, context);
        if (i.ElseBody != null)
        {
            Builder.AppendInstruction($"jmp _if_end_{idx}");
            Builder.AppendLabel($"_if_else_{idx}");
            GenerateStatement(i.ElseBody, context);
        }
        Builder.AppendLabel($"_if_end_{idx}");
    }
}
</file>

<file path="Generator\SymbolTable.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class SymbolTable
{
    private readonly Dictionary<string, (int Offset, string Type, bool IsConst, bool IsRead)> _symbols = new();
    public int TotalLocalSize { get; private set; }

    // Dummy constructor for semantic analysis pass where symbols aren't fully resolved yet.
    public SymbolTable() { }

    // Constructor for Functions/Methods
    public SymbolTable(FunctionDeclarationNode function, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager, CompilationUnitNode currentUnit)
    {
        var allLocalDeclarations = new List<DeclarationStatementNode>();
        CollectDeclarations(function.Body, allLocalDeclarations);
        Initialize(function.Parameters, allLocalDeclarations, typeResolver, memoryLayoutManager, function.Namespace, currentUnit);
    }

    // Constructor for Constructors
    public SymbolTable(ConstructorDeclarationNode ctor, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager, CompilationUnitNode currentUnit)
    {
        var allLocalDeclarations = new List<DeclarationStatementNode>();
        CollectDeclarations(ctor.Body, allLocalDeclarations);

        // If the owner's name is mangled, it's already an FQN. Otherwise, construct the FQN.
        string thisTypeName = ctor.OwnerStructName.Contains("__")
            ? ctor.OwnerStructName
            : (ctor.Namespace != null ? $"{ctor.Namespace}::{ctor.OwnerStructName}" : ctor.OwnerStructName);

        var thisTypeNode = new PointerTypeNode(new SimpleTypeNode(new Token(TokenType.Identifier, thisTypeName, -1, -1)));
        var thisParam = new ParameterNode(thisTypeNode, new Token(TokenType.Identifier, "this", -1, -1));

        var allParams = new List<ParameterNode> { thisParam };
        allParams.AddRange(ctor.Parameters);
        Initialize(allParams, allLocalDeclarations, typeResolver, memoryLayoutManager, ctor.Namespace, currentUnit);
    }

    // Constructor for Destructors
    public SymbolTable(DestructorDeclarationNode dtor, TypeResolver typeResolver, FunctionResolver functionResolver, MemoryLayoutManager memoryLayoutManager, CompilationUnitNode currentUnit)
    {
        var allLocalDeclarations = new List<DeclarationStatementNode>();
        CollectDeclarations(dtor.Body, allLocalDeclarations);

        // If the owner's name is mangled, it's already an FQN. Otherwise, construct the FQN.
        string thisTypeName = dtor.OwnerStructName.Contains("__")
            ? dtor.OwnerStructName
            : (dtor.Namespace != null ? $"{dtor.Namespace}::{dtor.OwnerStructName}" : dtor.OwnerStructName);

        var thisTypeNode = new PointerTypeNode(new SimpleTypeNode(new Token(TokenType.Identifier, thisTypeName, -1, -1)));
        var thisParam = new ParameterNode(thisTypeNode, new Token(TokenType.Identifier, "this", -1, -1));

        Initialize(new List<ParameterNode> { thisParam }, allLocalDeclarations, typeResolver, memoryLayoutManager, dtor.Namespace, currentUnit);
    }

    private void Initialize(List<ParameterNode> parameters, List<DeclarationStatementNode> localDeclarations, TypeResolver typeResolver, MemoryLayoutManager memoryLayoutManager, string? currentNamespace, CompilationUnitNode currentUnit)
    {
        TotalLocalSize = 0;
        foreach (var d in localDeclarations)
        {
            var baseTypeName = d.Type.GetBaseTypeName();
            if (baseTypeName == "unknown") continue;

            string resolvedTypeName = typeResolver.ResolveType(d.Type, currentNamespace, currentUnit);
            TotalLocalSize += memoryLayoutManager.GetSizeOfType(resolvedTypeName, currentUnit);
        }

        int currentParamOffset = 8; // EBP + 8 is first parameter
        foreach (var param in parameters)
        {
            var baseTypeName = param.Type.GetBaseTypeName();
            if (baseTypeName == "unknown") continue;

            string resolvedTypeName = typeResolver.ResolveType(param.Type, currentNamespace, currentUnit);

            _symbols[param.Name.Value] = (currentParamOffset, resolvedTypeName, false, false); // isRead = false
            currentParamOffset += Math.Max(4, memoryLayoutManager.GetSizeOfType(resolvedTypeName, currentUnit));
        }

        int currentLocalOffset = 0;
        foreach (var decl in localDeclarations)
        {
            var baseTypeName = decl.Type.GetBaseTypeName();
            if (baseTypeName == "unknown") continue;

            string resolvedTypeName = typeResolver.ResolveType(decl.Type, currentNamespace, currentUnit);

            int size = memoryLayoutManager.GetSizeOfType(resolvedTypeName, currentUnit);
            currentLocalOffset -= size;
            _symbols[decl.Identifier.Value] = (currentLocalOffset, resolvedTypeName, decl.IsConst, false); // isRead = false
        }
    }

    public void MarkAsRead(string name)
    {
        if (_symbols.TryGetValue(name, out var symbol))
        {
            _symbols[name] = (symbol.Offset, symbol.Type, symbol.IsConst, true);
        }
    }

    public IEnumerable<(string Name, int Line, int Column)> GetUnreadLocals()
    {
        return _symbols
            .Where(kvp => kvp.Value.Offset < 0 && !kvp.Value.IsRead) // Only locals (negative offset)
            .Select(kvp => {
                // This is a bit of a hack to get the declaration location back.
                // A better approach would be to store the DeclarationStatementNode in the symbol table.
                return (kvp.Key, -1, -1);
            });
    }



    private void CollectDeclarations(AstNode? node, List<DeclarationStatementNode> declarations)
    {
        if (node == null) return;
        if (node is DeclarationStatementNode decl) declarations.Add(decl);
        else if (node is BlockStatementNode block) foreach (var stmt in block.Statements) CollectDeclarations(stmt, declarations);
        else if (node is IfStatementNode ifStmt) { CollectDeclarations(ifStmt.ThenBody, declarations); CollectDeclarations(ifStmt.ElseBody, declarations); }
        else if (node is WhileStatementNode whileStmt) CollectDeclarations(whileStmt.Body, declarations);
    }

    public List<(string Name, int Offset, string TypeFqn)> GetDestructibleLocals(FunctionResolver functionResolver)
    {
        var result = new List<(string, int, string)>();
        foreach (var (name, (offset, type, _, _)) in _symbols)
        {
            if (offset < 0 && functionResolver.FindDestructor(type) != null) // Locals have negative offset
            {
                result.Add((name, offset, type));
            }
        }
        return result;
    }

    public bool TryGetSymbol(string name, out int offset, out string type, out bool isConst)
    {
        if (_symbols.TryGetValue(name, out var symbol))
        {
            offset = symbol.Offset;
            type = symbol.Type;
            isConst = symbol.IsConst;
            return true;
        }
        offset = 0; type = string.Empty; isConst = false;
        return false;
    }

    public string GetSymbolType(string name)
    {
        return _symbols.TryGetValue(name, out var symbol)
            ? symbol.Type
            : throw new InvalidOperationException($"Symbol '{name}' not found in current scope.");
    }
}
</file>

<file path="Generator\TypeRepository.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class TypeRepository
{
    private readonly Dictionary<string, StructDefinitionNode> _structs;
    private readonly Dictionary<string, EnumDefinitionNode> _enums;
    private readonly Dictionary<string, CompilationUnitNode> _structUnitMap;
    private readonly Dictionary<string, CompilationUnitNode> _enumUnitMap;

    public TypeRepository(ProgramNode program)
    {
        _structs = program.CompilationUnits.SelectMany(cu => cu.Structs)
            .ToDictionary(s => GetFullyQualifiedName(s));
        _enums = program.CompilationUnits.SelectMany(cu => cu.Enums)
            .ToDictionary(e => GetFullyQualifiedName(e));

        _structUnitMap = new Dictionary<string, CompilationUnitNode>();
        foreach (var cu in program.CompilationUnits)
            foreach (var s in cu.Structs)
                _structUnitMap[GetFullyQualifiedName(s)] = cu;

        _enumUnitMap = new Dictionary<string, CompilationUnitNode>();
        foreach (var cu in program.CompilationUnits)
            foreach (var e in cu.Enums)
                _enumUnitMap[GetFullyQualifiedName(e)] = cu;
    }

    public void RegisterInstantiatedStruct(StructDefinitionNode newStruct, CompilationUnitNode originalUnit)
    {
        var fqn = GetFullyQualifiedName(newStruct);
        if (_structs.ContainsKey(fqn)) return; // Already registered

        _structs[fqn] = newStruct;
        _structUnitMap[fqn] = originalUnit;
    }

    public static string GetFullyQualifiedName(StructDefinitionNode s) => s.Namespace != null ? $"{s.Namespace}::{s.Name}" : s.Name;
    public static string GetFullyQualifiedName(EnumDefinitionNode e) => e.Namespace != null ? $"{e.Namespace}::{e.Name}" : e.Name;

    public string? GetFullyQualifiedOwnerName(FunctionDeclarationNode func)
    {
        if (func.OwnerStructName == null) return null;

        // If the owner's name is mangled (contains "__"), it's already the FQN.
        if (func.OwnerStructName.Contains("__"))
        {
            return func.OwnerStructName;
        }

        // Otherwise, construct the FQN from the namespace and name.
        return func.Namespace != null ? $"{func.Namespace}::{func.OwnerStructName}" : func.OwnerStructName;
    }

    public StructDefinitionNode? FindStruct(string qualifiedName) => _structs.TryGetValue(qualifiedName, out var def) ? def : null;

    public StructDefinitionNode? FindStructByUnqualifiedName(string name, string? currentNamespace)
    {
        // Handle already-mangled names from monomorphization
        if (name.Contains("__")) return FindStruct(name);

        var fqn = currentNamespace != null ? $"{currentNamespace}::{name}" : name;
        if (_structs.TryGetValue(fqn, out var def)) return def;
        return _structs.TryGetValue(name, out def) ? def : null;
    }

    public EnumDefinitionNode? FindEnum(string qualifiedName) => _enums.TryGetValue(qualifiedName, out var def) ? def : null;

    public IEnumerable<StructDefinitionNode> GetAllStructs() => _structs.Values;
    public IEnumerable<EnumDefinitionNode> GetAllEnums() => _enums.Values;

    public CompilationUnitNode GetCompilationUnitForStruct(string structFqn) => _structUnitMap[structFqn];
    public CompilationUnitNode GetCompilationUnitForEnum(string enumFqn) => _enumUnitMap[enumFqn];

    public bool IsStruct(string typeName) => _structs.ContainsKey(typeName.TrimEnd('*'));

    public static string GetTypeNameFromNode(TypeNode node)
    {
        return node switch
        {
            SimpleTypeNode s => s.TypeToken.Value,
            PointerTypeNode p => GetTypeNameFromNode(p.BaseType) + "*",
            GenericInstantiationTypeNode g => $"{g.BaseType.Value}<{string.Join(",", g.TypeArguments.Select(GetTypeNameFromNode))}>",
            _ => throw new NotImplementedException($"GetTypeNameFromNode not implemented for {node.GetType().Name}")
        };
    }
}
</file>

<file path="Generator\VTableManager.cs">
using System;
using System.Collections.Generic;
using System.Linq;

namespace CTilde;

public class VTableManager
{
    private readonly TypeRepository _typeRepository;
    private readonly TypeResolver _typeResolver;

    private readonly Dictionary<string, List<AstNode>> _vtableCache = new();
    private readonly Dictionary<string, bool> _hasVTableCache = new();

    public VTableManager(TypeRepository typeRepository, TypeResolver typeResolver)
    {
        _typeRepository = typeRepository;
        _typeResolver = typeResolver;
    }

    public bool HasVTable(string structFqn)
    {
        if (_hasVTableCache.TryGetValue(structFqn, out var hasVTable)) return hasVTable;

        var structDef = _typeRepository.FindStruct(structFqn);
        if (structDef == null) return false;

        bool result = structDef.Methods.Any(m => m.IsVirtual) || structDef.Destructors.Any(d => d.IsVirtual);
        if (result)
        {
            _hasVTableCache[structFqn] = true;
            return true;
        }

        if (structDef.BaseStructName != null)
        {
            var unit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, structDef.BaseStructName, -1, -1));
            var baseFqn = _typeResolver.ResolveType(baseTypeNode, structDef.Namespace, unit);
            result = HasVTable(baseFqn);
        }

        _hasVTableCache[structFqn] = result;
        return result;
    }

    public List<AstNode> GetVTable(string structFqn)
    {
        if (_vtableCache.TryGetValue(structFqn, out var vtable)) return vtable;

        var structDef = _typeRepository.FindStruct(structFqn) ?? throw new InvalidOperationException($"Struct {structFqn} not found.");

        var newVTable = new List<AstNode>();
        if (structDef.BaseStructName != null)
        {
            var unit = _typeRepository.GetCompilationUnitForStruct(structFqn);
            var baseTypeNode = new SimpleTypeNode(new Token(TokenType.Identifier, structDef.BaseStructName, -1, -1));
            var baseFqn = _typeResolver.ResolveType(baseTypeNode, structDef.Namespace, unit);
            newVTable.AddRange(GetVTable(baseFqn));
        }

        var dtor = structDef.Destructors.FirstOrDefault();

        // A derived dtor is implicitly virtual if the base is virtual.
        bool isBaseDtorVirtual = newVTable.FirstOrDefault() is DestructorDeclarationNode;

        if (dtor != null && (dtor.IsVirtual || isBaseDtorVirtual))
        {
            // If the base had a virtual dtor, we override it.
            if (isBaseDtorVirtual)
            {
                newVTable[0] = dtor;
            }
            // If the base did NOT have a virtual dtor, but this one is explicitly virtual, we add it.
            else // dtor.IsVirtual is true
            {
                newVTable.Insert(0, dtor);
            }
        }

        foreach (var method in structDef.Methods)
        {
            int index = newVTable.FindIndex(m => m is FunctionDeclarationNode f && f.Name == method.Name);
            if (method.IsOverride)
            {
                if (index == -1) throw new InvalidOperationException($"Method '{method.Name}' marked 'override' but no virtual method found in base class.");
                newVTable[index] = method;
            }
            else if (method.IsVirtual)
            {
                if (index != -1) throw new InvalidOperationException($"Virtual method '{method.Name}' cannot be redeclared. Use 'override'.");
                newVTable.Add(method);
            }
        }
        _vtableCache[structFqn] = newVTable;
        return newVTable;
    }

    public int GetMethodVTableIndex(string structFqn, string methodName)
    {
        var vtable = GetVTable(structFqn);
        var index = vtable.FindIndex(n => n is FunctionDeclarationNode f && f.Name == methodName);
        if (index == -1) throw new InvalidOperationException($"Method '{methodName}' is not in the vtable for struct '{structFqn}'.");
        return index;
    }
}
</file>

<file path="Parser\ExpressionParser.cs">
using System;
using System.Collections.Generic;
using System.Globalization;

namespace CTilde;

internal class ExpressionParser
{
    private readonly Parser _parser;
    private int _stringLabelCounter;

    internal ExpressionParser(Parser parser)
    {
        _parser = parser;
    }

    internal ExpressionNode ParseInitializerListExpression()
    {
        var openingBrace = _parser.Eat(TokenType.LeftBrace);
        var values = new List<ExpressionNode>();
        if (_parser.Current.Type != TokenType.RightBrace)
        {
            do { values.Add(ParseExpression()); }
            while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
        }
        _parser.Eat(TokenType.RightBrace);
        return new InitializerListExpressionNode(openingBrace, values);
    }

    internal ExpressionNode ParseExpression() => ParseAssignmentExpression();

    private ExpressionNode ParseAssignmentExpression()
    {
        var left = ParseEqualityExpression();
        if (_parser.Current.Type == TokenType.Assignment)
        {
            var operatorToken = _parser.Current; // Get token before eating
            _parser.Eat(TokenType.Assignment);
            var right = ParseAssignmentExpression();
            if (left is VariableExpressionNode or MemberAccessExpressionNode or UnaryExpressionNode) return new AssignmentExpressionNode(left, right);

            _parser.ReportError($"The left-hand side of an assignment must be a variable, property or indexer.", operatorToken);
            return left; // Return the invalid left-hand side to allow parsing to continue.
        }
        return left;
    }

    private ExpressionNode ParseEqualityExpression()
    {
        var left = ParseRelationalExpression();
        while (_parser.Current.Type is TokenType.DoubleEquals or TokenType.NotEquals)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseRelationalExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseRelationalExpression()
    {
        var left = ParseAdditiveExpression();
        while (_parser.Current.Type is TokenType.LessThan or TokenType.GreaterThan)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseAdditiveExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseAdditiveExpression()
    {
        var left = ParseMultiplicativeExpression();
        while (_parser.Current.Type is TokenType.Plus or TokenType.Minus)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseMultiplicativeExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseMultiplicativeExpression()
    {
        var left = ParseUnaryExpression();
        while (_parser.Current.Type is TokenType.Star or TokenType.Slash)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            var right = ParseUnaryExpression();
            left = new BinaryExpressionNode(left, op, right);
        }
        return left;
    }

    private ExpressionNode ParseUnaryExpression()
    {
        if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "new")
        {
            return ParseNewExpression();
        }
        if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "sizeof")
        {
            return ParseSizeofExpression();
        }
        if (_parser.Current.Type is TokenType.Minus or TokenType.Plus or TokenType.Star or TokenType.Ampersand)
        {
            var op = _parser.Current; _parser.AdvancePosition(1);
            return new UnaryExpressionNode(op, ParseUnaryExpression());
        }
        return ParsePostfixExpression();
    }

    private ExpressionNode ParseSizeofExpression()
    {
        var sizeofToken = _parser.Eat(TokenType.Keyword); // sizeof
        _parser.Eat(TokenType.LeftParen);
        var typeNode = _parser.ParseTypeNode();
        _parser.Eat(TokenType.RightParen);
        return new SizeofExpressionNode(sizeofToken, typeNode);
    }

    private NewExpressionNode ParseNewExpression()
    {
        _parser.Eat(TokenType.Keyword); // new
        var typeNode = _parser.ParseTypeNode();

        _parser.Eat(TokenType.LeftParen);
        var arguments = new List<ExpressionNode>();
        if (_parser.Current.Type != TokenType.RightParen)
        {
            do { arguments.Add(ParseExpression()); }
            while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
        }
        _parser.Eat(TokenType.RightParen);

        return new NewExpressionNode(typeNode, arguments);
    }

    private ExpressionNode ParsePostfixExpression()
    {
        var expr = ParsePrimaryExpression();
        while (true)
        {
            if (_parser.Current.Type == TokenType.LeftParen)
            {
                _parser.Eat(TokenType.LeftParen);
                var arguments = new List<ExpressionNode>();
                if (_parser.Current.Type != TokenType.RightParen)
                {
                    do { arguments.Add(ParseExpression()); }
                    while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
                }
                _parser.Eat(TokenType.RightParen);
                expr = new CallExpressionNode(expr, arguments);
            }
            else if (_parser.Current.Type is TokenType.Dot or TokenType.Arrow)
            {
                var op = _parser.Current; _parser.AdvancePosition(1);
                var member = _parser.Eat(TokenType.Identifier);
                expr = new MemberAccessExpressionNode(expr, op, member);
            }
            else if (_parser.Current.Type == TokenType.DoubleColon)
            {
                _parser.Eat(TokenType.DoubleColon);
                var member = _parser.Eat(TokenType.Identifier);
                expr = new QualifiedAccessExpressionNode(expr, member);
            }
            else { break; }
        }
        return expr;
    }

    private ExpressionNode ParsePrimaryExpression()
    {
        var token = _parser.Current;
        switch (token.Type)
        {
            case TokenType.IntegerLiteral:
                _parser.Eat(TokenType.IntegerLiteral);
                if (int.TryParse(token.Value, out int v)) return new IntegerLiteralNode(token, v);
                _parser.ReportError($"Could not parse int: {token.Value}", token);
                return new IntegerLiteralNode(token, 0);

            case TokenType.HexLiteral:
                _parser.Eat(TokenType.HexLiteral);
                var hex = token.Value.StartsWith("0x") ? token.Value.Substring(2) : token.Value;
                if (int.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out int vHex)) return new IntegerLiteralNode(token, vHex);
                _parser.ReportError($"Could not parse hex: {token.Value}", token);
                return new IntegerLiteralNode(token, 0);

            case TokenType.StringLiteral:
                _parser.Eat(TokenType.StringLiteral);
                return new StringLiteralNode(token, token.Value, $"str{_stringLabelCounter++}");

            case TokenType.Identifier:
                return new VariableExpressionNode(_parser.Eat(TokenType.Identifier));

            case TokenType.LeftParen:
                _parser.Eat(TokenType.LeftParen);
                var expr = ParseExpression();
                _parser.Eat(TokenType.RightParen);
                return expr;
        }

        _parser.ReportError($"Unexpected token in expression: '{token.Type}'", token);
        // Advance past the bad token to prevent an infinite loop and return a dummy node.
        _parser.AdvancePosition(1);
        return new IntegerLiteralNode(token, 0);
    }
}
</file>

<file path="Parser\Parser.cs">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using CTilde.Diagnostics;

namespace CTilde;

public class Parser
{
    internal readonly List<Token> _tokens;
    internal int _position;
    internal string? _currentNamespace;
    internal readonly List<ImportDirectiveNode> _imports = new();
    private string _filePath = "";

    public List<Diagnostic> Diagnostics { get; } = new();

    private readonly ExpressionParser _expressionParser;
    private readonly StatementParser _statementParser;

    public Parser(List<Token> tokens)
    {
        _tokens = tokens;
        _position = 0;
        _expressionParser = new ExpressionParser(this);
        _statementParser = new StatementParser(this, _expressionParser);
    }

    internal Token Current => _position < _tokens.Count ? _tokens[_position] : _tokens[^1];
    internal Token Previous => _position > 0 ? _tokens[_position - 1] : _tokens[0];
    internal Token Peek(int offset) => _position + offset < _tokens.Count ? _tokens[_position + offset] : _tokens[^1];

    internal void ReportError(string message, Token token)
    {
        Diagnostics.Add(new Diagnostic(_filePath, message, token.Line, token.Column));
    }

    internal void ReportErrorAfter(string message, Token previousToken)
    {
        var line = previousToken.Line;
        var col = previousToken.Column + previousToken.Value.Length;
        Diagnostics.Add(new Diagnostic(_filePath, message, line, col));
    }

    internal Token Eat(TokenType expectedType)
    {
        var currentToken = Current;
        if (currentToken.Type == expectedType)
        {
            _position++;
            return currentToken;
        }

        string message = $"Expected '{expectedType}' but got '{currentToken.Type}' ('{currentToken.Value}')";

        // Heuristic: If we expect a statement/block terminator, the error is likely at the end of the previous construct.
        if (expectedType is TokenType.Semicolon or TokenType.RightBrace or TokenType.RightParen)
        {
            // Report the error at the position immediately *after* the last successfully consumed token.
            ReportErrorAfter(message, Previous);
        }
        else
        {
            ReportError(message, currentToken);
        }

        return new Token(expectedType, string.Empty, currentToken.Line, currentToken.Column); // Return a dummy token
    }

    internal void AdvancePosition(int amount) => _position += amount;

    public List<ImportDirectiveNode> GetImports() => _imports;

    public CompilationUnitNode Parse(string filePath)
    {
        _filePath = filePath;
        var usings = new List<UsingDirectiveNode>();
        var structs = new List<StructDefinitionNode>();
        var functions = new List<FunctionDeclarationNode>();
        var enums = new List<EnumDefinitionNode>();

        while (Current.Type != TokenType.Unknown)
        {
            try
            {
                if (Current.Type == TokenType.Hash)
                {
                    var hashKeyword = Peek(1);
                    if (hashKeyword.Type == TokenType.Identifier && hashKeyword.Value == "import")
                    {
                        _imports.Add(ParseImportDirective());
                    }
                    else if (hashKeyword.Type == TokenType.Identifier && hashKeyword.Value == "include")
                    {
                        ParseIncludeDirective(); // Handle and skip #include
                    }
                    else
                    {
                        ReportError($"Unexpected directive after '#': '{hashKeyword.Value}'", hashKeyword);
                        AdvancePosition(2); // Skip '#' and the bad identifier
                    }
                }
                else if (Current.Type == TokenType.Keyword && Current.Value == "using")
                {
                    usings.Add(ParseUsingDirective());
                }
                else if (Current.Type == TokenType.Keyword && Current.Value == "namespace")
                {
                    ParseNamespaceDirective();
                }
                else if (Current.Type == TokenType.Keyword && Current.Value == "struct")
                {
                    structs.Add(ParseStructDefinition());
                }
                else if (Current.Type == TokenType.Keyword && Current.Value == "enum")
                {
                    enums.Add(ParseEnumDefinition());
                }
                else
                {
                    functions.Add(ParseGlobalFunction());
                }
            }
            catch (Exception) // Catch potential cascading failures from bad tokens
            {
                // Synchronize to the next likely statement start to continue parsing
                while (Current.Type != TokenType.Semicolon && Current.Type != TokenType.RightBrace && Current.Type != TokenType.Unknown)
                {
                    AdvancePosition(1);
                }
                // Also consume the synchronizing token
                if (Current.Type != TokenType.Unknown) AdvancePosition(1);
            }
        }

        var unitNode = new CompilationUnitNode(filePath, usings, structs, functions, enums);
        SetParents(unitNode, null);
        return unitNode;
    }

    private UsingDirectiveNode ParseUsingDirective()
    {
        Eat(TokenType.Keyword); // using
        var firstIdentifier = Eat(TokenType.Identifier);
        string namespaceName;
        string? alias = null;

        if (Current.Type == TokenType.Assignment) // This is 'using alias = namespace;'
        {
            alias = firstIdentifier.Value; // 'rl' in 'using rl = raylib;'
            Eat(TokenType.Assignment);
            namespaceName = Eat(TokenType.Identifier).Value; // 'raylib' in 'using rl = raylib;'
        }
        else // This is 'using namespace;'
        {
            namespaceName = firstIdentifier.Value; // 'raylib' in 'using raylib;'
        }

        Eat(TokenType.Semicolon);
        return new UsingDirectiveNode(namespaceName, alias);
    }

    private void ParseNamespaceDirective()
    {
        Eat(TokenType.Keyword); // namespace
        var name = Eat(TokenType.Identifier);
        Eat(TokenType.Semicolon);
        _currentNamespace = name.Value;
    }

    private ImportDirectiveNode ParseImportDirective()
    {
        Eat(TokenType.Hash);
        Eat(TokenType.Identifier); // import
        var libNameToken = Eat(TokenType.StringLiteral);
        return new ImportDirectiveNode(libNameToken.Value);
    }

    private void ParseIncludeDirective()
    {
        Eat(TokenType.Hash);
        Eat(TokenType.Identifier); // include
        Eat(TokenType.StringLiteral); // "filename"
        // No AST node for include, as it's handled by the preprocessor
    }

    private EnumDefinitionNode ParseEnumDefinition()
    {
        Eat(TokenType.Keyword); // enum
        var enumName = Eat(TokenType.Identifier);
        Eat(TokenType.LeftBrace);

        var members = new List<EnumMemberNode>();
        int currentValue = 0; // Default enum value starts at 0 and increments

        while (Current.Type != TokenType.RightBrace && Current.Type != TokenType.Unknown)
        {
            var memberName = Eat(TokenType.Identifier);
            if (Current.Type == TokenType.Assignment)
            {
                Eat(TokenType.Assignment);
                var valueToken = Eat(TokenType.IntegerLiteral);
                if (!int.TryParse(valueToken.Value, out currentValue))
                {
                    ReportError($"Invalid integer value for enum member '{memberName.Value}': '{valueToken.Value}'", valueToken);
                }
            }
            members.Add(new EnumMemberNode(memberName, currentValue));
            currentValue++; // Increment for next default value

            if (Current.Type == TokenType.Comma)
            {
                Eat(TokenType.Comma);
            }
            else if (Current.Type != TokenType.RightBrace)
            {
                ReportError($"Expected ',' or '}}' after enum member '{memberName.Value}'", Current);
                break;
            }
        }

        Eat(TokenType.RightBrace);
        Eat(TokenType.Semicolon);
        return new EnumDefinitionNode(enumName.Value, _currentNamespace, members);
    }

    private StructDefinitionNode ParseStructDefinition()
    {
        Eat(TokenType.Keyword); // struct
        var structName = Eat(TokenType.Identifier);

        var genericParameters = new List<Token>();
        if (Current.Type == TokenType.LessThan)
        {
            Eat(TokenType.LessThan);
            do { genericParameters.Add(Eat(TokenType.Identifier)); }
            while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
            Eat(TokenType.GreaterThan);
        }

        string? baseStructName = null;
        if (Current.Type == TokenType.Colon)
        {
            Eat(TokenType.Colon);
            baseStructName = Eat(TokenType.Identifier).Value;
        }

        Eat(TokenType.LeftBrace);

        var members = new List<MemberVariableNode>();
        var methods = new List<FunctionDeclarationNode>();
        var constructors = new List<ConstructorDeclarationNode>();
        var destructors = new List<DestructorDeclarationNode>();

        var currentAccess = AccessSpecifier.Private;

        while (Current.Type != TokenType.RightBrace && Current.Type != TokenType.Unknown)
        {
            if (Current.Type == TokenType.Keyword && (Current.Value == "public" || Current.Value == "private"))
            {
                currentAccess = (Current.Value == "public") ? AccessSpecifier.Public : AccessSpecifier.Private;
                Eat(TokenType.Keyword);
                Eat(TokenType.Colon);
                continue;
            }

            bool isConst = false;
            bool isVirtual = false;
            bool isOverride = false;
            var startToken = Current;

            if (Current.Type == TokenType.Keyword && Current.Value == "const")
            {
                isConst = true;
                Eat(TokenType.Keyword);
            }

            if (Current.Type == TokenType.Keyword && Current.Value == "virtual")
            {
                isVirtual = true;
                Eat(TokenType.Keyword);
            }
            else if (Current.Type == TokenType.Keyword && Current.Value == "override")
            {
                isOverride = true;
                Eat(TokenType.Keyword);
            }

            if (isVirtual && isOverride) ReportError("A method cannot be both 'virtual' and 'override'.", startToken);

            if (Current.Type == TokenType.Tilde)
            {
                destructors.Add(ParseDestructor(structName.Value, currentAccess, isVirtual));
                continue;
            }

            // Check for constructor (e.g. `List(...)` not `List<T>(...)`)
            if (Current.Type == TokenType.Identifier && Current.Value == structName.Value && Peek(1).Type == TokenType.LeftParen)
            {
                if (isVirtual || isOverride || isConst) ReportError("Constructors cannot be marked 'virtual', 'override', or 'const'.", startToken);
                constructors.Add(ParseConstructor(structName.Value, baseStructName, currentAccess));
                continue;
            }

            var type = ParseTypeNode();

            Token name;
            if (Current.Type == TokenType.Keyword && Current.Value == "operator")
            {
                Eat(TokenType.Keyword); // operator
                var opToken = Current;
                _position++;
                name = new Token(TokenType.Identifier, $"operator_{NameMangler.MangleOperator(opToken.Value)}", opToken.Line, opToken.Column);
            }
            else
            {
                name = Eat(TokenType.Identifier);
            }

            if (Current.Type == TokenType.LeftParen)
            {
                var methodNode = FinishParsingFunction(type, name.Value, structName.Value, currentAccess, isVirtual, isOverride, _currentNamespace, true);
                methods.Add(methodNode);
            }
            else
            {
                if (isVirtual || isOverride) ReportError("Only methods can be marked 'virtual' or 'override'.", startToken);
                members.Add(new MemberVariableNode(isConst, type, name, currentAccess));
                Eat(TokenType.Semicolon);
            }
        }

        Eat(TokenType.RightBrace);
        Eat(TokenType.Semicolon);
        return new StructDefinitionNode(structName.Value, genericParameters, baseStructName, _currentNamespace, members, methods, constructors, destructors);
    }


    private ConstructorDeclarationNode ParseConstructor(string ownerStructName, string? baseStructName, AccessSpecifier access)
    {
        var nameToken = Eat(TokenType.Identifier);
        var parameters = ParseParameterList(false);

        BaseInitializerNode? baseInitializer = null;
        if (Current.Type == TokenType.Colon)
        {
            if (baseStructName == null) ReportError($"Struct '{ownerStructName}' cannot have a base initializer because it does not inherit from another struct.", nameToken);
            Eat(TokenType.Colon);
            var baseName = Eat(TokenType.Identifier);
            // No error here, Eat will report if baseName.Value != baseStructName

            Eat(TokenType.LeftParen);
            var arguments = new List<ExpressionNode>();
            if (Current.Type != TokenType.RightParen)
            {
                do { arguments.Add(_expressionParser.ParseExpression()); }
                while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
            }
            Eat(TokenType.RightParen);
            baseInitializer = new BaseInitializerNode(arguments);
        }

        var body = _statementParser.ParseBlockStatement();
        return new ConstructorDeclarationNode(ownerStructName, _currentNamespace, access, parameters, baseInitializer, body);
    }

    private DestructorDeclarationNode ParseDestructor(string ownerStructName, AccessSpecifier access, bool isVirtual)
    {
        Eat(TokenType.Tilde);
        var name = Eat(TokenType.Identifier);
        if (name.Value != ownerStructName) ReportError($"Destructor name '~{name.Value}' must match struct name '{ownerStructName}'.", name);

        Eat(TokenType.LeftParen);
        Eat(TokenType.RightParen);

        var body = _statementParser.ParseBlockStatement();
        return new DestructorDeclarationNode(ownerStructName, _currentNamespace, access, isVirtual, body);
    }


    public void SetParents(AstNode node, AstNode? parent)
    {
        node.Parent = parent;
        foreach (var property in node.GetType().GetProperties())
        {
            if (property.CanWrite && property.Name == "Parent") continue;
            if (property.GetValue(node) is AstNode child)
            {
                SetParents(child, node);
            }
            else if (property.GetValue(node) is IEnumerable<AstNode> children)
            {
                foreach (var c in children.ToList()) // ToList to avoid mutation issues
                {
                    SetParents(c, node);
                }
            }
        }
    }

    internal TypeNode ParseTypeNode()
    {
        Token baseTypeToken;
        var current = Current;

        // 1. Parse the base name (which could be qualified)
        if (current.Type == TokenType.Keyword && current.Value == "struct")
        {
            Eat(TokenType.Keyword);
            baseTypeToken = Eat(TokenType.Identifier);
        }
        else if (current.Type == TokenType.Keyword && (current.Value is "int" or "char" or "void"))
        {
            baseTypeToken = Eat(TokenType.Keyword);
        }
        else if (current.Type == TokenType.Identifier)
        {
            baseTypeToken = Eat(TokenType.Identifier);
            // Check for `::`
            if (Current.Type == TokenType.DoubleColon)
            {
                Eat(TokenType.DoubleColon);
                var memberName = Eat(TokenType.Identifier);
                baseTypeToken = new Token(TokenType.Identifier, $"{baseTypeToken.Value}::{memberName.Value}", baseTypeToken.Line, baseTypeToken.Column);
            }
        }
        else
        {
            ReportError($"Expected a type name but found '{current.Type}' ('{current.Value}').", current);
            AdvancePosition(1); // Consume the bad token to prevent infinite loop
            return new SimpleTypeNode(new Token(TokenType.Identifier, "unknown", current.Line, current.Column));
        }

        // 2. Parse optional generic arguments
        TypeNode typeNode;
        if (Current.Type == TokenType.LessThan)
        {
            Eat(TokenType.LessThan);
            var typeArgs = new List<TypeNode>();
            do { typeArgs.Add(ParseTypeNode()); }
            while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
            Eat(TokenType.GreaterThan);
            typeNode = new GenericInstantiationTypeNode(baseTypeToken, typeArgs);
        }
        else
        {
            typeNode = new SimpleTypeNode(baseTypeToken);
        }

        // 3. Parse optional pointers
        while (Current.Type == TokenType.Star)
        {
            Eat(TokenType.Star);
            typeNode = new PointerTypeNode(typeNode);
        }
        return typeNode;
    }


    private List<ParameterNode> ParseParameterList(bool addThisPointer)
    {
        Eat(TokenType.LeftParen);
        var parameters = new List<ParameterNode>();
        if (Current.Type != TokenType.RightParen)
        {
            do
            {
                var paramType = ParseTypeNode();
                var paramName = Eat(TokenType.Identifier);
                parameters.Add(new ParameterNode(paramType, paramName));
            } while (Current.Type == TokenType.Comma && Eat(TokenType.Comma) != null);
        }
        Eat(TokenType.RightParen);
        return parameters;
    }

    private FunctionDeclarationNode ParseGlobalFunction()
    {
        var returnType = ParseTypeNode();
        var identifier = Eat(TokenType.Identifier);
        return FinishParsingFunction(returnType, identifier.Value, null, AccessSpecifier.Public, false, false, _currentNamespace, false);
    }

    private FunctionDeclarationNode FinishParsingFunction(TypeNode returnType, string name, string? ownerStructName, AccessSpecifier accessLevel, bool isVirtual, bool isOverride, string? namespaceName, bool isMethod)
    {
        var parameters = ParseParameterList(isMethod);

        if (isMethod && ownerStructName != null)
        {
            // The `this` pointer type will be resolved later during semantic analysis.
            // For now, we create a placeholder.
            var thisType = new PointerTypeNode(new SimpleTypeNode(new Token(TokenType.Identifier, ownerStructName, -1, -1)));
            var thisName = new Token(TokenType.Identifier, "this", -1, -1);
            var thisParam = new ParameterNode(thisType, thisName);
            parameters.Insert(0, thisParam);
        }

        StatementNode? body = null;
        if (Current.Type == TokenType.LeftBrace)
        {
            body = _statementParser.ParseBlockStatement();
        }
        else
        {
            Eat(TokenType.Semicolon); // For function prototypes
        }

        return new FunctionDeclarationNode(returnType, name, parameters, body, ownerStructName, accessLevel, isVirtual, isOverride, namespaceName);
    }
}
</file>

<file path="Parser\StatementParser.cs">
using System;
using System.Collections.Generic;

namespace CTilde;

internal class StatementParser
{
    private readonly Parser _parser;
    private readonly ExpressionParser _expressionParser;

    internal StatementParser(Parser parser, ExpressionParser expressionParser)
    {
        _parser = parser;
        _expressionParser = expressionParser;
    }

    internal BlockStatementNode ParseBlockStatement()
    {
        _parser.Eat(TokenType.LeftBrace);
        var statements = new List<StatementNode>();
        while (_parser.Current.Type != TokenType.RightBrace && _parser.Current.Type != TokenType.Unknown)
        {
            statements.Add(ParseStatement());
        }
        _parser.Eat(TokenType.RightBrace);
        return new BlockStatementNode(statements);
    }

    /// <summary>
    /// Peeks ahead in the token stream to determine if the upcoming sequence of tokens is a declaration.
    /// This is a classic C/C++ parsing problem, as `A * B;` could be a multiplication or a declaration.
    /// This lookahead is read-only and does not consume tokens or report errors.
    /// </summary>
    private bool IsDeclaration()
    {
        int originalPosition = _parser._position;
        try
        {
            // Create a new parser instance for a safe lookahead, to avoid modifying the main parser's state
            // and to suppress error reporting during the lookahead.
            var tempParser = new Parser(new List<Token>(_parser._tokens.ToArray()))
            {
                _position = originalPosition
            };

            // A declaration can optionally start with const.
            if (tempParser.Current.Type == TokenType.Keyword && tempParser.Current.Value == "const")
            {
                tempParser.AdvancePosition(1);
            }

            // Now, try to parse a type from the temporary state.
            tempParser.ParseTypeNode();

            // If we get here, it parsed a type. A declaration must be followed by an identifier.
            return tempParser.Current.Type == TokenType.Identifier;
        }
        catch
        {
            return false;
        }
    }


    internal StatementNode ParseStatement()
    {
        // First, check for keywords that unambiguously start a statement.
        if (_parser.Current.Type == TokenType.Keyword)
        {
            switch (_parser.Current.Value)
            {
                case "return": return ParseReturnStatement();
                case "if": return ParseIfStatement();
                case "while": return ParseWhileStatement();
                case "delete": return ParseDeleteStatement();
            }
        }

        // Check for block statements.
        if (_parser.Current.Type == TokenType.LeftBrace)
        {
            return ParseBlockStatement();
        }

        // Now, use the lookahead to resolve the ambiguity between a declaration and an expression.
        if (IsDeclaration())
        {
            return ParseDeclarationStatement();
        }

        // If it's not a declaration or any other statement type, it must be an expression.
        var expression = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.Semicolon);
        return new ExpressionStatementNode(expression);
    }

    private DeleteStatementNode ParseDeleteStatement()
    {
        _parser.Eat(TokenType.Keyword); // delete
        var expr = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.Semicolon);
        return new DeleteStatementNode(expr);
    }

    private IfStatementNode ParseIfStatement()
    {
        _parser.Eat(TokenType.Keyword);
        _parser.Eat(TokenType.LeftParen);
        var condition = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.RightParen);
        var thenBody = ParseStatement();
        StatementNode? elseBody = null;
        if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "else")
        {
            _parser.Eat(TokenType.Keyword);
            elseBody = ParseStatement();
        }
        return new IfStatementNode(condition, thenBody, elseBody);
    }

    private StatementNode ParseDeclarationStatement()
    {
        bool isConst = false;
        if (_parser.Current.Type == TokenType.Keyword && _parser.Current.Value == "const")
        {
            isConst = true;
            _parser.Eat(TokenType.Keyword);
        }

        var typeNode = _parser.ParseTypeNode();
        var identifier = _parser.Eat(TokenType.Identifier);

        ExpressionNode? initializer = null;
        List<ExpressionNode>? ctorArgs = null;

        if (_parser.Current.Type == TokenType.Assignment)
        {
            _parser.Eat(TokenType.Assignment);
            if (_parser.Current.Type == TokenType.LeftBrace) initializer = _expressionParser.ParseInitializerListExpression();
            else initializer = _expressionParser.ParseExpression();
        }
        else if (_parser.Current.Type == TokenType.LeftParen)
        {
            _parser.Eat(TokenType.LeftParen);
            ctorArgs = new List<ExpressionNode>();
            if (_parser.Current.Type != TokenType.RightParen)
            {
                do { ctorArgs.Add(_expressionParser.ParseExpression()); }
                while (_parser.Current.Type == TokenType.Comma && _parser.Eat(TokenType.Comma) != null);
            }
            _parser.Eat(TokenType.RightParen);
        }
        else if (isConst)
        {
            _parser.ReportError($"Constant variable '{identifier.Value}' must be initialized.", identifier);
        }
        _parser.Eat(TokenType.Semicolon);
        return new DeclarationStatementNode(isConst, typeNode, identifier, initializer, ctorArgs);
    }

    private WhileStatementNode ParseWhileStatement()
    {
        _parser.Eat(TokenType.Keyword);
        _parser.Eat(TokenType.LeftParen);
        var condition = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.RightParen);
        var body = ParseStatement();
        return new WhileStatementNode(condition, body);
    }

    private ReturnStatementNode ParseReturnStatement()
    {
        _parser.Eat(TokenType.Keyword);
        ExpressionNode? expression = null;
        if (_parser.Current.Type != TokenType.Semicolon) expression = _expressionParser.ParseExpression();
        _parser.Eat(TokenType.Semicolon);
        return new ReturnStatementNode(expression);
    }
}
</file>

<file path="Tokenizer\Token.cs">
namespace CTilde;

public record Token(TokenType Type, string Value, int Line, int Column);
</file>

<file path="Tokenizer\Tokenizer.cs">
using System.Collections.Generic;
using System.Text;

namespace CTilde;

public class Tokenizer
{
    private static readonly HashSet<string> Keywords =
    [
        "int",
        "void",
        "return",
        "while",
        "if",
        "else",
        "struct",
        "char",
        "public",
        "private",
        "namespace",
        "using",
        "const",
        "enum",
        "virtual",
        "override",
        "new",
        "delete",
        "operator",
        "sizeof"
    ];

    public static List<Token> Tokenize(string input)
    {
        List<Token> tokens = [];
        int i = 0;
        int line = 1;
        int column = 1;

        while (i < input.Length)
        {
            var startColumn = column;
            char c = input[i];

            if (c == '\n')
            {
                line++;
                column = 1;
                i++;
                continue;
            }
            if (char.IsWhiteSpace(c))
            {
                i++;
                column++;
                continue;
            }

            if (c == '/' && i + 1 < input.Length && input[i + 1] == '/')
            {
                while (i < input.Length && input[i] != '\n')
                {
                    i++;
                }
                // Let the main loop handle the newline character and line/column update
                continue;
            }

            if (c == '"')
            {
                i++;
                column++;
                var sb = new StringBuilder();
                while (i < input.Length && input[i] != '"')
                {
                    char current = input[i];
                    if (current == '\\' && i + 1 < input.Length)
                    {
                        i++;
                        column++;
                        switch (input[i])
                        {
                            case 'n': sb.Append('\n'); break;
                            case 't': sb.Append('\t'); break;
                            case '\\': sb.Append('\\'); break;
                            case '"': sb.Append('"'); break;
                            default: sb.Append('\\'); sb.Append(input[i]); break;
                        }
                    }
                    else sb.Append(current);
                    i++;
                    column++;
                }
                if (i < input.Length)
                {
                    i++;
                    column++;
                }
                tokens.Add(new Token(TokenType.StringLiteral, sb.ToString(), line, startColumn));
                continue;
            }

            switch (c)
            {
                case '~': tokens.Add(new(TokenType.Tilde, "~", line, startColumn)); i++; column++; continue;
                case '#': tokens.Add(new(TokenType.Hash, "#", line, startColumn)); i++; column++; continue;
                case '.': tokens.Add(new(TokenType.Dot, ".", line, startColumn)); i++; column++; continue;
                case ':':
                    if (i + 1 < input.Length && input[i + 1] == ':') { tokens.Add(new(TokenType.DoubleColon, "::", line, startColumn)); i += 2; column += 2; }
                    else { tokens.Add(new(TokenType.Colon, ":", line, startColumn)); i++; column++; }
                    continue;
                case '(': tokens.Add(new(TokenType.LeftParen, "(", line, startColumn)); i++; column++; continue;
                case ')': tokens.Add(new(TokenType.RightParen, ")", line, startColumn)); i++; column++; continue;
                case '{': tokens.Add(new(TokenType.LeftBrace, "{", line, startColumn)); i++; column++; continue;
                case '}': tokens.Add(new(TokenType.RightBrace, "}", line, startColumn)); i++; column++; continue;
                case ';': tokens.Add(new(TokenType.Semicolon, ";", line, startColumn)); i++; column++; continue;
                case ',': tokens.Add(new(TokenType.Comma, ",", line, startColumn)); i++; column++; continue;
                case '+': tokens.Add(new(TokenType.Plus, "+", line, startColumn)); i++; column++; continue;
                case '-':
                    if (i + 1 < input.Length && input[i + 1] == '>') { tokens.Add(new(TokenType.Arrow, "->", line, startColumn)); i += 2; column += 2; }
                    else { tokens.Add(new(TokenType.Minus, "-", line, startColumn)); i++; column++; }
                    continue;
                case '*': tokens.Add(new(TokenType.Star, "*", line, startColumn)); i++; column++; continue;
                case '/': tokens.Add(new(TokenType.Slash, "/", line, startColumn)); i++; column++; continue;
                case '&': tokens.Add(new(TokenType.Ampersand, "&", line, startColumn)); i++; column++; continue;
                case '<': tokens.Add(new(TokenType.LessThan, "<", line, startColumn)); i++; column++; continue;
                case '>': tokens.Add(new(TokenType.GreaterThan, ">", line, startColumn)); i++; column++; continue;
                case '=':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.DoubleEquals, "==", line, startColumn)); i += 2; column += 2; }
                    else { tokens.Add(new(TokenType.Assignment, "=", line, startColumn)); i++; column++; }
                    continue;
                case '!':
                    if (i + 1 < input.Length && input[i + 1] == '=') { tokens.Add(new(TokenType.NotEquals, "!=", line, startColumn)); i += 2; column += 2; }
                    else { tokens.Add(new(TokenType.Unknown, c.ToString(), line, startColumn)); i++; column++; }
                    continue;
            }

            if (c == '0' && i + 1 < input.Length && (input[i + 1] == 'x' || input[i + 1] == 'X'))
            {
                int start = i;
                i += 2;
                while (i < input.Length && "0123456789abcdefABCDEF".Contains(input[i])) i++;
                var literalValue = input.Substring(start, i - start);
                tokens.Add(new Token(TokenType.HexLiteral, literalValue, line, startColumn));
                column += literalValue.Length;
                continue;
            }
            if (char.IsDigit(c))
            {
                int start = i;
                while (i < input.Length && char.IsDigit(input[i])) i++;
                string value = input.Substring(start, i - start);
                tokens.Add(new(TokenType.IntegerLiteral, value, line, startColumn));
                column += value.Length;
                continue;
            }
            if (char.IsLetter(c) || c == '_')
            {
                int start = i;
                while (i < input.Length && (char.IsLetterOrDigit(input[i]) || input[i] == '_')) i++;
                string value = input.Substring(start, i - start);
                tokens.Add(new(Keywords.Contains(value) ? TokenType.Keyword : TokenType.Identifier, value, line, startColumn));
                column += value.Length;
                continue;
            }
            tokens.Add(new(TokenType.Unknown, c.ToString(), line, startColumn));
            i++;
            column++;
        }
        tokens.Add(new(TokenType.Unknown, string.Empty, line, column)); // EOF token
        return tokens;
    }
}
</file>

<file path="Tokenizer\TokenType.cs">
namespace CTilde;

public enum TokenType
{
    Unknown,
    Keyword,
    Enum,
    Identifier,
    IntegerLiteral,
    HexLiteral,
    StringLiteral,
    Semicolon,
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Comma,
    Dot,
    Hash,
    Assignment,
    Plus,
    Minus,
    Star,
    Slash,

    DoubleEquals,
    NotEquals,
    LessThan,
    GreaterThan,

    Ampersand,
    Arrow,
    Colon,
    DoubleColon,
    Tilde
}
</file>

<file path="list.c">
namespace std;

// A generic dynamic list implementation.
// The list owns the backing array and copies items by value.
struct List<T>
{
private:
    T* m_data;          // Pointer to the array of T
    int m_count;        // Number of elements currently in the list
    int m_capacity;     // Allocated capacity of the backing array

    void ensure_capacity(int min_capacity)
    {
        if (m_capacity < min_capacity)
        {
            int new_capacity = m_capacity * 2;
        
            if (new_capacity < min_capacity) 
            {
                new_capacity = min_capacity;
            }
        
            if (new_capacity < 4) 
            {
                new_capacity = 4;
            }

            T* new_data = malloc(new_capacity * sizeof(T)); 
        
            if (m_data != 0)
            {
                memcpy(new_data, m_data, m_count * sizeof(T));
                free(m_data);
            }
        
            m_data = new_data;
            m_capacity = new_capacity;
        }
    }

public:
    List()
    {
        m_data = 0;
        m_count = 0;
        m_capacity = 0;
    }

    ~List()
    {
        if (m_data != 0)
        {
            free(m_data);
        }
    }
    
    void add(T item)
    {
        ensure_capacity(m_count + 1);
        *(m_data + m_count) = item;
        m_count = m_count + 1;
    }

    T get(int index)
    {
        return *(m_data + index);
    }
    
    void set(int index, T item)
    {
        *(m_data + index) = item;
    }

    int count()
    {
        return m_count;
    }
    
    void remove_at(int index)
    {
        if (index < m_count - 1)
        {
            memcpy(m_data + index, m_data + index + 1, (m_count - index - 1) * sizeof(T));
        }

        m_count = m_count - 1;
    }
    
    void clear()
    {
        m_count = 0;
    }
};
</file>

<file path="main.c">
#import "raylib.dll"
#import "msvcrt.dll"
#include "raylib.c"
#include "string.c"
#include "list.c"
#include "position.c"
#include "text_object.c"

using rl = raylib;
using game;
using std;

int main() 
{
    const int screenWidth = 800;
    const int screenHeight = 600;

    rl::InitWindow(screenWidth, screenHeight, "CTilde Generic List Demo");
    rl::SetTargetFPS(60);
    
    rl::Color rayWhite = {245, 245, 245, 255};
    rl::Color red = {230, 41, 55, 255};
    rl::Color blue = {0, 121, 241, 255};
    
    List<TextObject*> textObjects;
    textObjects.add(new TextObject(100, 100, "First Item", 20, red));
    textObjects.add(new TextObject(200, 200, "Second Item", 30, blue));
    textObjects.add(new TextObject(300, 300, "Third Item", 40, red));

    while (rl::WindowShouldClose() == 0) 
    {
        rl::BeginDrawing();
        rl::ClearBackground(rayWhite);

        int i = 0;
        while (i < textObjects.count())
        {
           TextObject* txt = textObjects.get(i);
           txt->draw();
           i = i + 1;
        }

        rl::EndDrawing();
    }
    
    int j = 0;
    while (j < textObjects.count())
    {
        TextObject* to_delete = textObjects.get(j);
        delete to_delete;
        j = j + 1;
    }
    
    rl::CloseWindow();
    
    return 0;
}
</file>

<file path="merged.c">
#import "raylib.dll"
namespace raylib;

struct Color 
{
    char r;
    char g;
    char b;
    char a;
};

void InitWindow(int width, int height, int title);
int WindowShouldClose();
void BeginDrawing();
void EndDrawing();
void ClearBackground(Color color);
void DrawText(int text, int posX, int posY, int fontSize, Color color);
void CloseWindow();

using raylib;

struct TextObject 
{
private:
    int x;

public:
    int y;
    int text;
    int fontSize;
    Color color;

    void init(int startX, int startY, int newText, int fSize, Color newColor) 
    {
        x = startX;
        y = startY;
        text = newText;
        fontSize = fSize;
        color = newColor;
    }

    void draw() 
    {
        DrawText(text, x, y, fontSize, color);
    }
    
    void move_right() 
    {
        x = x + 1;
    }
};


using raylib;

int main() 
{
    int screenWidth = 800;
    int screenHeight = 600;

    Color rayWhite = {245, 245, 245, 255};
    Color maroon = {190, 33, 55, 255};

    TextObject myText;
    // Initialize the object using its public method.
    // Direct access like `myText.x = 140;` would fail because x is private.
    myText.init(140, 275, "Encapsulation!", 20, maroon);

    InitWindow(screenWidth, screenHeight, "CTilde with Access Specifiers!");

    while (WindowShouldClose() == 0) 
    {
        BeginDrawing();
        ClearBackground(rayWhite);
        
        myText.move_right();
        myText.draw();
        
        EndDrawing();
    }

    CloseWindow();
    
    return 0;
}
</file>

<file path="position.c">
namespace game;

struct Position
{
public:
    int x;
    int y;

    Position(int startX, int startY)
    {
        x = startX;
        y = startY;
    }

    virtual ~Position()
    {
        // Base destructor
    }

    virtual void move_left(int deltaTime)
    {
        if (raylib::IsKeyDown(raylib::KeyboardKey::KEY_A))
        {
            x = x - (100 * deltaTime / 1000); // Default implementation
        }
    }
};
</file>

<file path="raylib.c">
namespace raylib;

struct Color 
{
    char r;
    char g;
    char b;
    char a;

    //Color(char r, char g, char b, char a) 
    //{
    //    this.r = r;
    //    this.g = g;
    //    this.b = b;
    //    this.a = a;
    //}
};

enum KeyboardKey 
{
    KEY_D = 68,
    KEY_A = 65,
    KEY_W = 87,
    KEY_S = 83,
    KEY_LEFT = 263,
    KEY_RIGHT = 262,
    KEY_UP = 265,
    KEY_DOWN = 264
};

void InitWindow(int width, int height, char* title);
void SetTargetFPS(int fps);
int WindowShouldClose();
void BeginDrawing();
void EndDrawing();
void ClearBackground(Color color);
void DrawText(char* text, int posX, int posY, int fontSize, Color color);
void DrawLine(int startPosX, int startPosY, int endPosX, int endPosY, Color color); // NEW
void CloseWindow();
int GetFPS();
int IsKeyDown(int key);
</file>

<file path="string.c">
int strlen(char* str);
void strcpy(char* dest, char* src);
void memcpy(char* dest, char* src, int count);
int malloc(int size);
void free(int ptr);

namespace std;

struct string 
{
private:
    int m_length;
    char* m_data;

public:
    string(char* literal) 
    {
        m_length = strlen(literal);
        m_data = malloc(m_length + 1);
        strcpy(m_data, literal);
    }
    
    string(string* other)
    {
        m_length = other->length();
        m_data = malloc(m_length + 1);
        strcpy(m_data, other->c_str());
    }

    ~string() 
    {
        free(m_data);
    }
    
    string operator+(string* other)
    {
        int new_len = m_length + other->length();
        char* new_buffer = malloc(new_len + 1);
        
        memcpy(new_buffer, m_data, m_length);
        memcpy(new_buffer + m_length, other->c_str(), other->length());
        *(new_buffer + new_len) = 0;
        
        string result(new_buffer);
        
        free(new_buffer);
        
        return result;
    }

    char* c_str() 
    {
        return m_data;
    }

    int length() 
    {
        return m_length;
    }
};
</file>

<file path="text_object.c">
using raylib;
using game;
using std;

struct TextObject : Position
{
private:
    int speed; 
    string* m_text;

public:
    int fontSize;
    Color color;

    TextObject(int startX, int startY, char* literal, int fSize, Color newColor)
        : Position(startX, startY)
    {
        m_text = new string(literal);
        fontSize = fSize;
        color = newColor;
        speed = 100; 
    }

    ~TextObject()
    {
        delete m_text; 
    }

    void draw() 
    {
        DrawText(m_text->c_str(), x, y, fontSize, color);
    }
    
    void move_right(int deltaTime) 
    {
        if (IsKeyDown(raylib::KeyboardKey::KEY_D))
        {
            x = x + (speed * deltaTime / 1000);
        }
    }

    override void move_left(int deltaTime)
    {
        if (IsKeyDown(raylib::KeyboardKey::KEY_A))
        {
             x = x - (speed * deltaTime / 500);
        }
    }
};
</file>

